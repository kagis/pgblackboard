export default function workerFactory(inject) { const blob = new Blob(["/* esm.sh - esbuild bundle(monaco-editor@0.52.0/esm/vs/editor/editor.worker) es2022 development */\n(()=\u003e{var a=typeof Reflect==\"object\"?Reflect:null,g=a\u0026\u0026typeof a.apply==\"function\"?a.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)},p;a\u0026\u0026typeof a.ownKeys==\"function\"?p=a.ownKeys:Object.getOwnPropertySymbols?p=function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:p=function(e){return Object.getOwnPropertyNames(e)};function D(n){console\u0026\u0026console.warn\u0026\u0026console.warn(n)}var w=Number.isNaN||function(e){return e!==e};function s(){L.call(this)}s.EventEmitter=s;s.prototype._events=void 0;s.prototype._eventsCount=0;s.prototype._maxListeners=void 0;var y=10;function d(n){if(typeof n!=\"function\")throw new TypeError('The \"listener\" argument must be of type Function. Received type '+typeof n)}Object.defineProperty(s,\"defaultMaxListeners\",{enumerable:!0,get:function(){return y},set:function(n){if(typeof n!=\"number\"||n\u003c0||w(n))throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received '+n+\".\");y=n}});function L(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)\u0026\u0026(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0}s.init=L;s.prototype.setMaxListeners=function(e){if(typeof e!=\"number\"||e\u003c0||w(e))throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received '+e+\".\");return this._maxListeners=e,this};function b(n){return n._maxListeners===void 0?s.defaultMaxListeners:n._maxListeners}s.prototype.getMaxListeners=function(){return b(this)};s.prototype.emit=function(e){for(var t=[],r=1;r\u003carguments.length;r++)t.push(arguments[r]);var i=e===\"error\",u=this._events;if(u!==void 0)i=i\u0026\u0026u.error===void 0;else if(!i)return!1;if(i){var o;if(t.length\u003e0\u0026\u0026(o=t[0]),o instanceof Error)throw o;var c=new Error(\"Unhandled error.\"+(o?\" (\"+o.message+\")\":\"\"));throw c.context=o,c}var l=u[e];if(l===void 0)return!1;if(typeof l==\"function\")g(l,this,t);else for(var m=l.length,M=x(l,m),r=0;r\u003cm;++r)g(M[r],this,t);return!0};function _(n,e,t,r){var i,u,o;if(d(t),u=n._events,u===void 0?(u=n._events=Object.create(null),n._eventsCount=0):(u.newListener!==void 0\u0026\u0026(n.emit(\"newListener\",e,t.listener?t.listener:t),u=n._events),o=u[e]),o===void 0)o=u[e]=t,++n._eventsCount;else if(typeof o==\"function\"?o=u[e]=r?[t,o]:[o,t]:r?o.unshift(t):o.push(t),i=b(n),i\u003e0\u0026\u0026o.length\u003ei\u0026\u0026!o.warned){o.warned=!0;var c=new Error(\"Possible EventEmitter memory leak detected. \"+o.length+\" \"+String(e)+\" listeners added. Use emitter.setMaxListeners() to increase limit\");c.name=\"MaxListenersExceededWarning\",c.emitter=n,c.type=e,c.count=o.length,D(c)}return n}s.prototype.addListener=function(e,t){return _(this,e,t,!1)};s.prototype.on=s.prototype.addListener;s.prototype.prependListener=function(e,t){return _(this,e,t,!0)};function R(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function E(n,e,t){var r={fired:!1,wrapFn:void 0,target:n,type:e,listener:t},i=R.bind(r);return i.listener=t,r.wrapFn=i,i}s.prototype.once=function(e,t){return d(t),this.on(e,E(this,e,t)),this};s.prototype.prependOnceListener=function(e,t){return d(t),this.prependListener(e,E(this,e,t)),this};s.prototype.removeListener=function(e,t){var r,i,u,o,c;if(d(t),i=this._events,i===void 0)return this;if(r=i[e],r===void 0)return this;if(r===t||r.listener===t)--this._eventsCount===0?this._events=Object.create(null):(delete i[e],i.removeListener\u0026\u0026this.emit(\"removeListener\",e,r.listener||t));else if(typeof r!=\"function\"){for(u=-1,o=r.length-1;o\u003e=0;o--)if(r[o]===t||r[o].listener===t){c=r[o].listener,u=o;break}if(u\u003c0)return this;u===0?r.shift():N(r,u),r.length===1\u0026\u0026(i[e]=r[0]),i.removeListener!==void 0\u0026\u0026this.emit(\"removeListener\",e,c||t)}return this};s.prototype.off=s.prototype.removeListener;s.prototype.removeAllListeners=function(e){var t,r,i;if(r=this._events,r===void 0)return this;if(r.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):r[e]!==void 0\u0026\u0026(--this._eventsCount===0?this._events=Object.create(null):delete r[e]),this;if(arguments.length===0){var u=Object.keys(r),o;for(i=0;i\u003cu.length;++i)o=u[i],o!==\"removeListener\"\u0026\u0026this.removeAllListeners(o);return this.removeAllListeners(\"removeListener\"),this._events=Object.create(null),this._eventsCount=0,this}if(t=r[e],typeof t==\"function\")this.removeListener(e,t);else if(t!==void 0)for(i=t.length-1;i\u003e=0;i--)this.removeListener(e,t[i]);return this};function O(n,e,t){var r=n._events;if(r===void 0)return[];var i=r[e];return i===void 0?[]:typeof i==\"function\"?t?[i.listener||i]:[i]:t?P(i):x(i,i.length)}s.prototype.listeners=function(e){return O(this,e,!0)};s.prototype.rawListeners=function(e){return O(this,e,!1)};function C(n,e){return typeof n.listenerCount==\"function\"?n.listenerCount(e):s.prototype.listenerCount.call(n,e)}s.listenerCount=C;s.prototype.listenerCount=function(n){var e=this._events;if(e!==void 0){var t=e[n];if(typeof t==\"function\")return 1;if(t!==void 0)return t.length}return 0};s.prototype.eventNames=function(){return this._eventsCount\u003e0?p(this._events):[]};function x(n,e){for(var t=new Array(e),r=0;r\u003ce;++r)t[r]=n[r];return t}function N(n,e){for(;e+1\u003cn.length;e++)n[e]=n[e+1];n.pop()}function P(n){for(var e=new Array(n.length),t=0;t\u003ce.length;++t)e[t]=n[t].listener||n[t];return e}function v(n){let e=performance.now(),t=Math.floor(e/1e3),r=Math.floor(e*1e6-t*1e9);if(!n)return[t,r];let[i,u]=n;return[t-i,r-u]}v.bigint=function(){let[n,e]=v();return BigInt(n)*1000000000n+BigInt(e)};var h=class extends s{title=\"browser\";browser=!0;env={};argv=[];pid=0;arch=\"unknown\";platform=\"browser\";version=\"\";versions={};emitWarning=()=\u003e{throw new Error(\"process.emitWarning is not supported\")};binding=()=\u003e{throw new Error(\"process.binding is not supported\")};cwd=()=\u003e{throw new Error(\"process.cwd is not supported\")};chdir=e=\u003e{throw new Error(\"process.chdir is not supported\")};umask=()=\u003e18;nextTick=(e,...t)=\u003equeueMicrotask(()=\u003ee(...t));hrtime=v;constructor(){super()}},f=new h;if(typeof Deno\u003c\"u\"){f.name=\"deno\",f.browser=!1,f.pid=Deno.pid,f.cwd=()=\u003eDeno.cwd(),f.chdir=e=\u003eDeno.chdir(e),f.arch=Deno.build.arch,f.platform=Deno.build.os,f.version=\"v18.12.1\",f.versions={node:\"18.12.1\",uv:\"1.43.0\",zlib:\"1.2.11\",brotli:\"1.0.9\",ares:\"1.18.1\",modules:\"108\",nghttp2:\"1.47.0\",napi:\"8\",llhttp:\"6.0.10\",openssl:\"3.0.7+quic\",cldr:\"41.0\",icu:\"71.1\",tz:\"2022b\",unicode:\"14.0\",ngtcp2:\"0.8.1\",nghttp3:\"0.7.0\",...Deno.version},f.env=new Proxy({},{get(e,t){return Deno.env.get(String(t))},ownKeys:()=\u003eReflect.ownKeys(Deno.env.toObject()),getOwnPropertyDescriptor:(e,t)=\u003e{let r=Deno.env.toObject();if(t in Deno.env.toObject()){let i={enumerable:!0,configurable:!0};return typeof t==\"string\"\u0026\u0026(i.value=r[t]),i}},set(e,t,r){return Deno.env.set(String(t),String(r)),r}});let n=[\"\",\"\",...Deno.args];Object.defineProperty(n,\"0\",{get:Deno.execPath}),Object.defineProperty(n,\"1\",{get:()=\u003eDeno.mainModule.startsWith(\"file:\")?new URL(Deno.mainModule).pathname:join(Deno.cwd(),\"$deno$node.js\")}),f.argv=n}else{let n=\"/\";f.cwd=()=\u003en,f.chdir=e=\u003en=e}var j=f;globalThis.__Process$=j;})();\nvar __require = /* @__PURE__ */ ((x) =\u003e typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) =\u003e (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/errors.js\nvar ErrorHandler = class {\n  constructor() {\n    this.listeners = [];\n    this.unexpectedErrorHandler = function(e) {\n      setTimeout(() =\u003e {\n        if (e.stack) {\n          if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n            throw new ErrorNoTelemetry(e.message + \"\\n\\n\" + e.stack);\n          }\n          throw new Error(e.message + \"\\n\\n\" + e.stack);\n        }\n        throw e;\n      }, 0);\n    };\n  }\n  emit(e) {\n    this.listeners.forEach((listener) =\u003e {\n      listener(e);\n    });\n  }\n  onUnexpectedError(e) {\n    this.unexpectedErrorHandler(e);\n    this.emit(e);\n  }\n  // For external errors, we don't want the listeners to be called\n  onUnexpectedExternalError(e) {\n    this.unexpectedErrorHandler(e);\n  }\n};\nvar errorHandler = new ErrorHandler();\nfunction onUnexpectedError(e) {\n  if (!isCancellationError(e)) {\n    errorHandler.onUnexpectedError(e);\n  }\n  return void 0;\n}\nfunction transformErrorForSerialization(error) {\n  if (error instanceof Error) {\n    const { name, message } = error;\n    const stack = error.stacktrace || error.stack;\n    return {\n      $isError: true,\n      name,\n      message,\n      stack,\n      noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\n    };\n  }\n  return error;\n}\nvar canceledName = \"Canceled\";\nfunction isCancellationError(error) {\n  if (error instanceof CancellationError) {\n    return true;\n  }\n  return error instanceof Error \u0026\u0026 error.name === canceledName \u0026\u0026 error.message === canceledName;\n}\nvar CancellationError = class extends Error {\n  constructor() {\n    super(canceledName);\n    this.name = this.message;\n  }\n};\nvar ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"CodeExpectedError\";\n  }\n  static fromError(err) {\n    if (err instanceof _ErrorNoTelemetry) {\n      return err;\n    }\n    const result = new _ErrorNoTelemetry();\n    result.message = err.message;\n    result.stack = err.stack;\n    return result;\n  }\n  static isErrorNoTelemetry(err) {\n    return err.name === \"CodeExpectedError\";\n  }\n};\nvar BugIndicatingError = class _BugIndicatingError extends Error {\n  constructor(message) {\n    super(message || \"An unexpected bug occurred.\");\n    Object.setPrototypeOf(this, _BugIndicatingError.prototype);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/functional.js\nfunction createSingleCallFunction(fn, fnDidRunCallback) {\n  const _this = this;\n  let didCall = false;\n  let result;\n  return function() {\n    if (didCall) {\n      return result;\n    }\n    didCall = true;\n    if (fnDidRunCallback) {\n      try {\n        result = fn.apply(_this, arguments);\n      } finally {\n        fnDidRunCallback();\n      }\n    } else {\n      result = fn.apply(_this, arguments);\n    }\n    return result;\n  };\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js\nvar Iterable;\n(function(Iterable2) {\n  function is(thing) {\n    return thing \u0026\u0026 typeof thing === \"object\" \u0026\u0026 typeof thing[Symbol.iterator] === \"function\";\n  }\n  Iterable2.is = is;\n  const _empty2 = Object.freeze([]);\n  function empty() {\n    return _empty2;\n  }\n  Iterable2.empty = empty;\n  function* single(element) {\n    yield element;\n  }\n  Iterable2.single = single;\n  function wrap(iterableOrElement) {\n    if (is(iterableOrElement)) {\n      return iterableOrElement;\n    } else {\n      return single(iterableOrElement);\n    }\n  }\n  Iterable2.wrap = wrap;\n  function from(iterable) {\n    return iterable || _empty2;\n  }\n  Iterable2.from = from;\n  function* reverse(array) {\n    for (let i = array.length - 1; i \u003e= 0; i--) {\n      yield array[i];\n    }\n  }\n  Iterable2.reverse = reverse;\n  function isEmpty(iterable) {\n    return !iterable || iterable[Symbol.iterator]().next().done === true;\n  }\n  Iterable2.isEmpty = isEmpty;\n  function first(iterable) {\n    return iterable[Symbol.iterator]().next().value;\n  }\n  Iterable2.first = first;\n  function some(iterable, predicate) {\n    let i = 0;\n    for (const element of iterable) {\n      if (predicate(element, i++)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  Iterable2.some = some;\n  function find(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        return element;\n      }\n    }\n    return void 0;\n  }\n  Iterable2.find = find;\n  function* filter(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        yield element;\n      }\n    }\n  }\n  Iterable2.filter = filter;\n  function* map(iterable, fn) {\n    let index = 0;\n    for (const element of iterable) {\n      yield fn(element, index++);\n    }\n  }\n  Iterable2.map = map;\n  function* flatMap(iterable, fn) {\n    let index = 0;\n    for (const element of iterable) {\n      yield* fn(element, index++);\n    }\n  }\n  Iterable2.flatMap = flatMap;\n  function* concat(...iterables) {\n    for (const iterable of iterables) {\n      yield* iterable;\n    }\n  }\n  Iterable2.concat = concat;\n  function reduce(iterable, reducer, initialValue) {\n    let value = initialValue;\n    for (const element of iterable) {\n      value = reducer(value, element);\n    }\n    return value;\n  }\n  Iterable2.reduce = reduce;\n  function* slice(arr, from2, to = arr.length) {\n    if (from2 \u003c 0) {\n      from2 += arr.length;\n    }\n    if (to \u003c 0) {\n      to += arr.length;\n    } else if (to \u003e arr.length) {\n      to = arr.length;\n    }\n    for (; from2 \u003c to; from2++) {\n      yield arr[from2];\n    }\n  }\n  Iterable2.slice = slice;\n  function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n    const consumed = [];\n    if (atMost === 0) {\n      return [consumed, iterable];\n    }\n    const iterator = iterable[Symbol.iterator]();\n    for (let i = 0; i \u003c atMost; i++) {\n      const next = iterator.next();\n      if (next.done) {\n        return [consumed, Iterable2.empty()];\n      }\n      consumed.push(next.value);\n    }\n    return [consumed, { [Symbol.iterator]() {\n      return iterator;\n    } }];\n  }\n  Iterable2.consume = consume;\n  async function asyncToArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n      result.push(item);\n    }\n    return Promise.resolve(result);\n  }\n  Iterable2.asyncToArray = asyncToArray;\n})(Iterable || (Iterable = {}));\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\nvar TRACK_DISPOSABLES = false;\nvar disposableTracker = null;\nfunction setDisposableTracker(tracker) {\n  disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n  const __is_disposable_tracked__ = \"__is_disposable_tracked__\";\n  setDisposableTracker(new class {\n    trackDisposable(x) {\n      const stack = new Error(\"Potentially leaked disposable\").stack;\n      setTimeout(() =\u003e {\n        if (!x[__is_disposable_tracked__]) {\n          console.log(stack);\n        }\n      }, 3e3);\n    }\n    setParent(child, parent) {\n      if (child \u0026\u0026 child !== Disposable.None) {\n        try {\n          child[__is_disposable_tracked__] = true;\n        } catch {\n        }\n      }\n    }\n    markAsDisposed(disposable) {\n      if (disposable \u0026\u0026 disposable !== Disposable.None) {\n        try {\n          disposable[__is_disposable_tracked__] = true;\n        } catch {\n        }\n      }\n    }\n    markAsSingleton(disposable) {\n    }\n  }());\n}\nfunction trackDisposable(x) {\n  disposableTracker?.trackDisposable(x);\n  return x;\n}\nfunction markAsDisposed(disposable) {\n  disposableTracker?.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n  disposableTracker?.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n  if (!disposableTracker) {\n    return;\n  }\n  for (const child of children) {\n    disposableTracker.setParent(child, parent);\n  }\n}\nfunction dispose(arg) {\n  if (Iterable.is(arg)) {\n    const errors = [];\n    for (const d of arg) {\n      if (d) {\n        try {\n          d.dispose();\n        } catch (e) {\n          errors.push(e);\n        }\n      }\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length \u003e 1) {\n      throw new AggregateError(errors, \"Encountered errors while disposing of store\");\n    }\n    return Array.isArray(arg) ? [] : arg;\n  } else if (arg) {\n    arg.dispose();\n    return arg;\n  }\n}\nfunction combinedDisposable(...disposables) {\n  const parent = toDisposable(() =\u003e dispose(disposables));\n  setParentOfDisposables(disposables, parent);\n  return parent;\n}\nfunction toDisposable(fn) {\n  const self = trackDisposable({\n    dispose: createSingleCallFunction(() =\u003e {\n      markAsDisposed(self);\n      fn();\n    })\n  });\n  return self;\n}\nvar DisposableStore = class _DisposableStore {\n  static {\n    this.DISABLE_DISPOSED_WARNING = false;\n  }\n  constructor() {\n    this._toDispose = /* @__PURE__ */ new Set();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  /**\n   * Dispose of all registered disposables and mark this object as disposed.\n   *\n   * Any future disposables added to this object will be disposed of on `add`.\n   */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    markAsDisposed(this);\n    this._isDisposed = true;\n    this.clear();\n  }\n  /**\n   * @return `true` if this object has been disposed of.\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Dispose of all registered disposables but do not mark this object as disposed.\n   */\n  clear() {\n    if (this._toDispose.size === 0) {\n      return;\n    }\n    try {\n      dispose(this._toDispose);\n    } finally {\n      this._toDispose.clear();\n    }\n  }\n  /**\n   * Add a new {@link IDisposable disposable} to the collection.\n   */\n  add(o) {\n    if (!o) {\n      return o;\n    }\n    if (o === this) {\n      throw new Error(\"Cannot register a disposable on itself!\");\n    }\n    setParentOfDisposable(o, this);\n    if (this._isDisposed) {\n      if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {\n        console.warn(new Error(\"Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!\").stack);\n      }\n    } else {\n      this._toDispose.add(o);\n    }\n    return o;\n  }\n  /**\n   * Deletes the value from the store, but does not dispose it.\n   */\n  deleteAndLeak(o) {\n    if (!o) {\n      return;\n    }\n    if (this._toDispose.has(o)) {\n      this._toDispose.delete(o);\n      setParentOfDisposable(o, null);\n    }\n  }\n};\nvar Disposable = class {\n  static {\n    this.None = Object.freeze({ dispose() {\n    } });\n  }\n  constructor() {\n    this._store = new DisposableStore();\n    trackDisposable(this);\n    setParentOfDisposable(this._store, this);\n  }\n  dispose() {\n    markAsDisposed(this);\n    this._store.dispose();\n  }\n  /**\n   * Adds `o` to the collection of disposables managed by this object.\n   */\n  _register(o) {\n    if (o === this) {\n      throw new Error(\"Cannot register a disposable on itself!\");\n    }\n    return this._store.add(o);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js\nvar Node = class _Node {\n  static {\n    this.Undefined = new _Node(void 0);\n  }\n  constructor(element) {\n    this.element = element;\n    this.next = _Node.Undefined;\n    this.prev = _Node.Undefined;\n  }\n};\nvar LinkedList = class {\n  constructor() {\n    this._first = Node.Undefined;\n    this._last = Node.Undefined;\n    this._size = 0;\n  }\n  get size() {\n    return this._size;\n  }\n  isEmpty() {\n    return this._first === Node.Undefined;\n  }\n  clear() {\n    let node = this._first;\n    while (node !== Node.Undefined) {\n      const next = node.next;\n      node.prev = Node.Undefined;\n      node.next = Node.Undefined;\n      node = next;\n    }\n    this._first = Node.Undefined;\n    this._last = Node.Undefined;\n    this._size = 0;\n  }\n  unshift(element) {\n    return this._insert(element, false);\n  }\n  push(element) {\n    return this._insert(element, true);\n  }\n  _insert(element, atTheEnd) {\n    const newNode = new Node(element);\n    if (this._first === Node.Undefined) {\n      this._first = newNode;\n      this._last = newNode;\n    } else if (atTheEnd) {\n      const oldLast = this._last;\n      this._last = newNode;\n      newNode.prev = oldLast;\n      oldLast.next = newNode;\n    } else {\n      const oldFirst = this._first;\n      this._first = newNode;\n      newNode.next = oldFirst;\n      oldFirst.prev = newNode;\n    }\n    this._size += 1;\n    let didRemove = false;\n    return () =\u003e {\n      if (!didRemove) {\n        didRemove = true;\n        this._remove(newNode);\n      }\n    };\n  }\n  shift() {\n    if (this._first === Node.Undefined) {\n      return void 0;\n    } else {\n      const res = this._first.element;\n      this._remove(this._first);\n      return res;\n    }\n  }\n  pop() {\n    if (this._last === Node.Undefined) {\n      return void 0;\n    } else {\n      const res = this._last.element;\n      this._remove(this._last);\n      return res;\n    }\n  }\n  _remove(node) {\n    if (node.prev !== Node.Undefined \u0026\u0026 node.next !== Node.Undefined) {\n      const anchor = node.prev;\n      anchor.next = node.next;\n      node.next.prev = anchor;\n    } else if (node.prev === Node.Undefined \u0026\u0026 node.next === Node.Undefined) {\n      this._first = Node.Undefined;\n      this._last = Node.Undefined;\n    } else if (node.next === Node.Undefined) {\n      this._last = this._last.prev;\n      this._last.next = Node.Undefined;\n    } else if (node.prev === Node.Undefined) {\n      this._first = this._first.next;\n      this._first.prev = Node.Undefined;\n    }\n    this._size -= 1;\n  }\n  *[Symbol.iterator]() {\n    let node = this._first;\n    while (node !== Node.Undefined) {\n      yield node.element;\n      node = node.next;\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js\nvar hasPerformanceNow = globalThis.performance \u0026\u0026 typeof globalThis.performance.now === \"function\";\nvar StopWatch = class _StopWatch {\n  static create(highResolution) {\n    return new _StopWatch(highResolution);\n  }\n  constructor(highResolution) {\n    this._now = hasPerformanceNow \u0026\u0026 highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);\n    this._startTime = this._now();\n    this._stopTime = -1;\n  }\n  stop() {\n    this._stopTime = this._now();\n  }\n  reset() {\n    this._startTime = this._now();\n    this._stopTime = -1;\n  }\n  elapsed() {\n    if (this._stopTime !== -1) {\n      return this._stopTime - this._startTime;\n    }\n    return this._now() - this._startTime;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/event.js\nvar _enableListenerGCedWarning = false;\nvar _enableDisposeWithListenerWarning = false;\nvar _enableSnapshotPotentialLeakWarning = false;\nvar Event;\n(function(Event2) {\n  Event2.None = () =\u003e Disposable.None;\n  function _addLeakageTraceLogic(options) {\n    if (_enableSnapshotPotentialLeakWarning) {\n      const { onDidAddListener: origListenerDidAdd } = options;\n      const stack = Stacktrace.create();\n      let count = 0;\n      options.onDidAddListener = () =\u003e {\n        if (++count === 2) {\n          console.warn(\"snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here\");\n          stack.print();\n        }\n        origListenerDidAdd?.();\n      };\n    }\n  }\n  function defer(event, disposable) {\n    return debounce(event, () =\u003e void 0, 0, void 0, true, void 0, disposable);\n  }\n  Event2.defer = defer;\n  function once(event) {\n    return (listener, thisArgs = null, disposables) =\u003e {\n      let didFire = false;\n      let result = void 0;\n      result = event((e) =\u003e {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n      if (didFire) {\n        result.dispose();\n      }\n      return result;\n    };\n  }\n  Event2.once = once;\n  function onceIf(event, condition) {\n    return Event2.once(Event2.filter(event, condition));\n  }\n  Event2.onceIf = onceIf;\n  function map(event, map2, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) =\u003e event((i) =\u003e listener.call(thisArgs, map2(i)), null, disposables), disposable);\n  }\n  Event2.map = map;\n  function forEach(event, each, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) =\u003e event((i) =\u003e {\n      each(i);\n      listener.call(thisArgs, i);\n    }, null, disposables), disposable);\n  }\n  Event2.forEach = forEach;\n  function filter(event, filter2, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) =\u003e event((e) =\u003e filter2(e) \u0026\u0026 listener.call(thisArgs, e), null, disposables), disposable);\n  }\n  Event2.filter = filter;\n  function signal(event) {\n    return event;\n  }\n  Event2.signal = signal;\n  function any(...events) {\n    return (listener, thisArgs = null, disposables) =\u003e {\n      const disposable = combinedDisposable(...events.map((event) =\u003e event((e) =\u003e listener.call(thisArgs, e))));\n      return addAndReturnDisposable(disposable, disposables);\n    };\n  }\n  Event2.any = any;\n  function reduce(event, merge, initial, disposable) {\n    let output = initial;\n    return map(event, (e) =\u003e {\n      output = merge(output, e);\n      return output;\n    }, disposable);\n  }\n  Event2.reduce = reduce;\n  function snapshot(event, disposable) {\n    let listener;\n    const options = {\n      onWillAddFirstListener() {\n        listener = event(emitter.fire, emitter);\n      },\n      onDidRemoveLastListener() {\n        listener?.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    const emitter = new Emitter(options);\n    disposable?.add(emitter);\n    return emitter.event;\n  }\n  function addAndReturnDisposable(d, store) {\n    if (store instanceof Array) {\n      store.push(d);\n    } else if (store) {\n      store.add(d);\n    }\n    return d;\n  }\n  function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n    let subscription;\n    let output = void 0;\n    let handle = void 0;\n    let numDebouncedCalls = 0;\n    let doFire;\n    const options = {\n      leakWarningThreshold,\n      onWillAddFirstListener() {\n        subscription = event((cur) =\u003e {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n          if (leading \u0026\u0026 !handle) {\n            emitter.fire(output);\n            output = void 0;\n          }\n          doFire = () =\u003e {\n            const _output = output;\n            output = void 0;\n            handle = void 0;\n            if (!leading || numDebouncedCalls \u003e 1) {\n              emitter.fire(_output);\n            }\n            numDebouncedCalls = 0;\n          };\n          if (typeof delay === \"number\") {\n            clearTimeout(handle);\n            handle = setTimeout(doFire, delay);\n          } else {\n            if (handle === void 0) {\n              handle = 0;\n              queueMicrotask(doFire);\n            }\n          }\n        });\n      },\n      onWillRemoveListener() {\n        if (flushOnListenerRemove \u0026\u0026 numDebouncedCalls \u003e 0) {\n          doFire?.();\n        }\n      },\n      onDidRemoveLastListener() {\n        doFire = void 0;\n        subscription.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    const emitter = new Emitter(options);\n    disposable?.add(emitter);\n    return emitter.event;\n  }\n  Event2.debounce = debounce;\n  function accumulate(event, delay = 0, disposable) {\n    return Event2.debounce(event, (last, e) =\u003e {\n      if (!last) {\n        return [e];\n      }\n      last.push(e);\n      return last;\n    }, delay, void 0, true, void 0, disposable);\n  }\n  Event2.accumulate = accumulate;\n  function latch(event, equals3 = (a, b) =\u003e a === b, disposable) {\n    let firstCall = true;\n    let cache;\n    return filter(event, (value) =\u003e {\n      const shouldEmit = firstCall || !equals3(value, cache);\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    }, disposable);\n  }\n  Event2.latch = latch;\n  function split(event, isT, disposable) {\n    return [\n      Event2.filter(event, isT, disposable),\n      Event2.filter(event, (e) =\u003e !isT(e), disposable)\n    ];\n  }\n  Event2.split = split;\n  function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n    let buffer2 = _buffer.slice();\n    let listener = event((e) =\u003e {\n      if (buffer2) {\n        buffer2.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n    if (disposable) {\n      disposable.add(listener);\n    }\n    const flush = () =\u003e {\n      buffer2?.forEach((e) =\u003e emitter.fire(e));\n      buffer2 = null;\n    };\n    const emitter = new Emitter({\n      onWillAddFirstListener() {\n        if (!listener) {\n          listener = event((e) =\u003e emitter.fire(e));\n          if (disposable) {\n            disposable.add(listener);\n          }\n        }\n      },\n      onDidAddFirstListener() {\n        if (buffer2) {\n          if (flushAfterTimeout) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onDidRemoveLastListener() {\n        if (listener) {\n          listener.dispose();\n        }\n        listener = null;\n      }\n    });\n    if (disposable) {\n      disposable.add(emitter);\n    }\n    return emitter.event;\n  }\n  Event2.buffer = buffer;\n  function chain(event, sythensize) {\n    const fn = (listener, thisArgs, disposables) =\u003e {\n      const cs = sythensize(new ChainableSynthesis());\n      return event(function(value) {\n        const result = cs.evaluate(value);\n        if (result !== HaltChainable) {\n          listener.call(thisArgs, result);\n        }\n      }, void 0, disposables);\n    };\n    return fn;\n  }\n  Event2.chain = chain;\n  const HaltChainable = Symbol(\"HaltChainable\");\n  class ChainableSynthesis {\n    constructor() {\n      this.steps = [];\n    }\n    map(fn) {\n      this.steps.push(fn);\n      return this;\n    }\n    forEach(fn) {\n      this.steps.push((v) =\u003e {\n        fn(v);\n        return v;\n      });\n      return this;\n    }\n    filter(fn) {\n      this.steps.push((v) =\u003e fn(v) ? v : HaltChainable);\n      return this;\n    }\n    reduce(merge, initial) {\n      let last = initial;\n      this.steps.push((v) =\u003e {\n        last = merge(last, v);\n        return last;\n      });\n      return this;\n    }\n    latch(equals3 = (a, b) =\u003e a === b) {\n      let firstCall = true;\n      let cache;\n      this.steps.push((value) =\u003e {\n        const shouldEmit = firstCall || !equals3(value, cache);\n        firstCall = false;\n        cache = value;\n        return shouldEmit ? value : HaltChainable;\n      });\n      return this;\n    }\n    evaluate(value) {\n      for (const step of this.steps) {\n        value = step(value);\n        if (value === HaltChainable) {\n          break;\n        }\n      }\n      return value;\n    }\n  }\n  function fromNodeEventEmitter(emitter, eventName, map2 = (id) =\u003e id) {\n    const fn = (...args) =\u003e result.fire(map2(...args));\n    const onFirstListenerAdd = () =\u003e emitter.on(eventName, fn);\n    const onLastListenerRemove = () =\u003e emitter.removeListener(eventName, fn);\n    const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n    return result.event;\n  }\n  Event2.fromNodeEventEmitter = fromNodeEventEmitter;\n  function fromDOMEventEmitter(emitter, eventName, map2 = (id) =\u003e id) {\n    const fn = (...args) =\u003e result.fire(map2(...args));\n    const onFirstListenerAdd = () =\u003e emitter.addEventListener(eventName, fn);\n    const onLastListenerRemove = () =\u003e emitter.removeEventListener(eventName, fn);\n    const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n    return result.event;\n  }\n  Event2.fromDOMEventEmitter = fromDOMEventEmitter;\n  function toPromise(event) {\n    return new Promise((resolve2) =\u003e once(event)(resolve2));\n  }\n  Event2.toPromise = toPromise;\n  function fromPromise(promise) {\n    const result = new Emitter();\n    promise.then((res) =\u003e {\n      result.fire(res);\n    }, () =\u003e {\n      result.fire(void 0);\n    }).finally(() =\u003e {\n      result.dispose();\n    });\n    return result.event;\n  }\n  Event2.fromPromise = fromPromise;\n  function forward(from, to) {\n    return from((e) =\u003e to.fire(e));\n  }\n  Event2.forward = forward;\n  function runAndSubscribe(event, handler, initial) {\n    handler(initial);\n    return event((e) =\u003e handler(e));\n  }\n  Event2.runAndSubscribe = runAndSubscribe;\n  class EmitterObserver {\n    constructor(_observable, store) {\n      this._observable = _observable;\n      this._counter = 0;\n      this._hasChanged = false;\n      const options = {\n        onWillAddFirstListener: () =\u003e {\n          _observable.addObserver(this);\n          this._observable.reportChanges();\n        },\n        onDidRemoveLastListener: () =\u003e {\n          _observable.removeObserver(this);\n        }\n      };\n      if (!store) {\n        _addLeakageTraceLogic(options);\n      }\n      this.emitter = new Emitter(options);\n      if (store) {\n        store.add(this.emitter);\n      }\n    }\n    beginUpdate(_observable) {\n      this._counter++;\n    }\n    handlePossibleChange(_observable) {\n    }\n    handleChange(_observable, _change) {\n      this._hasChanged = true;\n    }\n    endUpdate(_observable) {\n      this._counter--;\n      if (this._counter === 0) {\n        this._observable.reportChanges();\n        if (this._hasChanged) {\n          this._hasChanged = false;\n          this.emitter.fire(this._observable.get());\n        }\n      }\n    }\n  }\n  function fromObservable(obs, store) {\n    const observer = new EmitterObserver(obs, store);\n    return observer.emitter.event;\n  }\n  Event2.fromObservable = fromObservable;\n  function fromObservableLight(observable) {\n    return (listener, thisArgs, disposables) =\u003e {\n      let count = 0;\n      let didChange = false;\n      const observer = {\n        beginUpdate() {\n          count++;\n        },\n        endUpdate() {\n          count--;\n          if (count === 0) {\n            observable.reportChanges();\n            if (didChange) {\n              didChange = false;\n              listener.call(thisArgs);\n            }\n          }\n        },\n        handlePossibleChange() {\n        },\n        handleChange() {\n          didChange = true;\n        }\n      };\n      observable.addObserver(observer);\n      observable.reportChanges();\n      const disposable = {\n        dispose() {\n          observable.removeObserver(observer);\n        }\n      };\n      if (disposables instanceof DisposableStore) {\n        disposables.add(disposable);\n      } else if (Array.isArray(disposables)) {\n        disposables.push(disposable);\n      }\n      return disposable;\n    };\n  }\n  Event2.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nvar EventProfiling = class _EventProfiling {\n  static {\n    this.all = /* @__PURE__ */ new Set();\n  }\n  static {\n    this._idPool = 0;\n  }\n  constructor(name) {\n    this.listenerCount = 0;\n    this.invocationCount = 0;\n    this.elapsedOverall = 0;\n    this.durations = [];\n    this.name = `${name}_${_EventProfiling._idPool++}`;\n    _EventProfiling.all.add(this);\n  }\n  start(listenerCount) {\n    this._stopWatch = new StopWatch();\n    this.listenerCount = listenerCount;\n  }\n  stop() {\n    if (this._stopWatch) {\n      const elapsed = this._stopWatch.elapsed();\n      this.durations.push(elapsed);\n      this.elapsedOverall += elapsed;\n      this.invocationCount += 1;\n      this._stopWatch = void 0;\n    }\n  }\n};\nvar _globalLeakWarningThreshold = -1;\nvar LeakageMonitor = class _LeakageMonitor {\n  static {\n    this._idPool = 1;\n  }\n  constructor(_errorHandler, threshold, name = (_LeakageMonitor._idPool++).toString(16).padStart(3, \"0\")) {\n    this._errorHandler = _errorHandler;\n    this.threshold = threshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n  dispose() {\n    this._stacks?.clear();\n  }\n  check(stack, listenerCount) {\n    const threshold = this.threshold;\n    if (threshold \u003c= 0 || listenerCount \u003c threshold) {\n      return void 0;\n    }\n    if (!this._stacks) {\n      this._stacks = /* @__PURE__ */ new Map();\n    }\n    const count = this._stacks.get(stack.value) || 0;\n    this._stacks.set(stack.value, count + 1);\n    this._warnCountdown -= 1;\n    if (this._warnCountdown \u003c= 0) {\n      this._warnCountdown = threshold * 0.5;\n      const [topStack, topCount] = this.getMostFrequentStack();\n      const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n      console.warn(message);\n      console.warn(topStack);\n      const error = new ListenerLeakError(message, topStack);\n      this._errorHandler(error);\n    }\n    return () =\u003e {\n      const count2 = this._stacks.get(stack.value) || 0;\n      this._stacks.set(stack.value, count2 - 1);\n    };\n  }\n  getMostFrequentStack() {\n    if (!this._stacks) {\n      return void 0;\n    }\n    let topStack;\n    let topCount = 0;\n    for (const [stack, count] of this._stacks) {\n      if (!topStack || topCount \u003c count) {\n        topStack = [stack, count];\n        topCount = count;\n      }\n    }\n    return topStack;\n  }\n};\nvar Stacktrace = class _Stacktrace {\n  static create() {\n    const err = new Error();\n    return new _Stacktrace(err.stack ?? \"\");\n  }\n  constructor(value) {\n    this.value = value;\n  }\n  print() {\n    console.warn(this.value.split(\"\\n\").slice(2).join(\"\\n\"));\n  }\n};\nvar ListenerLeakError = class extends Error {\n  constructor(message, stack) {\n    super(message);\n    this.name = \"ListenerLeakError\";\n    this.stack = stack;\n  }\n};\nvar ListenerRefusalError = class extends Error {\n  constructor(message, stack) {\n    super(message);\n    this.name = \"ListenerRefusalError\";\n    this.stack = stack;\n  }\n};\nvar UniqueContainer = class {\n  constructor(value) {\n    this.value = value;\n  }\n};\nvar compactionThreshold = 2;\nvar forEachListener = (listeners, fn) =\u003e {\n  if (listeners instanceof UniqueContainer) {\n    fn(listeners);\n  } else {\n    for (let i = 0; i \u003c listeners.length; i++) {\n      const l = listeners[i];\n      if (l) {\n        fn(l);\n      }\n    }\n  }\n};\nvar _listenerFinalizers;\nif (_enableListenerGCedWarning) {\n  const leaks = [];\n  setInterval(() =\u003e {\n    if (leaks.length === 0) {\n      return;\n    }\n    console.warn(\"[LEAKING LISTENERS] GC'ed these listeners that were NOT yet disposed:\");\n    console.warn(leaks.join(\"\\n\"));\n    leaks.length = 0;\n  }, 3e3);\n  _listenerFinalizers = new FinalizationRegistry((heldValue) =\u003e {\n    if (typeof heldValue === \"string\") {\n      leaks.push(heldValue);\n    }\n  });\n}\nvar Emitter = class {\n  constructor(options) {\n    this._size = 0;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold \u003e 0 || this._options?.leakWarningThreshold ? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) : void 0;\n    this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : void 0;\n    this._deliveryQueue = this._options?.deliveryQueue;\n  }\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      if (this._deliveryQueue?.current === this) {\n        this._deliveryQueue.reset();\n      }\n      if (this._listeners) {\n        if (_enableDisposeWithListenerWarning) {\n          const listeners = this._listeners;\n          queueMicrotask(() =\u003e {\n            forEachListener(listeners, (l) =\u003e l.stack?.print());\n          });\n        }\n        this._listeners = void 0;\n        this._size = 0;\n      }\n      this._options?.onDidRemoveLastListener?.();\n      this._leakageMon?.dispose();\n    }\n  }\n  /**\n   * For the public to allow to subscribe\n   * to events from this Emitter\n   */\n  get event() {\n    this._event ??= (callback, thisArgs, disposables) =\u003e {\n      if (this._leakageMon \u0026\u0026 this._size \u003e this._leakageMon.threshold ** 2) {\n        const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n        console.warn(message);\n        const tuple = this._leakageMon.getMostFrequentStack() ?? [\"UNKNOWN stack\", -1];\n        const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n        const errorHandler2 = this._options?.onListenerError || onUnexpectedError;\n        errorHandler2(error);\n        return Disposable.None;\n      }\n      if (this._disposed) {\n        return Disposable.None;\n      }\n      if (thisArgs) {\n        callback = callback.bind(thisArgs);\n      }\n      const contained = new UniqueContainer(callback);\n      let removeMonitor;\n      let stack;\n      if (this._leakageMon \u0026\u0026 this._size \u003e= Math.ceil(this._leakageMon.threshold * 0.2)) {\n        contained.stack = Stacktrace.create();\n        removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n      }\n      if (_enableDisposeWithListenerWarning) {\n        contained.stack = stack ?? Stacktrace.create();\n      }\n      if (!this._listeners) {\n        this._options?.onWillAddFirstListener?.(this);\n        this._listeners = contained;\n        this._options?.onDidAddFirstListener?.(this);\n      } else if (this._listeners instanceof UniqueContainer) {\n        this._deliveryQueue ??= new EventDeliveryQueuePrivate();\n        this._listeners = [this._listeners, contained];\n      } else {\n        this._listeners.push(contained);\n      }\n      this._size++;\n      const result = toDisposable(() =\u003e {\n        _listenerFinalizers?.unregister(result);\n        removeMonitor?.();\n        this._removeListener(contained);\n      });\n      if (disposables instanceof DisposableStore) {\n        disposables.add(result);\n      } else if (Array.isArray(disposables)) {\n        disposables.push(result);\n      }\n      if (_listenerFinalizers) {\n        const stack2 = new Error().stack.split(\"\\n\").slice(2, 3).join(\"\\n\").trim();\n        const match = /(file:|vscode-file:\\/\\/vscode-app)?(\\/[^:]*:\\d+:\\d+)/.exec(stack2);\n        _listenerFinalizers.register(result, match?.[2] ?? stack2, result);\n      }\n      return result;\n    };\n    return this._event;\n  }\n  _removeListener(listener) {\n    this._options?.onWillRemoveListener?.(this);\n    if (!this._listeners) {\n      return;\n    }\n    if (this._size === 1) {\n      this._listeners = void 0;\n      this._options?.onDidRemoveLastListener?.(this);\n      this._size = 0;\n      return;\n    }\n    const listeners = this._listeners;\n    const index = listeners.indexOf(listener);\n    if (index === -1) {\n      console.log(\"disposed?\", this._disposed);\n      console.log(\"size?\", this._size);\n      console.log(\"arr?\", JSON.stringify(this._listeners));\n      throw new Error(\"Attempted to dispose unknown listener\");\n    }\n    this._size--;\n    listeners[index] = void 0;\n    const adjustDeliveryQueue = this._deliveryQueue.current === this;\n    if (this._size * compactionThreshold \u003c= listeners.length) {\n      let n = 0;\n      for (let i = 0; i \u003c listeners.length; i++) {\n        if (listeners[i]) {\n          listeners[n++] = listeners[i];\n        } else if (adjustDeliveryQueue) {\n          this._deliveryQueue.end--;\n          if (n \u003c this._deliveryQueue.i) {\n            this._deliveryQueue.i--;\n          }\n        }\n      }\n      listeners.length = n;\n    }\n  }\n  _deliver(listener, value) {\n    if (!listener) {\n      return;\n    }\n    const errorHandler2 = this._options?.onListenerError || onUnexpectedError;\n    if (!errorHandler2) {\n      listener.value(value);\n      return;\n    }\n    try {\n      listener.value(value);\n    } catch (e) {\n      errorHandler2(e);\n    }\n  }\n  /** Delivers items in the queue. Assumes the queue is ready to go. */\n  _deliverQueue(dq) {\n    const listeners = dq.current._listeners;\n    while (dq.i \u003c dq.end) {\n      this._deliver(listeners[dq.i++], dq.value);\n    }\n    dq.reset();\n  }\n  /**\n   * To be kept private to fire an event to\n   * subscribers\n   */\n  fire(event) {\n    if (this._deliveryQueue?.current) {\n      this._deliverQueue(this._deliveryQueue);\n      this._perfMon?.stop();\n    }\n    this._perfMon?.start(this._size);\n    if (!this._listeners) {\n    } else if (this._listeners instanceof UniqueContainer) {\n      this._deliver(this._listeners, event);\n    } else {\n      const dq = this._deliveryQueue;\n      dq.enqueue(this, event, this._listeners.length);\n      this._deliverQueue(dq);\n    }\n    this._perfMon?.stop();\n  }\n  hasListeners() {\n    return this._size \u003e 0;\n  }\n};\nvar EventDeliveryQueuePrivate = class {\n  constructor() {\n    this.i = -1;\n    this.end = 0;\n  }\n  enqueue(emitter, value, end) {\n    this.i = 0;\n    this.end = end;\n    this.current = emitter;\n    this.value = value;\n  }\n  reset() {\n    this.i = this.end;\n    this.current = void 0;\n    this.value = void 0;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/nls.messages.js\nfunction getNLSMessages() {\n  return globalThis._VSCODE_NLS_MESSAGES;\n}\nfunction getNLSLanguage() {\n  return globalThis._VSCODE_NLS_LANGUAGE;\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/nls.js\nvar isPseudo = getNLSLanguage() === \"pseudo\" || typeof document !== \"undefined\" \u0026\u0026 document.location \u0026\u0026 document.location.hash.indexOf(\"pseudo=true\") \u003e= 0;\nfunction _format(message, args) {\n  let result;\n  if (args.length === 0) {\n    result = message;\n  } else {\n    result = message.replace(/\\{(\\d+)\\}/g, (match, rest) =\u003e {\n      const index = rest[0];\n      const arg = args[index];\n      let result2 = match;\n      if (typeof arg === \"string\") {\n        result2 = arg;\n      } else if (typeof arg === \"number\" || typeof arg === \"boolean\" || arg === void 0 || arg === null) {\n        result2 = String(arg);\n      }\n      return result2;\n    });\n  }\n  if (isPseudo) {\n    result = \"\\uFF3B\" + result.replace(/[aouei]/g, \"$\u0026$\u0026\") + \"\\uFF3D\";\n  }\n  return result;\n}\nfunction localize(data, message, ...args) {\n  if (typeof data === \"number\") {\n    return _format(lookupMessage(data, message), args);\n  }\n  return _format(message, args);\n}\nfunction lookupMessage(index, fallback) {\n  const message = getNLSMessages()?.[index];\n  if (typeof message !== \"string\") {\n    if (typeof fallback === \"string\") {\n      return fallback;\n    }\n    throw new Error(`!!! NLS MISSING: ${index} !!!`);\n  }\n  return message;\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/platform.js\nvar LANGUAGE_DEFAULT = \"en\";\nvar _isWindows = false;\nvar _isMacintosh = false;\nvar _isLinux = false;\nvar _isLinuxSnap = false;\nvar _isNative = false;\nvar _isWeb = false;\nvar _isElectron = false;\nvar _isIOS = false;\nvar _isCI = false;\nvar _isMobile = false;\nvar _locale = void 0;\nvar _language = LANGUAGE_DEFAULT;\nvar _platformLocale = LANGUAGE_DEFAULT;\nvar _translationsConfigFile = void 0;\nvar _userAgent = void 0;\nvar $globalThis = globalThis;\nvar nodeProcess = void 0;\nif (typeof $globalThis.vscode !== \"undefined\" \u0026\u0026 typeof $globalThis.vscode.process !== \"undefined\") {\n  nodeProcess = $globalThis.vscode.process;\n} else if (typeof __Process$ !== \"undefined\" \u0026\u0026 typeof __Process$?.versions?.node === \"string\") {\n  nodeProcess = __Process$;\n}\nvar isElectronProcess = typeof nodeProcess?.versions?.electron === \"string\";\nvar isElectronRenderer = isElectronProcess \u0026\u0026 nodeProcess?.type === \"renderer\";\nif (typeof nodeProcess === \"object\") {\n  _isWindows = nodeProcess.platform === \"win32\";\n  _isMacintosh = nodeProcess.platform === \"darwin\";\n  _isLinux = nodeProcess.platform === \"linux\";\n  _isLinuxSnap = _isLinux \u0026\u0026 !!nodeProcess.env[\"SNAP\"] \u0026\u0026 !!nodeProcess.env[\"SNAP_REVISION\"];\n  _isElectron = isElectronProcess;\n  _isCI = !!nodeProcess.env[\"CI\"] || !!nodeProcess.env[\"BUILD_ARTIFACTSTAGINGDIRECTORY\"];\n  _locale = LANGUAGE_DEFAULT;\n  _language = LANGUAGE_DEFAULT;\n  const rawNlsConfig = nodeProcess.env[\"VSCODE_NLS_CONFIG\"];\n  if (rawNlsConfig) {\n    try {\n      const nlsConfig = JSON.parse(rawNlsConfig);\n      _locale = nlsConfig.userLocale;\n      _platformLocale = nlsConfig.osLocale;\n      _language = nlsConfig.resolvedLanguage || LANGUAGE_DEFAULT;\n      _translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;\n    } catch (e) {\n    }\n  }\n  _isNative = true;\n} else if (typeof navigator === \"object\" \u0026\u0026 !isElectronRenderer) {\n  _userAgent = navigator.userAgent;\n  _isWindows = _userAgent.indexOf(\"Windows\") \u003e= 0;\n  _isMacintosh = _userAgent.indexOf(\"Macintosh\") \u003e= 0;\n  _isIOS = (_userAgent.indexOf(\"Macintosh\") \u003e= 0 || _userAgent.indexOf(\"iPad\") \u003e= 0 || _userAgent.indexOf(\"iPhone\") \u003e= 0) \u0026\u0026 !!navigator.maxTouchPoints \u0026\u0026 navigator.maxTouchPoints \u003e 0;\n  _isLinux = _userAgent.indexOf(\"Linux\") \u003e= 0;\n  _isMobile = _userAgent?.indexOf(\"Mobi\") \u003e= 0;\n  _isWeb = true;\n  _language = getNLSLanguage() || LANGUAGE_DEFAULT;\n  _locale = navigator.language.toLowerCase();\n  _platformLocale = _locale;\n} else {\n  console.error(\"Unable to resolve platform.\");\n}\nvar _platform = 0;\nif (_isMacintosh) {\n  _platform = 1;\n} else if (_isWindows) {\n  _platform = 3;\n} else if (_isLinux) {\n  _platform = 2;\n}\nvar isWindows = _isWindows;\nvar isMacintosh = _isMacintosh;\nvar isNative = _isNative;\nvar isWeb = _isWeb;\nvar isWebWorker = _isWeb \u0026\u0026 typeof $globalThis.importScripts === \"function\";\nvar webWorkerOrigin = isWebWorker ? $globalThis.origin : void 0;\nvar userAgent = _userAgent;\nvar setTimeout0IsFaster = typeof $globalThis.postMessage === \"function\" \u0026\u0026 !$globalThis.importScripts;\nvar setTimeout0 = (() =\u003e {\n  if (setTimeout0IsFaster) {\n    const pending = [];\n    $globalThis.addEventListener(\"message\", (e) =\u003e {\n      if (e.data \u0026\u0026 e.data.vscodeScheduleAsyncWork) {\n        for (let i = 0, len = pending.length; i \u003c len; i++) {\n          const candidate = pending[i];\n          if (candidate.id === e.data.vscodeScheduleAsyncWork) {\n            pending.splice(i, 1);\n            candidate.callback();\n            return;\n          }\n        }\n      }\n    });\n    let lastId = 0;\n    return (callback) =\u003e {\n      const myId = ++lastId;\n      pending.push({\n        id: myId,\n        callback\n      });\n      $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, \"*\");\n    };\n  }\n  return (callback) =\u003e setTimeout(callback);\n})();\nvar isChrome = !!(userAgent \u0026\u0026 userAgent.indexOf(\"Chrome\") \u003e= 0);\nvar isFirefox = !!(userAgent \u0026\u0026 userAgent.indexOf(\"Firefox\") \u003e= 0);\nvar isSafari = !!(!isChrome \u0026\u0026 (userAgent \u0026\u0026 userAgent.indexOf(\"Safari\") \u003e= 0));\nvar isEdge = !!(userAgent \u0026\u0026 userAgent.indexOf(\"Edg/\") \u003e= 0);\nvar isAndroid = !!(userAgent \u0026\u0026 userAgent.indexOf(\"Android\") \u003e= 0);\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/cache.js\nfunction identity(t) {\n  return t;\n}\nvar LRUCachedFunction = class {\n  constructor(arg1, arg2) {\n    this.lastCache = void 0;\n    this.lastArgKey = void 0;\n    if (typeof arg1 === \"function\") {\n      this._fn = arg1;\n      this._computeKey = identity;\n    } else {\n      this._fn = arg2;\n      this._computeKey = arg1.getCacheKey;\n    }\n  }\n  get(arg) {\n    const key = this._computeKey(arg);\n    if (this.lastArgKey !== key) {\n      this.lastArgKey = key;\n      this.lastCache = this._fn(arg);\n    }\n    return this.lastCache;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js\nvar Lazy = class {\n  constructor(executor) {\n    this.executor = executor;\n    this._didRun = false;\n  }\n  /**\n   * Get the wrapped value.\n   *\n   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n   */\n  get value() {\n    if (!this._didRun) {\n      try {\n        this._value = this.executor();\n      } catch (err) {\n        this._error = err;\n      } finally {\n        this._didRun = true;\n      }\n    }\n    if (this._error) {\n      throw this._error;\n    }\n    return this._value;\n  }\n  /**\n   * Get the wrapped value without forcing evaluation.\n   */\n  get rawValue() {\n    return this._value;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/strings.js\nfunction escapeRegExpCharacters(value) {\n  return value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, \"\\\\$\u0026\");\n}\nfunction splitLines(str) {\n  return str.split(/\\r\\n|\\r|\\n/);\n}\nfunction firstNonWhitespaceIndex(str) {\n  for (let i = 0, len = str.length; i \u003c len; i++) {\n    const chCode = str.charCodeAt(i);\n    if (chCode !== 32 \u0026\u0026 chCode !== 9) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction lastNonWhitespaceIndex(str, startIndex = str.length - 1) {\n  for (let i = startIndex; i \u003e= 0; i--) {\n    const chCode = str.charCodeAt(i);\n    if (chCode !== 32 \u0026\u0026 chCode !== 9) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction isUpperAsciiLetter(code) {\n  return code \u003e= 65 \u0026\u0026 code \u003c= 90;\n}\nfunction isHighSurrogate(charCode) {\n  return 55296 \u003c= charCode \u0026\u0026 charCode \u003c= 56319;\n}\nfunction isLowSurrogate(charCode) {\n  return 56320 \u003c= charCode \u0026\u0026 charCode \u003c= 57343;\n}\nfunction computeCodePoint(highSurrogate, lowSurrogate) {\n  return (highSurrogate - 55296 \u003c\u003c 10) + (lowSurrogate - 56320) + 65536;\n}\nfunction getNextCodePoint(str, len, offset) {\n  const charCode = str.charCodeAt(offset);\n  if (isHighSurrogate(charCode) \u0026\u0026 offset + 1 \u003c len) {\n    const nextCharCode = str.charCodeAt(offset + 1);\n    if (isLowSurrogate(nextCharCode)) {\n      return computeCodePoint(charCode, nextCharCode);\n    }\n  }\n  return charCode;\n}\nvar IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\nfunction isBasicASCII(str) {\n  return IS_BASIC_ASCII.test(str);\n}\nvar UTF8_BOM_CHARACTER = String.fromCharCode(\n  65279\n  /* CharCode.UTF8_BOM */\n);\nvar GraphemeBreakTree = class _GraphemeBreakTree {\n  static {\n    this._INSTANCE = null;\n  }\n  static getInstance() {\n    if (!_GraphemeBreakTree._INSTANCE) {\n      _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();\n    }\n    return _GraphemeBreakTree._INSTANCE;\n  }\n  constructor() {\n    this._data = getGraphemeBreakRawData();\n  }\n  getGraphemeBreakType(codePoint) {\n    if (codePoint \u003c 32) {\n      if (codePoint === 10) {\n        return 3;\n      }\n      if (codePoint === 13) {\n        return 2;\n      }\n      return 4;\n    }\n    if (codePoint \u003c 127) {\n      return 0;\n    }\n    const data = this._data;\n    const nodeCount = data.length / 3;\n    let nodeIndex = 1;\n    while (nodeIndex \u003c= nodeCount) {\n      if (codePoint \u003c data[3 * nodeIndex]) {\n        nodeIndex = 2 * nodeIndex;\n      } else if (codePoint \u003e data[3 * nodeIndex + 1]) {\n        nodeIndex = 2 * nodeIndex + 1;\n      } else {\n        return data[3 * nodeIndex + 2];\n      }\n    }\n    return 0;\n  }\n};\nfunction getGraphemeBreakRawData() {\n  return JSON.parse(\"[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]\");\n}\nvar AmbiguousCharacters = class _AmbiguousCharacters {\n  static {\n    this.ambiguousCharacterData = new Lazy(() =\u003e {\n      return JSON.parse('{\"_common\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],\"_default\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"cs\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"de\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"es\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"fr\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"it\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ja\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\"ko\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pl\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pt-BR\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"qps-ploc\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ru\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"tr\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"zh-hans\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\"zh-hant\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');\n    });\n  }\n  static {\n    this.cache = new LRUCachedFunction({ getCacheKey: JSON.stringify }, (locales) =\u003e {\n      function arrayToMap(arr) {\n        const result = /* @__PURE__ */ new Map();\n        for (let i = 0; i \u003c arr.length; i += 2) {\n          result.set(arr[i], arr[i + 1]);\n        }\n        return result;\n      }\n      function mergeMaps(map1, map2) {\n        const result = new Map(map1);\n        for (const [key, value] of map2) {\n          result.set(key, value);\n        }\n        return result;\n      }\n      function intersectMaps(map1, map2) {\n        if (!map1) {\n          return map2;\n        }\n        const result = /* @__PURE__ */ new Map();\n        for (const [key, value] of map1) {\n          if (map2.has(key)) {\n            result.set(key, value);\n          }\n        }\n        return result;\n      }\n      const data = this.ambiguousCharacterData.value;\n      let filteredLocales = locales.filter((l) =\u003e !l.startsWith(\"_\") \u0026\u0026 l in data);\n      if (filteredLocales.length === 0) {\n        filteredLocales = [\"_default\"];\n      }\n      let languageSpecificMap = void 0;\n      for (const locale of filteredLocales) {\n        const map2 = arrayToMap(data[locale]);\n        languageSpecificMap = intersectMaps(languageSpecificMap, map2);\n      }\n      const commonMap = arrayToMap(data[\"_common\"]);\n      const map = mergeMaps(commonMap, languageSpecificMap);\n      return new _AmbiguousCharacters(map);\n    });\n  }\n  static getInstance(locales) {\n    return _AmbiguousCharacters.cache.get(Array.from(locales));\n  }\n  static {\n    this._locales = new Lazy(() =\u003e Object.keys(_AmbiguousCharacters.ambiguousCharacterData.value).filter((k) =\u003e !k.startsWith(\"_\")));\n  }\n  static getLocales() {\n    return _AmbiguousCharacters._locales.value;\n  }\n  constructor(confusableDictionary) {\n    this.confusableDictionary = confusableDictionary;\n  }\n  isAmbiguous(codePoint) {\n    return this.confusableDictionary.has(codePoint);\n  }\n  /**\n   * Returns the non basic ASCII code point that the given code point can be confused,\n   * or undefined if such code point does note exist.\n   */\n  getPrimaryConfusable(codePoint) {\n    return this.confusableDictionary.get(codePoint);\n  }\n  getConfusableCodePoints() {\n    return new Set(this.confusableDictionary.keys());\n  }\n};\nvar InvisibleCharacters = class _InvisibleCharacters {\n  static getRawData() {\n    return JSON.parse(\"[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]\");\n  }\n  static {\n    this._data = void 0;\n  }\n  static getData() {\n    if (!this._data) {\n      this._data = new Set(_InvisibleCharacters.getRawData());\n    }\n    return this._data;\n  }\n  static isInvisibleCharacter(codePoint) {\n    return _InvisibleCharacters.getData().has(codePoint);\n  }\n  static get codePoints() {\n    return _InvisibleCharacters.getData();\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/process.js\nvar safeProcess;\nvar vscodeGlobal = globalThis.vscode;\nif (typeof vscodeGlobal !== \"undefined\" \u0026\u0026 typeof vscodeGlobal.process !== \"undefined\") {\n  const sandboxProcess = vscodeGlobal.process;\n  safeProcess = {\n    get platform() {\n      return sandboxProcess.platform;\n    },\n    get arch() {\n      return sandboxProcess.arch;\n    },\n    get env() {\n      return sandboxProcess.env;\n    },\n    cwd() {\n      return sandboxProcess.cwd();\n    }\n  };\n} else if (typeof __Process$ !== \"undefined\" \u0026\u0026 typeof __Process$?.versions?.node === \"string\") {\n  safeProcess = {\n    get platform() {\n      return __Process$.platform;\n    },\n    get arch() {\n      return __Process$.arch;\n    },\n    get env() {\n      return __Process$.env;\n    },\n    cwd() {\n      return __Process$.env[\"VSCODE_CWD\"] || __Process$.cwd();\n    }\n  };\n} else {\n  safeProcess = {\n    // Supported\n    get platform() {\n      return isWindows ? \"win32\" : isMacintosh ? \"darwin\" : \"linux\";\n    },\n    get arch() {\n      return void 0;\n    },\n    // Unsupported\n    get env() {\n      return {};\n    },\n    cwd() {\n      return \"/\";\n    }\n  };\n}\nvar cwd = safeProcess.cwd;\nvar env = safeProcess.env;\nvar platform = safeProcess.platform;\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/path.js\nvar CHAR_UPPERCASE_A = 65;\nvar CHAR_LOWERCASE_A = 97;\nvar CHAR_UPPERCASE_Z = 90;\nvar CHAR_LOWERCASE_Z = 122;\nvar CHAR_DOT = 46;\nvar CHAR_FORWARD_SLASH = 47;\nvar CHAR_BACKWARD_SLASH = 92;\nvar CHAR_COLON = 58;\nvar CHAR_QUESTION_MARK = 63;\nvar ErrorInvalidArgType = class extends Error {\n  constructor(name, expected, actual) {\n    let determiner;\n    if (typeof expected === \"string\" \u0026\u0026 expected.indexOf(\"not \") === 0) {\n      determiner = \"must not be\";\n      expected = expected.replace(/^not /, \"\");\n    } else {\n      determiner = \"must be\";\n    }\n    const type = name.indexOf(\".\") !== -1 ? \"property\" : \"argument\";\n    let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n    msg += `. Received type ${typeof actual}`;\n    super(msg);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n};\nfunction validateObject(pathObject, name) {\n  if (pathObject === null || typeof pathObject !== \"object\") {\n    throw new ErrorInvalidArgType(name, \"Object\", pathObject);\n  }\n}\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") {\n    throw new ErrorInvalidArgType(name, \"string\", value);\n  }\n}\nvar platformIsWin32 = platform === \"win32\";\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n  return code \u003e= CHAR_UPPERCASE_A \u0026\u0026 code \u003c= CHAR_UPPERCASE_Z || code \u003e= CHAR_LOWERCASE_A \u0026\u0026 code \u003c= CHAR_LOWERCASE_Z;\n}\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i \u003c= path.length; ++i) {\n    if (i \u003c path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator2(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n    if (isPathSeparator2(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (dots === 2) {\n        if (res.length \u003c 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length \u003e 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length \u003e 0 ? `${separator}..` : \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length \u003e 0) {\n          res += `${separator}${path.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT \u0026\u0026 dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nfunction formatExt(ext) {\n  return ext ? `${ext[0] === \".\" ? \"\" : \".\"}${ext}` : \"\";\n}\nfunction _format2(sep2, pathObject) {\n  validateObject(pathObject, \"pathObject\");\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || `${pathObject.name || \"\"}${formatExt(pathObject.ext)}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;\n}\nvar win32 = {\n  // path.resolve([from ...], to)\n  resolve(...pathSegments) {\n    let resolvedDevice = \"\";\n    let resolvedTail = \"\";\n    let resolvedAbsolute = false;\n    for (let i = pathSegments.length - 1; i \u003e= -1; i--) {\n      let path;\n      if (i \u003e= 0) {\n        path = pathSegments[i];\n        validateString(path, `paths[${i}]`);\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = cwd();\n      } else {\n        path = env[`=${resolvedDevice}`] || cwd();\n        if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() \u0026\u0026 path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n      const len = path.length;\n      let rootEnd = 0;\n      let device = \"\";\n      let isAbsolute = false;\n      const code = path.charCodeAt(0);\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        isAbsolute = true;\n        if (isPathSeparator(path.charCodeAt(1))) {\n          let j = 2;\n          let last = j;\n          while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j \u003c len \u0026\u0026 j !== last) {\n            const firstPart = path.slice(last, j);\n            last = j;\n            while (j \u003c len \u0026\u0026 isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j \u003c len \u0026\u0026 j !== last) {\n              last = j;\n              while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON) {\n        device = path.slice(0, 2);\n        rootEnd = 2;\n        if (len \u003e 2 \u0026\u0026 isPathSeparator(path.charCodeAt(2))) {\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n      if (device.length \u003e 0) {\n        if (resolvedDevice.length \u003e 0) {\n          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n            continue;\n          }\n        } else {\n          resolvedDevice = device;\n        }\n      }\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length \u003e 0) {\n          break;\n        }\n      } else {\n        resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute \u0026\u0026 resolvedDevice.length \u003e 0) {\n          break;\n        }\n      }\n    }\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, \"\\\\\", isPathSeparator);\n    return resolvedAbsolute ? `${resolvedDevice}\\\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || \".\";\n  },\n  normalize(path) {\n    validateString(path, \"path\");\n    const len = path.length;\n    if (len === 0) {\n      return \".\";\n    }\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = path.charCodeAt(0);\n    if (len === 1) {\n      return isPosixPathSeparator(code) ? \"\\\\\" : path;\n    }\n    if (isPathSeparator(code)) {\n      isAbsolute = true;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        let j = 2;\n        let last = j;\n        while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j \u003c len \u0026\u0026 j !== last) {\n          const firstPart = path.slice(last, j);\n          last = j;\n          while (j \u003c len \u0026\u0026 isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j \u003c len \u0026\u0026 j !== last) {\n            last = j;\n            while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n            }\n            if (j !== last) {\n              device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON) {\n      device = path.slice(0, 2);\n      rootEnd = 2;\n      if (len \u003e 2 \u0026\u0026 isPathSeparator(path.charCodeAt(2))) {\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n    let tail = rootEnd \u003c len ? normalizeString(path.slice(rootEnd), !isAbsolute, \"\\\\\", isPathSeparator) : \"\";\n    if (tail.length === 0 \u0026\u0026 !isAbsolute) {\n      tail = \".\";\n    }\n    if (tail.length \u003e 0 \u0026\u0026 isPathSeparator(path.charCodeAt(len - 1))) {\n      tail += \"\\\\\";\n    }\n    if (device === void 0) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  },\n  isAbsolute(path) {\n    validateString(path, \"path\");\n    const len = path.length;\n    if (len === 0) {\n      return false;\n    }\n    const code = path.charCodeAt(0);\n    return isPathSeparator(code) || // Possible device root\n    len \u003e 2 \u0026\u0026 isWindowsDeviceRoot(code) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON \u0026\u0026 isPathSeparator(path.charCodeAt(2));\n  },\n  join(...paths) {\n    if (paths.length === 0) {\n      return \".\";\n    }\n    let joined;\n    let firstPart;\n    for (let i = 0; i \u003c paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, \"path\");\n      if (arg.length \u003e 0) {\n        if (joined === void 0) {\n          joined = firstPart = arg;\n        } else {\n          joined += `\\\\${arg}`;\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    let needsReplace = true;\n    let slashCount = 0;\n    if (typeof firstPart === \"string\" \u0026\u0026 isPathSeparator(firstPart.charCodeAt(0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen \u003e 1 \u0026\u0026 isPathSeparator(firstPart.charCodeAt(1))) {\n        ++slashCount;\n        if (firstLen \u003e 2) {\n          if (isPathSeparator(firstPart.charCodeAt(2))) {\n            ++slashCount;\n          } else {\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      while (slashCount \u003c joined.length \u0026\u0026 isPathSeparator(joined.charCodeAt(slashCount))) {\n        slashCount++;\n      }\n      if (slashCount \u003e= 2) {\n        joined = `\\\\${joined.slice(slashCount)}`;\n      }\n    }\n    return win32.normalize(joined);\n  },\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative(from, to) {\n    validateString(from, \"from\");\n    validateString(to, \"to\");\n    if (from === to) {\n      return \"\";\n    }\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n    if (fromOrig === toOrig) {\n      return \"\";\n    }\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n    if (from === to) {\n      return \"\";\n    }\n    let fromStart = 0;\n    while (fromStart \u003c from.length \u0026\u0026 from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    let fromEnd = from.length;\n    while (fromEnd - 1 \u003e fromStart \u0026\u0026 from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n    let toStart = 0;\n    while (toStart \u003c to.length \u0026\u0026 to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    let toEnd = to.length;\n    while (toEnd - 1 \u003e toStart \u0026\u0026 to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n    const length = fromLen \u003c toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i \u003c length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_BACKWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i !== length) {\n      if (lastCommonSep === -1) {\n        return toOrig;\n      }\n    } else {\n      if (toLen \u003e length) {\n        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n          return toOrig.slice(toStart + i + 1);\n        }\n        if (i === 2) {\n          return toOrig.slice(toStart + i);\n        }\n      }\n      if (fromLen \u003e length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n          lastCommonSep = i;\n        } else if (i === 2) {\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1) {\n        lastCommonSep = 0;\n      }\n    }\n    let out = \"\";\n    for (i = fromStart + lastCommonSep + 1; i \u003c= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? \"..\" : \"\\\\..\";\n      }\n    }\n    toStart += lastCommonSep;\n    if (out.length \u003e 0) {\n      return `${out}${toOrig.slice(toStart, toEnd)}`;\n    }\n    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      ++toStart;\n    }\n    return toOrig.slice(toStart, toEnd);\n  },\n  toNamespacedPath(path) {\n    if (typeof path !== \"string\" || path.length === 0) {\n      return path;\n    }\n    const resolvedPath = win32.resolve(path);\n    if (resolvedPath.length \u003c= 2) {\n      return path;\n    }\n    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n        const code = resolvedPath.charCodeAt(2);\n        if (code !== CHAR_QUESTION_MARK \u0026\u0026 code !== CHAR_DOT) {\n          return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n        }\n      }\n    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) \u0026\u0026 resolvedPath.charCodeAt(1) === CHAR_COLON \u0026\u0026 resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n    return path;\n  },\n  dirname(path) {\n    validateString(path, \"path\");\n    const len = path.length;\n    if (len === 0) {\n      return \".\";\n    }\n    let rootEnd = -1;\n    let offset = 0;\n    const code = path.charCodeAt(0);\n    if (len === 1) {\n      return isPathSeparator(code) ? path : \".\";\n    }\n    if (isPathSeparator(code)) {\n      rootEnd = offset = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        let j = 2;\n        let last = j;\n        while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j \u003c len \u0026\u0026 j !== last) {\n          last = j;\n          while (j \u003c len \u0026\u0026 isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j \u003c len \u0026\u0026 j !== last) {\n            last = j;\n            while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              return path;\n            }\n            if (j !== last) {\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON) {\n      rootEnd = len \u003e 2 \u0026\u0026 isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i \u003e= offset; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      if (rootEnd === -1) {\n        return \".\";\n      }\n      end = rootEnd;\n    }\n    return path.slice(0, end);\n  },\n  basename(path, suffix) {\n    if (suffix !== void 0) {\n      validateString(suffix, \"suffix\");\n    }\n    validateString(path, \"path\");\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (path.length \u003e= 2 \u0026\u0026 isWindowsDeviceRoot(path.charCodeAt(0)) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON) {\n      start = 2;\n    }\n    if (suffix !== void 0 \u0026\u0026 suffix.length \u003e 0 \u0026\u0026 suffix.length \u003c= path.length) {\n      if (suffix === path) {\n        return \"\";\n      }\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i \u003e= start; --i) {\n        const code = path.charCodeAt(i);\n        if (isPathSeparator(code)) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx \u003e= 0) {\n            if (code === suffix.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i \u003e= start; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1) {\n      return \"\";\n    }\n    return path.slice(start, end);\n  },\n  extname(path) {\n    validateString(path, \"path\");\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    if (path.length \u003e= 2 \u0026\u0026 path.charCodeAt(1) === CHAR_COLON \u0026\u0026 isWindowsDeviceRoot(path.charCodeAt(0))) {\n      start = startPart = 2;\n    }\n    for (let i = path.length - 1; i \u003e= start; --i) {\n      const code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 \u0026\u0026 startDot === end - 1 \u0026\u0026 startDot === startPart + 1) {\n      return \"\";\n    }\n    return path.slice(startDot, end);\n  },\n  format: _format2.bind(null, \"\\\\\"),\n  parse(path) {\n    validateString(path, \"path\");\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path.length === 0) {\n      return ret;\n    }\n    const len = path.length;\n    let rootEnd = 0;\n    let code = path.charCodeAt(0);\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    if (isPathSeparator(code)) {\n      rootEnd = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        let j = 2;\n        let last = j;\n        while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j \u003c len \u0026\u0026 j !== last) {\n          last = j;\n          while (j \u003c len \u0026\u0026 isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j \u003c len \u0026\u0026 j !== last) {\n            last = j;\n            while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              rootEnd = j;\n            } else if (j !== last) {\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON) {\n      if (len \u003c= 2) {\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(path.charCodeAt(2))) {\n        if (len === 3) {\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd \u003e 0) {\n      ret.root = path.slice(0, rootEnd);\n    }\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    let preDotState = 0;\n    for (; i \u003e= rootEnd; --i) {\n      code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (end !== -1) {\n      if (startDot === -1 || // We saw a non-dot character immediately before the dot\n      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 \u0026\u0026 startDot === end - 1 \u0026\u0026 startDot === startPart + 1) {\n        ret.base = ret.name = path.slice(startPart, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n    if (startPart \u003e 0 \u0026\u0026 startPart !== rootEnd) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else {\n      ret.dir = ret.root;\n    }\n    return ret;\n  },\n  sep: \"\\\\\",\n  delimiter: \";\",\n  win32: null,\n  posix: null\n};\nvar posixCwd = (() =\u003e {\n  if (platformIsWin32) {\n    const regexp = /\\\\/g;\n    return () =\u003e {\n      const cwd2 = cwd().replace(regexp, \"/\");\n      return cwd2.slice(cwd2.indexOf(\"/\"));\n    };\n  }\n  return () =\u003e cwd();\n})();\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve(...pathSegments) {\n    let resolvedPath = \"\";\n    let resolvedAbsolute = false;\n    for (let i = pathSegments.length - 1; i \u003e= -1 \u0026\u0026 !resolvedAbsolute; i--) {\n      const path = i \u003e= 0 ? pathSegments[i] : posixCwd();\n      validateString(path, `paths[${i}]`);\n      if (path.length === 0) {\n        continue;\n      }\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, \"/\", isPosixPathSeparator);\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length \u003e 0 ? resolvedPath : \".\";\n  },\n  normalize(path) {\n    validateString(path, \"path\");\n    if (path.length === 0) {\n      return \".\";\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n    path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n    if (path.length === 0) {\n      if (isAbsolute) {\n        return \"/\";\n      }\n      return trailingSeparator ? \"./\" : \".\";\n    }\n    if (trailingSeparator) {\n      path += \"/\";\n    }\n    return isAbsolute ? `/${path}` : path;\n  },\n  isAbsolute(path) {\n    validateString(path, \"path\");\n    return path.length \u003e 0 \u0026\u0026 path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n  join(...paths) {\n    if (paths.length === 0) {\n      return \".\";\n    }\n    let joined;\n    for (let i = 0; i \u003c paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, \"path\");\n      if (arg.length \u003e 0) {\n        if (joined === void 0) {\n          joined = arg;\n        } else {\n          joined += `/${arg}`;\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    return posix.normalize(joined);\n  },\n  relative(from, to) {\n    validateString(from, \"from\");\n    validateString(to, \"to\");\n    if (from === to) {\n      return \"\";\n    }\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n    if (from === to) {\n      return \"\";\n    }\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n    const length = fromLen \u003c toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i \u003c length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i === length) {\n      if (toLen \u003e length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          return to.slice(toStart + i + 1);\n        }\n        if (i === 0) {\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen \u003e length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          lastCommonSep = i;\n        } else if (i === 0) {\n          lastCommonSep = 0;\n        }\n      }\n    }\n    let out = \"\";\n    for (i = fromStart + lastCommonSep + 1; i \u003c= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? \"..\" : \"/..\";\n      }\n    }\n    return `${out}${to.slice(toStart + lastCommonSep)}`;\n  },\n  toNamespacedPath(path) {\n    return path;\n  },\n  dirname(path) {\n    validateString(path, \"path\");\n    if (path.length === 0) {\n      return \".\";\n    }\n    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i \u003e= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      return hasRoot ? \"/\" : \".\";\n    }\n    if (hasRoot \u0026\u0026 end === 1) {\n      return \"//\";\n    }\n    return path.slice(0, end);\n  },\n  basename(path, suffix) {\n    if (suffix !== void 0) {\n      validateString(suffix, \"ext\");\n    }\n    validateString(path, \"path\");\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (suffix !== void 0 \u0026\u0026 suffix.length \u003e 0 \u0026\u0026 suffix.length \u003c= path.length) {\n      if (suffix === path) {\n        return \"\";\n      }\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i \u003e= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx \u003e= 0) {\n            if (code === suffix.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i \u003e= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1) {\n      return \"\";\n    }\n    return path.slice(start, end);\n  },\n  extname(path) {\n    validateString(path, \"path\");\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path.length - 1; i \u003e= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 \u0026\u0026 startDot === end - 1 \u0026\u0026 startDot === startPart + 1) {\n      return \"\";\n    }\n    return path.slice(startDot, end);\n  },\n  format: _format2.bind(null, \"/\"),\n  parse(path) {\n    validateString(path, \"path\");\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path.length === 0) {\n      return ret;\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = \"/\";\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    let preDotState = 0;\n    for (; i \u003e= start; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (end !== -1) {\n      const start2 = startPart === 0 \u0026\u0026 isAbsolute ? 1 : startPart;\n      if (startDot === -1 || // We saw a non-dot character immediately before the dot\n      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 \u0026\u0026 startDot === end - 1 \u0026\u0026 startDot === startPart + 1) {\n        ret.base = ret.name = path.slice(start2, end);\n      } else {\n        ret.name = path.slice(start2, startDot);\n        ret.base = path.slice(start2, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n    if (startPart \u003e 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = \"/\";\n    }\n    return ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  win32: null,\n  posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nvar normalize = platformIsWin32 ? win32.normalize : posix.normalize;\nvar join = platformIsWin32 ? win32.join : posix.join;\nvar resolve = platformIsWin32 ? win32.resolve : posix.resolve;\nvar relative = platformIsWin32 ? win32.relative : posix.relative;\nvar dirname = platformIsWin32 ? win32.dirname : posix.dirname;\nvar basename = platformIsWin32 ? win32.basename : posix.basename;\nvar extname = platformIsWin32 ? win32.extname : posix.extname;\nvar sep = platformIsWin32 ? win32.sep : posix.sep;\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/uri.js\nvar _schemePattern = /^\\w[\\w\\d+.-]*$/;\nvar _singleSlashStart = /^\\//;\nvar _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n  if (!ret.scheme \u0026\u0026 _strict) {\n    throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n  }\n  if (ret.scheme \u0026\u0026 !_schemePattern.test(ret.scheme)) {\n    throw new Error(\"[UriError]: Scheme contains illegal characters.\");\n  }\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n      }\n    }\n  }\n}\nfunction _schemeFix(scheme, _strict) {\n  if (!scheme \u0026\u0026 !_strict) {\n    return \"file\";\n  }\n  return scheme;\n}\nfunction _referenceResolution(scheme, path) {\n  switch (scheme) {\n    case \"https\":\n    case \"http\":\n    case \"file\":\n      if (!path) {\n        path = _slash;\n      } else if (path[0] !== _slash) {\n        path = _slash + path;\n      }\n      break;\n  }\n  return path;\n}\nvar _empty = \"\";\nvar _slash = \"/\";\nvar _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\nvar URI = class _URI {\n  static isUri(thing) {\n    if (thing instanceof _URI) {\n      return true;\n    }\n    if (!thing) {\n      return false;\n    }\n    return typeof thing.authority === \"string\" \u0026\u0026 typeof thing.fragment === \"string\" \u0026\u0026 typeof thing.path === \"string\" \u0026\u0026 typeof thing.query === \"string\" \u0026\u0026 typeof thing.scheme === \"string\" \u0026\u0026 typeof thing.fsPath === \"string\" \u0026\u0026 typeof thing.with === \"function\" \u0026\u0026 typeof thing.toString === \"function\";\n  }\n  /**\n   * @internal\n   */\n  constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n    if (typeof schemeOrData === \"object\") {\n      this.scheme = schemeOrData.scheme || _empty;\n      this.authority = schemeOrData.authority || _empty;\n      this.path = schemeOrData.path || _empty;\n      this.query = schemeOrData.query || _empty;\n      this.fragment = schemeOrData.fragment || _empty;\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict);\n      this.authority = authority || _empty;\n      this.path = _referenceResolution(this.scheme, path || _empty);\n      this.query = query || _empty;\n      this.fragment = fragment || _empty;\n      _validateUri(this, _strict);\n    }\n  }\n  // ---- filesystem path -----------------------\n  /**\n   * Returns a string representing the corresponding file system path of this URI.\n   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n   * platform specific path separator.\n   *\n   * * Will *not* validate the path for invalid characters and semantics.\n   * * Will *not* look at the scheme of this URI.\n   * * The result shall *not* be used for display purposes but for accessing a file on disk.\n   *\n   *\n   * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n   *\n   * ```ts\n      const u = URI.parse('file://server/c$/folder/file.txt')\n      u.authority === 'server'\n      u.path === '/shares/c$/file.txt'\n      u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n  ```\n   *\n   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n   * with URIs that represent files on disk (`file` scheme).\n   */\n  get fsPath() {\n    return uriToFsPath(this, false);\n  }\n  // ---- modify to new -------------------------\n  with(change) {\n    if (!change) {\n      return this;\n    }\n    let { scheme, authority, path, query, fragment } = change;\n    if (scheme === void 0) {\n      scheme = this.scheme;\n    } else if (scheme === null) {\n      scheme = _empty;\n    }\n    if (authority === void 0) {\n      authority = this.authority;\n    } else if (authority === null) {\n      authority = _empty;\n    }\n    if (path === void 0) {\n      path = this.path;\n    } else if (path === null) {\n      path = _empty;\n    }\n    if (query === void 0) {\n      query = this.query;\n    } else if (query === null) {\n      query = _empty;\n    }\n    if (fragment === void 0) {\n      fragment = this.fragment;\n    } else if (fragment === null) {\n      fragment = _empty;\n    }\n    if (scheme === this.scheme \u0026\u0026 authority === this.authority \u0026\u0026 path === this.path \u0026\u0026 query === this.query \u0026\u0026 fragment === this.fragment) {\n      return this;\n    }\n    return new Uri(scheme, authority, path, query, fragment);\n  }\n  // ---- parse \u0026 validate ------------------------\n  /**\n   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n   * `file:///usr/home`, or `scheme:with/path`.\n   *\n   * @param value A string which represents an URI (see `URI#toString`).\n   */\n  static parse(value, _strict = false) {\n    const match = _regexp.exec(value);\n    if (!match) {\n      return new Uri(_empty, _empty, _empty, _empty, _empty);\n    }\n    return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n  }\n  /**\n   * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n   * `/usr/home`, or `\\\\server\\share\\some\\path`.\n   *\n   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n   * `URI.parse('file://' + path)` because the path might contain characters that are\n   * interpreted (# and ?). See the following sample:\n   * ```ts\n  const good = URI.file('/coding/c#/project1');\n  good.scheme === 'file';\n  good.path === '/coding/c#/project1';\n  good.fragment === '';\n  const bad = URI.parse('file://' + '/coding/c#/project1');\n  bad.scheme === 'file';\n  bad.path === '/coding/c'; // path is now broken\n  bad.fragment === '/project1';\n  ```\n   *\n   * @param path A file system path (see `URI#fsPath`)\n   */\n  static file(path) {\n    let authority = _empty;\n    if (isWindows) {\n      path = path.replace(/\\\\/g, _slash);\n    }\n    if (path[0] === _slash \u0026\u0026 path[1] === _slash) {\n      const idx = path.indexOf(_slash, 2);\n      if (idx === -1) {\n        authority = path.substring(2);\n        path = _slash;\n      } else {\n        authority = path.substring(2, idx);\n        path = path.substring(idx) || _slash;\n      }\n    }\n    return new Uri(\"file\", authority, path, _empty, _empty);\n  }\n  /**\n   * Creates new URI from uri components.\n   *\n   * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\n   * validation and should be used for untrusted uri components retrieved from storage,\n   * user input, command arguments etc\n   */\n  static from(components, strict) {\n    const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);\n    return result;\n  }\n  /**\n   * Join a URI path with path fragments and normalizes the resulting path.\n   *\n   * @param uri The input URI.\n   * @param pathFragment The path fragment to add to the URI path.\n   * @returns The resulting URI.\n   */\n  static joinPath(uri, ...pathFragment) {\n    if (!uri.path) {\n      throw new Error(`[UriError]: cannot call joinPath on URI without path`);\n    }\n    let newPath;\n    if (isWindows \u0026\u0026 uri.scheme === \"file\") {\n      newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n    } else {\n      newPath = posix.join(uri.path, ...pathFragment);\n    }\n    return uri.with({ path: newPath });\n  }\n  // ---- printing/externalize ---------------------------\n  /**\n   * Creates a string representation for this URI. It's guaranteed that calling\n   * `URI.parse` with the result of this function creates an URI which is equal\n   * to this URI.\n   *\n   * * The result shall *not* be used for display purposes but for externalization or transport.\n   * * The result will be encoded using the percentage encoding and encoding happens mostly\n   * ignore the scheme-specific encoding rules.\n   *\n   * @param skipEncoding Do not encode the result, default is `false`\n   */\n  toString(skipEncoding = false) {\n    return _asFormatted(this, skipEncoding);\n  }\n  toJSON() {\n    return this;\n  }\n  static revive(data) {\n    if (!data) {\n      return data;\n    } else if (data instanceof _URI) {\n      return data;\n    } else {\n      const result = new Uri(data);\n      result._formatted = data.external ?? null;\n      result._fsPath = data._sep === _pathSepMarker ? data.fsPath ?? null : null;\n      return result;\n    }\n  }\n};\nvar _pathSepMarker = isWindows ? 1 : void 0;\nvar Uri = class extends URI {\n  constructor() {\n    super(...arguments);\n    this._formatted = null;\n    this._fsPath = null;\n  }\n  get fsPath() {\n    if (!this._fsPath) {\n      this._fsPath = uriToFsPath(this, false);\n    }\n    return this._fsPath;\n  }\n  toString(skipEncoding = false) {\n    if (!skipEncoding) {\n      if (!this._formatted) {\n        this._formatted = _asFormatted(this, false);\n      }\n      return this._formatted;\n    } else {\n      return _asFormatted(this, true);\n    }\n  }\n  toJSON() {\n    const res = {\n      $mid: 1\n      /* MarshalledId.Uri */\n    };\n    if (this._fsPath) {\n      res.fsPath = this._fsPath;\n      res._sep = _pathSepMarker;\n    }\n    if (this._formatted) {\n      res.external = this._formatted;\n    }\n    if (this.path) {\n      res.path = this.path;\n    }\n    if (this.scheme) {\n      res.scheme = this.scheme;\n    }\n    if (this.authority) {\n      res.authority = this.authority;\n    }\n    if (this.query) {\n      res.query = this.query;\n    }\n    if (this.fragment) {\n      res.fragment = this.fragment;\n    }\n    return res;\n  }\n};\nvar encodeTable = {\n  [\n    58\n    /* CharCode.Colon */\n  ]: \"%3A\",\n  // gen-delims\n  [\n    47\n    /* CharCode.Slash */\n  ]: \"%2F\",\n  [\n    63\n    /* CharCode.QuestionMark */\n  ]: \"%3F\",\n  [\n    35\n    /* CharCode.Hash */\n  ]: \"%23\",\n  [\n    91\n    /* CharCode.OpenSquareBracket */\n  ]: \"%5B\",\n  [\n    93\n    /* CharCode.CloseSquareBracket */\n  ]: \"%5D\",\n  [\n    64\n    /* CharCode.AtSign */\n  ]: \"%40\",\n  [\n    33\n    /* CharCode.ExclamationMark */\n  ]: \"%21\",\n  // sub-delims\n  [\n    36\n    /* CharCode.DollarSign */\n  ]: \"%24\",\n  [\n    38\n    /* CharCode.Ampersand */\n  ]: \"%26\",\n  [\n    39\n    /* CharCode.SingleQuote */\n  ]: \"%27\",\n  [\n    40\n    /* CharCode.OpenParen */\n  ]: \"%28\",\n  [\n    41\n    /* CharCode.CloseParen */\n  ]: \"%29\",\n  [\n    42\n    /* CharCode.Asterisk */\n  ]: \"%2A\",\n  [\n    43\n    /* CharCode.Plus */\n  ]: \"%2B\",\n  [\n    44\n    /* CharCode.Comma */\n  ]: \"%2C\",\n  [\n    59\n    /* CharCode.Semicolon */\n  ]: \"%3B\",\n  [\n    61\n    /* CharCode.Equals */\n  ]: \"%3D\",\n  [\n    32\n    /* CharCode.Space */\n  ]: \"%20\"\n};\nfunction encodeURIComponentFast(uriComponent, isPath, isAuthority) {\n  let res = void 0;\n  let nativeEncodePos = -1;\n  for (let pos = 0; pos \u003c uriComponent.length; pos++) {\n    const code = uriComponent.charCodeAt(pos);\n    if (code \u003e= 97 \u0026\u0026 code \u003c= 122 || code \u003e= 65 \u0026\u0026 code \u003c= 90 || code \u003e= 48 \u0026\u0026 code \u003c= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath \u0026\u0026 code === 47 || isAuthority \u0026\u0026 code === 91 || isAuthority \u0026\u0026 code === 93 || isAuthority \u0026\u0026 code === 58) {\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n        nativeEncodePos = -1;\n      }\n      if (res !== void 0) {\n        res += uriComponent.charAt(pos);\n      }\n    } else {\n      if (res === void 0) {\n        res = uriComponent.substr(0, pos);\n      }\n      const escaped = encodeTable[code];\n      if (escaped !== void 0) {\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n          nativeEncodePos = -1;\n        }\n        res += escaped;\n      } else if (nativeEncodePos === -1) {\n        nativeEncodePos = pos;\n      }\n    }\n  }\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n  }\n  return res !== void 0 ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n  let res = void 0;\n  for (let pos = 0; pos \u003c path.length; pos++) {\n    const code = path.charCodeAt(pos);\n    if (code === 35 || code === 63) {\n      if (res === void 0) {\n        res = path.substr(0, pos);\n      }\n      res += encodeTable[code];\n    } else {\n      if (res !== void 0) {\n        res += path[pos];\n      }\n    }\n  }\n  return res !== void 0 ? res : path;\n}\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\n  let value;\n  if (uri.authority \u0026\u0026 uri.path.length \u003e 1 \u0026\u0026 uri.scheme === \"file\") {\n    value = `//${uri.authority}${uri.path}`;\n  } else if (uri.path.charCodeAt(0) === 47 \u0026\u0026 (uri.path.charCodeAt(1) \u003e= 65 \u0026\u0026 uri.path.charCodeAt(1) \u003c= 90 || uri.path.charCodeAt(1) \u003e= 97 \u0026\u0026 uri.path.charCodeAt(1) \u003c= 122) \u0026\u0026 uri.path.charCodeAt(2) === 58) {\n    if (!keepDriveLetterCasing) {\n      value = uri.path[1].toLowerCase() + uri.path.substr(2);\n    } else {\n      value = uri.path.substr(1);\n    }\n  } else {\n    value = uri.path;\n  }\n  if (isWindows) {\n    value = value.replace(/\\//g, \"\\\\\");\n  }\n  return value;\n}\nfunction _asFormatted(uri, skipEncoding) {\n  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n  let res = \"\";\n  let { scheme, authority, path, query, fragment } = uri;\n  if (scheme) {\n    res += scheme;\n    res += \":\";\n  }\n  if (authority || scheme === \"file\") {\n    res += _slash;\n    res += _slash;\n  }\n  if (authority) {\n    let idx = authority.indexOf(\"@\");\n    if (idx !== -1) {\n      const userinfo = authority.substr(0, idx);\n      authority = authority.substr(idx + 1);\n      idx = userinfo.lastIndexOf(\":\");\n      if (idx === -1) {\n        res += encoder(userinfo, false, false);\n      } else {\n        res += encoder(userinfo.substr(0, idx), false, false);\n        res += \":\";\n        res += encoder(userinfo.substr(idx + 1), false, true);\n      }\n      res += \"@\";\n    }\n    authority = authority.toLowerCase();\n    idx = authority.lastIndexOf(\":\");\n    if (idx === -1) {\n      res += encoder(authority, false, true);\n    } else {\n      res += encoder(authority.substr(0, idx), false, true);\n      res += authority.substr(idx);\n    }\n  }\n  if (path) {\n    if (path.length \u003e= 3 \u0026\u0026 path.charCodeAt(0) === 47 \u0026\u0026 path.charCodeAt(2) === 58) {\n      const code = path.charCodeAt(1);\n      if (code \u003e= 65 \u0026\u0026 code \u003c= 90) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;\n      }\n    } else if (path.length \u003e= 2 \u0026\u0026 path.charCodeAt(1) === 58) {\n      const code = path.charCodeAt(0);\n      if (code \u003e= 65 \u0026\u0026 code \u003c= 90) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;\n      }\n    }\n    res += encoder(path, true, false);\n  }\n  if (query) {\n    res += \"?\";\n    res += encoder(query, false, false);\n  }\n  if (fragment) {\n    res += \"#\";\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n  }\n  return res;\n}\nfunction decodeURIComponentGraceful(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    if (str.length \u003e 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n    } else {\n      return str;\n    }\n  }\n}\nvar _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n  if (!str.match(_rEncodedAsHex)) {\n    return str;\n  }\n  return str.replace(_rEncodedAsHex, (match) =\u003e decodeURIComponentGraceful(match));\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/network.js\nvar Schemas;\n(function(Schemas2) {\n  Schemas2.inMemory = \"inmemory\";\n  Schemas2.vscode = \"vscode\";\n  Schemas2.internal = \"private\";\n  Schemas2.walkThrough = \"walkThrough\";\n  Schemas2.walkThroughSnippet = \"walkThroughSnippet\";\n  Schemas2.http = \"http\";\n  Schemas2.https = \"https\";\n  Schemas2.file = \"file\";\n  Schemas2.mailto = \"mailto\";\n  Schemas2.untitled = \"untitled\";\n  Schemas2.data = \"data\";\n  Schemas2.command = \"command\";\n  Schemas2.vscodeRemote = \"vscode-remote\";\n  Schemas2.vscodeRemoteResource = \"vscode-remote-resource\";\n  Schemas2.vscodeManagedRemoteResource = \"vscode-managed-remote-resource\";\n  Schemas2.vscodeUserData = \"vscode-userdata\";\n  Schemas2.vscodeCustomEditor = \"vscode-custom-editor\";\n  Schemas2.vscodeNotebookCell = \"vscode-notebook-cell\";\n  Schemas2.vscodeNotebookCellMetadata = \"vscode-notebook-cell-metadata\";\n  Schemas2.vscodeNotebookCellMetadataDiff = \"vscode-notebook-cell-metadata-diff\";\n  Schemas2.vscodeNotebookCellOutput = \"vscode-notebook-cell-output\";\n  Schemas2.vscodeNotebookCellOutputDiff = \"vscode-notebook-cell-output-diff\";\n  Schemas2.vscodeNotebookMetadata = \"vscode-notebook-metadata\";\n  Schemas2.vscodeInteractiveInput = \"vscode-interactive-input\";\n  Schemas2.vscodeSettings = \"vscode-settings\";\n  Schemas2.vscodeWorkspaceTrust = \"vscode-workspace-trust\";\n  Schemas2.vscodeTerminal = \"vscode-terminal\";\n  Schemas2.vscodeChatCodeBlock = \"vscode-chat-code-block\";\n  Schemas2.vscodeChatCodeCompareBlock = \"vscode-chat-code-compare-block\";\n  Schemas2.vscodeChatSesssion = \"vscode-chat-editor\";\n  Schemas2.webviewPanel = \"webview-panel\";\n  Schemas2.vscodeWebview = \"vscode-webview\";\n  Schemas2.extension = \"extension\";\n  Schemas2.vscodeFileResource = \"vscode-file\";\n  Schemas2.tmp = \"tmp\";\n  Schemas2.vsls = \"vsls\";\n  Schemas2.vscodeSourceControl = \"vscode-scm\";\n  Schemas2.commentsInput = \"comment\";\n  Schemas2.codeSetting = \"code-setting\";\n  Schemas2.outputChannel = \"output\";\n})(Schemas || (Schemas = {}));\nvar connectionTokenQueryName = \"tkn\";\nvar RemoteAuthoritiesImpl = class {\n  constructor() {\n    this._hosts = /* @__PURE__ */ Object.create(null);\n    this._ports = /* @__PURE__ */ Object.create(null);\n    this._connectionTokens = /* @__PURE__ */ Object.create(null);\n    this._preferredWebSchema = \"http\";\n    this._delegate = null;\n    this._serverRootPath = \"/\";\n  }\n  setPreferredWebSchema(schema) {\n    this._preferredWebSchema = schema;\n  }\n  get _remoteResourcesPath() {\n    return posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);\n  }\n  rewrite(uri) {\n    if (this._delegate) {\n      try {\n        return this._delegate(uri);\n      } catch (err) {\n        onUnexpectedError(err);\n        return uri;\n      }\n    }\n    const authority = uri.authority;\n    let host = this._hosts[authority];\n    if (host \u0026\u0026 host.indexOf(\":\") !== -1 \u0026\u0026 host.indexOf(\"[\") === -1) {\n      host = `[${host}]`;\n    }\n    const port = this._ports[authority];\n    const connectionToken = this._connectionTokens[authority];\n    let query = `path=${encodeURIComponent(uri.path)}`;\n    if (typeof connectionToken === \"string\") {\n      query += `\u0026${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n    }\n    return URI.from({\n      scheme: isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n      authority: `${host}:${port}`,\n      path: this._remoteResourcesPath,\n      query\n    });\n  }\n};\nvar RemoteAuthorities = new RemoteAuthoritiesImpl();\nvar VSCODE_AUTHORITY = \"vscode-app\";\nvar FileAccessImpl = class _FileAccessImpl {\n  static {\n    this.FALLBACK_AUTHORITY = VSCODE_AUTHORITY;\n  }\n  /**\n   * Returns a URI to use in contexts where the browser is responsible\n   * for loading (e.g. fetch()) or when used within the DOM.\n   *\n   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n   */\n  asBrowserUri(resourcePath) {\n    const uri = this.toUri(resourcePath);\n    return this.uriToBrowserUri(uri);\n  }\n  /**\n   * Returns a URI to use in contexts where the browser is responsible\n   * for loading (e.g. fetch()) or when used within the DOM.\n   *\n   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n   */\n  uriToBrowserUri(uri) {\n    if (uri.scheme === Schemas.vscodeRemote) {\n      return RemoteAuthorities.rewrite(uri);\n    }\n    if (\n      // ...only ever for `file` resources\n      uri.scheme === Schemas.file \u0026\u0026 // ...and we run in native environments\n      (isNative || // ...or web worker extensions on desktop\n      webWorkerOrigin === `${Schemas.vscodeFileResource}://${_FileAccessImpl.FALLBACK_AUTHORITY}`)\n    ) {\n      return uri.with({\n        scheme: Schemas.vscodeFileResource,\n        // We need to provide an authority here so that it can serve\n        // as origin for network and loading matters in chromium.\n        // If the URI is not coming with an authority already, we\n        // add our own\n        authority: uri.authority || _FileAccessImpl.FALLBACK_AUTHORITY,\n        query: null,\n        fragment: null\n      });\n    }\n    return uri;\n  }\n  toUri(uriOrModule, moduleIdToUrl) {\n    if (URI.isUri(uriOrModule)) {\n      return uriOrModule;\n    }\n    if (globalThis._VSCODE_FILE_ROOT) {\n      const rootUriOrPath = globalThis._VSCODE_FILE_ROOT;\n      if (/^\\w[\\w\\d+.-]*:\\/\\//.test(rootUriOrPath)) {\n        return URI.joinPath(URI.parse(rootUriOrPath, true), uriOrModule);\n      }\n      const modulePath = join(rootUriOrPath, uriOrModule);\n      return URI.file(modulePath);\n    }\n    return URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n  }\n};\nvar FileAccess = new FileAccessImpl();\nvar COI;\n(function(COI2) {\n  const coiHeaders = /* @__PURE__ */ new Map([\n    [\"1\", { \"Cross-Origin-Opener-Policy\": \"same-origin\" }],\n    [\"2\", { \"Cross-Origin-Embedder-Policy\": \"require-corp\" }],\n    [\"3\", { \"Cross-Origin-Opener-Policy\": \"same-origin\", \"Cross-Origin-Embedder-Policy\": \"require-corp\" }]\n  ]);\n  COI2.CoopAndCoep = Object.freeze(coiHeaders.get(\"3\"));\n  const coiSearchParamName = \"vscode-coi\";\n  function getHeadersFromQuery(url) {\n    let params;\n    if (typeof url === \"string\") {\n      params = new URL(url).searchParams;\n    } else if (url instanceof URL) {\n      params = url.searchParams;\n    } else if (URI.isUri(url)) {\n      params = new URL(url.toString(true)).searchParams;\n    }\n    const value = params?.get(coiSearchParamName);\n    if (!value) {\n      return void 0;\n    }\n    return coiHeaders.get(value);\n  }\n  COI2.getHeadersFromQuery = getHeadersFromQuery;\n  function addSearchParam(urlOrSearch, coop, coep) {\n    if (!globalThis.crossOriginIsolated) {\n      return;\n    }\n    const value = coop \u0026\u0026 coep ? \"3\" : coep ? \"2\" : \"1\";\n    if (urlOrSearch instanceof URLSearchParams) {\n      urlOrSearch.set(coiSearchParamName, value);\n    } else {\n      urlOrSearch[coiSearchParamName] = value;\n    }\n  }\n  COI2.addSearchParam = addSearchParam;\n})(COI || (COI = {}));\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js\nvar isESM = true;\nvar DEFAULT_CHANNEL = \"default\";\nvar INITIALIZE = \"$initialize\";\nvar RequestMessage = class {\n  constructor(vsWorker, req, channel, method, args) {\n    this.vsWorker = vsWorker;\n    this.req = req;\n    this.channel = channel;\n    this.method = method;\n    this.args = args;\n    this.type = 0;\n  }\n};\nvar ReplyMessage = class {\n  constructor(vsWorker, seq, res, err) {\n    this.vsWorker = vsWorker;\n    this.seq = seq;\n    this.res = res;\n    this.err = err;\n    this.type = 1;\n  }\n};\nvar SubscribeEventMessage = class {\n  constructor(vsWorker, req, channel, eventName, arg) {\n    this.vsWorker = vsWorker;\n    this.req = req;\n    this.channel = channel;\n    this.eventName = eventName;\n    this.arg = arg;\n    this.type = 2;\n  }\n};\nvar EventMessage = class {\n  constructor(vsWorker, req, event) {\n    this.vsWorker = vsWorker;\n    this.req = req;\n    this.event = event;\n    this.type = 3;\n  }\n};\nvar UnsubscribeEventMessage = class {\n  constructor(vsWorker, req) {\n    this.vsWorker = vsWorker;\n    this.req = req;\n    this.type = 4;\n  }\n};\nvar SimpleWorkerProtocol = class {\n  constructor(handler) {\n    this._workerId = -1;\n    this._handler = handler;\n    this._lastSentReq = 0;\n    this._pendingReplies = /* @__PURE__ */ Object.create(null);\n    this._pendingEmitters = /* @__PURE__ */ new Map();\n    this._pendingEvents = /* @__PURE__ */ new Map();\n  }\n  setWorkerId(workerId) {\n    this._workerId = workerId;\n  }\n  sendMessage(channel, method, args) {\n    const req = String(++this._lastSentReq);\n    return new Promise((resolve2, reject) =\u003e {\n      this._pendingReplies[req] = {\n        resolve: resolve2,\n        reject\n      };\n      this._send(new RequestMessage(this._workerId, req, channel, method, args));\n    });\n  }\n  listen(channel, eventName, arg) {\n    let req = null;\n    const emitter = new Emitter({\n      onWillAddFirstListener: () =\u003e {\n        req = String(++this._lastSentReq);\n        this._pendingEmitters.set(req, emitter);\n        this._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));\n      },\n      onDidRemoveLastListener: () =\u003e {\n        this._pendingEmitters.delete(req);\n        this._send(new UnsubscribeEventMessage(this._workerId, req));\n        req = null;\n      }\n    });\n    return emitter.event;\n  }\n  handleMessage(message) {\n    if (!message || !message.vsWorker) {\n      return;\n    }\n    if (this._workerId !== -1 \u0026\u0026 message.vsWorker !== this._workerId) {\n      return;\n    }\n    this._handleMessage(message);\n  }\n  createProxyToRemoteChannel(channel, sendMessageBarrier) {\n    const handler = {\n      get: (target, name) =\u003e {\n        if (typeof name === \"string\" \u0026\u0026 !target[name]) {\n          if (propertyIsDynamicEvent(name)) {\n            target[name] = (arg) =\u003e {\n              return this.listen(channel, name, arg);\n            };\n          } else if (propertyIsEvent(name)) {\n            target[name] = this.listen(channel, name, void 0);\n          } else if (name.charCodeAt(0) === 36) {\n            target[name] = async (...myArgs) =\u003e {\n              await sendMessageBarrier?.();\n              return this.sendMessage(channel, name, myArgs);\n            };\n          }\n        }\n        return target[name];\n      }\n    };\n    return new Proxy(/* @__PURE__ */ Object.create(null), handler);\n  }\n  _handleMessage(msg) {\n    switch (msg.type) {\n      case 1:\n        return this._handleReplyMessage(msg);\n      case 0:\n        return this._handleRequestMessage(msg);\n      case 2:\n        return this._handleSubscribeEventMessage(msg);\n      case 3:\n        return this._handleEventMessage(msg);\n      case 4:\n        return this._handleUnsubscribeEventMessage(msg);\n    }\n  }\n  _handleReplyMessage(replyMessage) {\n    if (!this._pendingReplies[replyMessage.seq]) {\n      console.warn(\"Got reply to unknown seq\");\n      return;\n    }\n    const reply = this._pendingReplies[replyMessage.seq];\n    delete this._pendingReplies[replyMessage.seq];\n    if (replyMessage.err) {\n      let err = replyMessage.err;\n      if (replyMessage.err.$isError) {\n        err = new Error();\n        err.name = replyMessage.err.name;\n        err.message = replyMessage.err.message;\n        err.stack = replyMessage.err.stack;\n      }\n      reply.reject(err);\n      return;\n    }\n    reply.resolve(replyMessage.res);\n  }\n  _handleRequestMessage(requestMessage) {\n    const req = requestMessage.req;\n    const result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);\n    result.then((r) =\u003e {\n      this._send(new ReplyMessage(this._workerId, req, r, void 0));\n    }, (e) =\u003e {\n      if (e.detail instanceof Error) {\n        e.detail = transformErrorForSerialization(e.detail);\n      }\n      this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));\n    });\n  }\n  _handleSubscribeEventMessage(msg) {\n    const req = msg.req;\n    const disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) =\u003e {\n      this._send(new EventMessage(this._workerId, req, event));\n    });\n    this._pendingEvents.set(req, disposable);\n  }\n  _handleEventMessage(msg) {\n    if (!this._pendingEmitters.has(msg.req)) {\n      console.warn(\"Got event for unknown req\");\n      return;\n    }\n    this._pendingEmitters.get(msg.req).fire(msg.event);\n  }\n  _handleUnsubscribeEventMessage(msg) {\n    if (!this._pendingEvents.has(msg.req)) {\n      console.warn(\"Got unsubscribe for unknown req\");\n      return;\n    }\n    this._pendingEvents.get(msg.req).dispose();\n    this._pendingEvents.delete(msg.req);\n  }\n  _send(msg) {\n    const transfer = [];\n    if (msg.type === 0) {\n      for (let i = 0; i \u003c msg.args.length; i++) {\n        if (msg.args[i] instanceof ArrayBuffer) {\n          transfer.push(msg.args[i]);\n        }\n      }\n    } else if (msg.type === 1) {\n      if (msg.res instanceof ArrayBuffer) {\n        transfer.push(msg.res);\n      }\n    }\n    this._handler.sendMessage(msg, transfer);\n  }\n};\nfunction propertyIsEvent(name) {\n  return name[0] === \"o\" \u0026\u0026 name[1] === \"n\" \u0026\u0026 isUpperAsciiLetter(name.charCodeAt(2));\n}\nfunction propertyIsDynamicEvent(name) {\n  return /^onDynamic/.test(name) \u0026\u0026 isUpperAsciiLetter(name.charCodeAt(9));\n}\nvar SimpleWorkerServer = class {\n  constructor(postMessage, requestHandlerFactory) {\n    this._localChannels = /* @__PURE__ */ new Map();\n    this._remoteChannels = /* @__PURE__ */ new Map();\n    this._requestHandlerFactory = requestHandlerFactory;\n    this._requestHandler = null;\n    this._protocol = new SimpleWorkerProtocol({\n      sendMessage: (msg, transfer) =\u003e {\n        postMessage(msg, transfer);\n      },\n      handleMessage: (channel, method, args) =\u003e this._handleMessage(channel, method, args),\n      handleEvent: (channel, eventName, arg) =\u003e this._handleEvent(channel, eventName, arg)\n    });\n  }\n  onmessage(msg) {\n    this._protocol.handleMessage(msg);\n  }\n  _handleMessage(channel, method, args) {\n    if (channel === DEFAULT_CHANNEL \u0026\u0026 method === INITIALIZE) {\n      return this.initialize(args[0], args[1], args[2]);\n    }\n    const requestHandler = channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel);\n    if (!requestHandler) {\n      return Promise.reject(new Error(`Missing channel ${channel} on worker thread`));\n    }\n    if (typeof requestHandler[method] !== \"function\") {\n      return Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));\n    }\n    try {\n      return Promise.resolve(requestHandler[method].apply(requestHandler, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  _handleEvent(channel, eventName, arg) {\n    const requestHandler = channel === DEFAULT_CHANNEL ? this._requestHandler : this._localChannels.get(channel);\n    if (!requestHandler) {\n      throw new Error(`Missing channel ${channel} on worker thread`);\n    }\n    if (propertyIsDynamicEvent(eventName)) {\n      const event = requestHandler[eventName].call(requestHandler, arg);\n      if (typeof event !== \"function\") {\n        throw new Error(`Missing dynamic event ${eventName} on request handler.`);\n      }\n      return event;\n    }\n    if (propertyIsEvent(eventName)) {\n      const event = requestHandler[eventName];\n      if (typeof event !== \"function\") {\n        throw new Error(`Missing event ${eventName} on request handler.`);\n      }\n      return event;\n    }\n    throw new Error(`Malformed event name ${eventName}`);\n  }\n  getChannel(channel) {\n    if (!this._remoteChannels.has(channel)) {\n      const inst = this._protocol.createProxyToRemoteChannel(channel);\n      this._remoteChannels.set(channel, inst);\n    }\n    return this._remoteChannels.get(channel);\n  }\n  async initialize(workerId, loaderConfig, moduleId) {\n    this._protocol.setWorkerId(workerId);\n    if (this._requestHandlerFactory) {\n      this._requestHandler = this._requestHandlerFactory(this);\n      return;\n    }\n    if (loaderConfig) {\n      if (typeof loaderConfig.baseUrl !== \"undefined\") {\n        delete loaderConfig[\"baseUrl\"];\n      }\n      if (typeof loaderConfig.paths !== \"undefined\") {\n        if (typeof loaderConfig.paths.vs !== \"undefined\") {\n          delete loaderConfig.paths[\"vs\"];\n        }\n      }\n      if (typeof loaderConfig.trustedTypesPolicy !== \"undefined\") {\n        delete loaderConfig[\"trustedTypesPolicy\"];\n      }\n      loaderConfig.catchError = true;\n      globalThis.require.config(loaderConfig);\n    }\n    if (isESM) {\n      const url = FileAccess.asBrowserUri(`${moduleId}.js`).toString(true);\n      return import(`${url}`).then((module) =\u003e {\n        this._requestHandler = module.create(this);\n        if (!this._requestHandler) {\n          throw new Error(`No RequestHandler!`);\n        }\n      });\n    }\n    return new Promise((resolve2, reject) =\u003e {\n      const req = globalThis.require;\n      req([moduleId], (module) =\u003e {\n        this._requestHandler = module.create(this);\n        if (!this._requestHandler) {\n          reject(new Error(`No RequestHandler!`));\n          return;\n        }\n        resolve2();\n      }, reject);\n    });\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js\nvar DiffChange = class {\n  /**\n   * Constructs a new DiffChange with the given sequence information\n   * and content.\n   */\n  constructor(originalStart, originalLength, modifiedStart, modifiedLength) {\n    this.originalStart = originalStart;\n    this.originalLength = originalLength;\n    this.modifiedStart = modifiedStart;\n    this.modifiedLength = modifiedLength;\n  }\n  /**\n   * The end point (exclusive) of the change in the original sequence.\n   */\n  getOriginalEnd() {\n    return this.originalStart + this.originalLength;\n  }\n  /**\n   * The end point (exclusive) of the change in the modified sequence.\n   */\n  getModifiedEnd() {\n    return this.modifiedStart + this.modifiedLength;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/hash.js\nfunction numberHash(val, initialHashVal) {\n  return (initialHashVal \u003c\u003c 5) - initialHashVal + val | 0;\n}\nfunction stringHash(s, hashVal) {\n  hashVal = numberHash(149417, hashVal);\n  for (let i = 0, length = s.length; i \u003c length; i++) {\n    hashVal = numberHash(s.charCodeAt(i), hashVal);\n  }\n  return hashVal;\n}\nfunction leftRotate(value, bits, totalBits = 32) {\n  const delta = totalBits - bits;\n  const mask = ~((1 \u003c\u003c delta) - 1);\n  return (value \u003c\u003c bits | (mask \u0026 value) \u003e\u003e\u003e delta) \u003e\u003e\u003e 0;\n}\nfunction fill(dest, index = 0, count = dest.byteLength, value = 0) {\n  for (let i = 0; i \u003c count; i++) {\n    dest[index + i] = value;\n  }\n}\nfunction leftPad(value, length, char = \"0\") {\n  while (value.length \u003c length) {\n    value = char + value;\n  }\n  return value;\n}\nfunction toHexString(bufferOrValue, bitsize = 32) {\n  if (bufferOrValue instanceof ArrayBuffer) {\n    return Array.from(new Uint8Array(bufferOrValue)).map((b) =\u003e b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n  return leftPad((bufferOrValue \u003e\u003e\u003e 0).toString(16), bitsize / 4);\n}\nvar StringSHA1 = class _StringSHA1 {\n  static {\n    this._bigBlock32 = new DataView(new ArrayBuffer(320));\n  }\n  // 80 * 4 = 320\n  constructor() {\n    this._h0 = 1732584193;\n    this._h1 = 4023233417;\n    this._h2 = 2562383102;\n    this._h3 = 271733878;\n    this._h4 = 3285377520;\n    this._buff = new Uint8Array(\n      64 + 3\n      /* to fit any utf-8 */\n    );\n    this._buffDV = new DataView(this._buff.buffer);\n    this._buffLen = 0;\n    this._totalLen = 0;\n    this._leftoverHighSurrogate = 0;\n    this._finished = false;\n  }\n  update(str) {\n    const strLen = str.length;\n    if (strLen === 0) {\n      return;\n    }\n    const buff = this._buff;\n    let buffLen = this._buffLen;\n    let leftoverHighSurrogate = this._leftoverHighSurrogate;\n    let charCode;\n    let offset;\n    if (leftoverHighSurrogate !== 0) {\n      charCode = leftoverHighSurrogate;\n      offset = -1;\n      leftoverHighSurrogate = 0;\n    } else {\n      charCode = str.charCodeAt(0);\n      offset = 0;\n    }\n    while (true) {\n      let codePoint = charCode;\n      if (isHighSurrogate(charCode)) {\n        if (offset + 1 \u003c strLen) {\n          const nextCharCode = str.charCodeAt(offset + 1);\n          if (isLowSurrogate(nextCharCode)) {\n            offset++;\n            codePoint = computeCodePoint(charCode, nextCharCode);\n          } else {\n            codePoint = 65533;\n          }\n        } else {\n          leftoverHighSurrogate = charCode;\n          break;\n        }\n      } else if (isLowSurrogate(charCode)) {\n        codePoint = 65533;\n      }\n      buffLen = this._push(buff, buffLen, codePoint);\n      offset++;\n      if (offset \u003c strLen) {\n        charCode = str.charCodeAt(offset);\n      } else {\n        break;\n      }\n    }\n    this._buffLen = buffLen;\n    this._leftoverHighSurrogate = leftoverHighSurrogate;\n  }\n  _push(buff, buffLen, codePoint) {\n    if (codePoint \u003c 128) {\n      buff[buffLen++] = codePoint;\n    } else if (codePoint \u003c 2048) {\n      buff[buffLen++] = 192 | (codePoint \u0026 1984) \u003e\u003e\u003e 6;\n      buff[buffLen++] = 128 | (codePoint \u0026 63) \u003e\u003e\u003e 0;\n    } else if (codePoint \u003c 65536) {\n      buff[buffLen++] = 224 | (codePoint \u0026 61440) \u003e\u003e\u003e 12;\n      buff[buffLen++] = 128 | (codePoint \u0026 4032) \u003e\u003e\u003e 6;\n      buff[buffLen++] = 128 | (codePoint \u0026 63) \u003e\u003e\u003e 0;\n    } else {\n      buff[buffLen++] = 240 | (codePoint \u0026 1835008) \u003e\u003e\u003e 18;\n      buff[buffLen++] = 128 | (codePoint \u0026 258048) \u003e\u003e\u003e 12;\n      buff[buffLen++] = 128 | (codePoint \u0026 4032) \u003e\u003e\u003e 6;\n      buff[buffLen++] = 128 | (codePoint \u0026 63) \u003e\u003e\u003e 0;\n    }\n    if (buffLen \u003e= 64) {\n      this._step();\n      buffLen -= 64;\n      this._totalLen += 64;\n      buff[0] = buff[64 + 0];\n      buff[1] = buff[64 + 1];\n      buff[2] = buff[64 + 2];\n    }\n    return buffLen;\n  }\n  digest() {\n    if (!this._finished) {\n      this._finished = true;\n      if (this._leftoverHighSurrogate) {\n        this._leftoverHighSurrogate = 0;\n        this._buffLen = this._push(\n          this._buff,\n          this._buffLen,\n          65533\n          /* SHA1Constant.UNICODE_REPLACEMENT */\n        );\n      }\n      this._totalLen += this._buffLen;\n      this._wrapUp();\n    }\n    return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n  }\n  _wrapUp() {\n    this._buff[this._buffLen++] = 128;\n    fill(this._buff, this._buffLen);\n    if (this._buffLen \u003e 56) {\n      this._step();\n      fill(this._buff);\n    }\n    const ml = 8 * this._totalLen;\n    this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n    this._buffDV.setUint32(60, ml % 4294967296, false);\n    this._step();\n  }\n  _step() {\n    const bigBlock32 = _StringSHA1._bigBlock32;\n    const data = this._buffDV;\n    for (let j = 0; j \u003c 64; j += 4) {\n      bigBlock32.setUint32(j, data.getUint32(j, false), false);\n    }\n    for (let j = 64; j \u003c 320; j += 4) {\n      bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);\n    }\n    let a = this._h0;\n    let b = this._h1;\n    let c = this._h2;\n    let d = this._h3;\n    let e = this._h4;\n    let f, k;\n    let temp;\n    for (let j = 0; j \u003c 80; j++) {\n      if (j \u003c 20) {\n        f = b \u0026 c | ~b \u0026 d;\n        k = 1518500249;\n      } else if (j \u003c 40) {\n        f = b ^ c ^ d;\n        k = 1859775393;\n      } else if (j \u003c 60) {\n        f = b \u0026 c | b \u0026 d | c \u0026 d;\n        k = 2400959708;\n      } else {\n        f = b ^ c ^ d;\n        k = 3395469782;\n      }\n      temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) \u0026 4294967295;\n      e = d;\n      d = c;\n      c = leftRotate(b, 30);\n      b = a;\n      a = temp;\n    }\n    this._h0 = this._h0 + a \u0026 4294967295;\n    this._h1 = this._h1 + b \u0026 4294967295;\n    this._h2 = this._h2 + c \u0026 4294967295;\n    this._h3 = this._h3 + d \u0026 4294967295;\n    this._h4 = this._h4 + e \u0026 4294967295;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js\nvar StringDiffSequence = class {\n  constructor(source) {\n    this.source = source;\n  }\n  getElements() {\n    const source = this.source;\n    const characters = new Int32Array(source.length);\n    for (let i = 0, len = source.length; i \u003c len; i++) {\n      characters[i] = source.charCodeAt(i);\n    }\n    return characters;\n  }\n};\nfunction stringDiff(original, modified, pretty) {\n  return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\nvar Debug = class {\n  static Assert(condition, message) {\n    if (!condition) {\n      throw new Error(message);\n    }\n  }\n};\nvar MyArray = class {\n  /**\n   * Copies a range of elements from an Array starting at the specified source index and pastes\n   * them to another Array starting at the specified destination index. The length and the indexes\n   * are specified as 64-bit integers.\n   * sourceArray:\n   *\t\tThe Array that contains the data to copy.\n   * sourceIndex:\n   *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n   * destinationArray:\n   *\t\tThe Array that receives the data.\n   * destinationIndex:\n   *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n   * length:\n   *\t\tA 64-bit integer that represents the number of elements to copy.\n   */\n  static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n    for (let i = 0; i \u003c length; i++) {\n      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n    }\n  }\n  static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n    for (let i = 0; i \u003c length; i++) {\n      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n    }\n  }\n};\nvar DiffChangeHelper = class {\n  /**\n   * Constructs a new DiffChangeHelper for the given DiffSequences.\n   */\n  constructor() {\n    this.m_changes = [];\n    this.m_originalStart = 1073741824;\n    this.m_modifiedStart = 1073741824;\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n  }\n  /**\n   * Marks the beginning of the next change in the set of differences.\n   */\n  MarkNextChange() {\n    if (this.m_originalCount \u003e 0 || this.m_modifiedCount \u003e 0) {\n      this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n    }\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n    this.m_originalStart = 1073741824;\n    this.m_modifiedStart = 1073741824;\n  }\n  /**\n   * Adds the original element at the given position to the elements\n   * affected by the current change. The modified index gives context\n   * to the change position with respect to the original sequence.\n   * @param originalIndex The index of the original element to add.\n   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n   */\n  AddOriginalElement(originalIndex, modifiedIndex) {\n    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n    this.m_originalCount++;\n  }\n  /**\n   * Adds the modified element at the given position to the elements\n   * affected by the current change. The original index gives context\n   * to the change position with respect to the modified sequence.\n   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n   * @param modifiedIndex The index of the modified element to add.\n   */\n  AddModifiedElement(originalIndex, modifiedIndex) {\n    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n    this.m_modifiedCount++;\n  }\n  /**\n   * Retrieves all of the changes marked by the class.\n   */\n  getChanges() {\n    if (this.m_originalCount \u003e 0 || this.m_modifiedCount \u003e 0) {\n      this.MarkNextChange();\n    }\n    return this.m_changes;\n  }\n  /**\n   * Retrieves all of the changes marked by the class in the reverse order\n   */\n  getReverseChanges() {\n    if (this.m_originalCount \u003e 0 || this.m_modifiedCount \u003e 0) {\n      this.MarkNextChange();\n    }\n    this.m_changes.reverse();\n    return this.m_changes;\n  }\n};\nvar LcsDiff = class _LcsDiff {\n  /**\n   * Constructs the DiffFinder\n   */\n  constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n    this.ContinueProcessingPredicate = continueProcessingPredicate;\n    this._originalSequence = originalSequence;\n    this._modifiedSequence = modifiedSequence;\n    const [originalStringElements, originalElementsOrHash, originalHasStrings] = _LcsDiff._getElements(originalSequence);\n    const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = _LcsDiff._getElements(modifiedSequence);\n    this._hasStrings = originalHasStrings \u0026\u0026 modifiedHasStrings;\n    this._originalStringElements = originalStringElements;\n    this._originalElementsOrHash = originalElementsOrHash;\n    this._modifiedStringElements = modifiedStringElements;\n    this._modifiedElementsOrHash = modifiedElementsOrHash;\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = [];\n  }\n  static _isStringArray(arr) {\n    return arr.length \u003e 0 \u0026\u0026 typeof arr[0] === \"string\";\n  }\n  static _getElements(sequence) {\n    const elements = sequence.getElements();\n    if (_LcsDiff._isStringArray(elements)) {\n      const hashes = new Int32Array(elements.length);\n      for (let i = 0, len = elements.length; i \u003c len; i++) {\n        hashes[i] = stringHash(elements[i], 0);\n      }\n      return [elements, hashes, true];\n    }\n    if (elements instanceof Int32Array) {\n      return [[], elements, false];\n    }\n    return [[], new Int32Array(elements), false];\n  }\n  ElementsAreEqual(originalIndex, newIndex) {\n    if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n      return false;\n    }\n    return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;\n  }\n  ElementsAreStrictEqual(originalIndex, newIndex) {\n    if (!this.ElementsAreEqual(originalIndex, newIndex)) {\n      return false;\n    }\n    const originalElement = _LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n    const modifiedElement = _LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n    return originalElement === modifiedElement;\n  }\n  static _getStrictElement(sequence, index) {\n    if (typeof sequence.getStrictElement === \"function\") {\n      return sequence.getStrictElement(index);\n    }\n    return null;\n  }\n  OriginalElementsAreEqual(index1, index2) {\n    if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n      return false;\n    }\n    return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;\n  }\n  ModifiedElementsAreEqual(index1, index2) {\n    if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n      return false;\n    }\n    return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;\n  }\n  ComputeDiff(pretty) {\n    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n  }\n  /**\n   * Computes the differences between the original and modified input\n   * sequences on the bounded range.\n   * @returns An array of the differences between the two input sequences.\n   */\n  _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n    const quitEarlyArr = [false];\n    let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n    if (pretty) {\n      changes = this.PrettifyChanges(changes);\n    }\n    return {\n      quitEarly: quitEarlyArr[0],\n      changes\n    };\n  }\n  /**\n   * Private helper method which computes the differences on the bounded range\n   * recursively.\n   * @returns An array of the differences between the two input sequences.\n   */\n  ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n    quitEarlyArr[0] = false;\n    while (originalStart \u003c= originalEnd \u0026\u0026 modifiedStart \u003c= modifiedEnd \u0026\u0026 this.ElementsAreEqual(originalStart, modifiedStart)) {\n      originalStart++;\n      modifiedStart++;\n    }\n    while (originalEnd \u003e= originalStart \u0026\u0026 modifiedEnd \u003e= modifiedStart \u0026\u0026 this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n      originalEnd--;\n      modifiedEnd--;\n    }\n    if (originalStart \u003e originalEnd || modifiedStart \u003e modifiedEnd) {\n      let changes;\n      if (modifiedStart \u003c= modifiedEnd) {\n        Debug.Assert(originalStart === originalEnd + 1, \"originalStart should only be one more than originalEnd\");\n        changes = [\n          new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n      } else if (originalStart \u003c= originalEnd) {\n        Debug.Assert(modifiedStart === modifiedEnd + 1, \"modifiedStart should only be one more than modifiedEnd\");\n        changes = [\n          new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n        ];\n      } else {\n        Debug.Assert(originalStart === originalEnd + 1, \"originalStart should only be one more than originalEnd\");\n        Debug.Assert(modifiedStart === modifiedEnd + 1, \"modifiedStart should only be one more than modifiedEnd\");\n        changes = [];\n      }\n      return changes;\n    }\n    const midOriginalArr = [0];\n    const midModifiedArr = [0];\n    const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n    const midOriginal = midOriginalArr[0];\n    const midModified = midModifiedArr[0];\n    if (result !== null) {\n      return result;\n    } else if (!quitEarlyArr[0]) {\n      const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n      let rightChanges = [];\n      if (!quitEarlyArr[0]) {\n        rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n      } else {\n        rightChanges = [\n          new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n        ];\n      }\n      return this.ConcatenateChanges(leftChanges, rightChanges);\n    }\n    return [\n      new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n    ];\n  }\n  WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n    let forwardChanges = null;\n    let reverseChanges = null;\n    let changeHelper = new DiffChangeHelper();\n    let diagonalMin = diagonalForwardStart;\n    let diagonalMax = diagonalForwardEnd;\n    let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;\n    let lastOriginalIndex = -1073741824;\n    let historyIndex = this.m_forwardHistory.length - 1;\n    do {\n      const diagonal = diagonalRelative + diagonalForwardBase;\n      if (diagonal === diagonalMin || diagonal \u003c diagonalMax \u0026\u0026 forwardPoints[diagonal - 1] \u003c forwardPoints[diagonal + 1]) {\n        originalIndex = forwardPoints[diagonal + 1];\n        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n        if (originalIndex \u003c lastOriginalIndex) {\n          changeHelper.MarkNextChange();\n        }\n        lastOriginalIndex = originalIndex;\n        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n        diagonalRelative = diagonal + 1 - diagonalForwardBase;\n      } else {\n        originalIndex = forwardPoints[diagonal - 1] + 1;\n        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n        if (originalIndex \u003c lastOriginalIndex) {\n          changeHelper.MarkNextChange();\n        }\n        lastOriginalIndex = originalIndex - 1;\n        changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n        diagonalRelative = diagonal - 1 - diagonalForwardBase;\n      }\n      if (historyIndex \u003e= 0) {\n        forwardPoints = this.m_forwardHistory[historyIndex];\n        diagonalForwardBase = forwardPoints[0];\n        diagonalMin = 1;\n        diagonalMax = forwardPoints.length - 1;\n      }\n    } while (--historyIndex \u003e= -1);\n    forwardChanges = changeHelper.getReverseChanges();\n    if (quitEarlyArr[0]) {\n      let originalStartPoint = midOriginalArr[0] + 1;\n      let modifiedStartPoint = midModifiedArr[0] + 1;\n      if (forwardChanges !== null \u0026\u0026 forwardChanges.length \u003e 0) {\n        const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n        originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n        modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n      }\n      reverseChanges = [\n        new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n      ];\n    } else {\n      changeHelper = new DiffChangeHelper();\n      diagonalMin = diagonalReverseStart;\n      diagonalMax = diagonalReverseEnd;\n      diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;\n      lastOriginalIndex = 1073741824;\n      historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n      do {\n        const diagonal = diagonalRelative + diagonalReverseBase;\n        if (diagonal === diagonalMin || diagonal \u003c diagonalMax \u0026\u0026 reversePoints[diagonal - 1] \u003e= reversePoints[diagonal + 1]) {\n          originalIndex = reversePoints[diagonal + 1] - 1;\n          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n          if (originalIndex \u003e lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n          lastOriginalIndex = originalIndex + 1;\n          changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n          diagonalRelative = diagonal + 1 - diagonalReverseBase;\n        } else {\n          originalIndex = reversePoints[diagonal - 1];\n          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n          if (originalIndex \u003e lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n          lastOriginalIndex = originalIndex;\n          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n          diagonalRelative = diagonal - 1 - diagonalReverseBase;\n        }\n        if (historyIndex \u003e= 0) {\n          reversePoints = this.m_reverseHistory[historyIndex];\n          diagonalReverseBase = reversePoints[0];\n          diagonalMin = 1;\n          diagonalMax = reversePoints.length - 1;\n        }\n      } while (--historyIndex \u003e= -1);\n      reverseChanges = changeHelper.getChanges();\n    }\n    return this.ConcatenateChanges(forwardChanges, reverseChanges);\n  }\n  /**\n   * Given the range to compute the diff on, this method finds the point:\n   * (midOriginal, midModified)\n   * that exists in the middle of the LCS of the two sequences and\n   * is the point at which the LCS problem may be broken down recursively.\n   * This method will try to keep the LCS trace in memory. If the LCS recursion\n   * point is calculated and the full trace is available in memory, then this method\n   * will return the change list.\n   * @param originalStart The start bound of the original sequence range\n   * @param originalEnd The end bound of the original sequence range\n   * @param modifiedStart The start bound of the modified sequence range\n   * @param modifiedEnd The end bound of the modified sequence range\n   * @param midOriginal The middle point of the original sequence range\n   * @param midModified The middle point of the modified sequence range\n   * @returns The diff changes, if available, otherwise null\n   */\n  ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n    let originalIndex = 0, modifiedIndex = 0;\n    let diagonalForwardStart = 0, diagonalForwardEnd = 0;\n    let diagonalReverseStart = 0, diagonalReverseEnd = 0;\n    originalStart--;\n    modifiedStart--;\n    midOriginalArr[0] = 0;\n    midModifiedArr[0] = 0;\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = [];\n    const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);\n    const numDiagonals = maxDifferences + 1;\n    const forwardPoints = new Int32Array(numDiagonals);\n    const reversePoints = new Int32Array(numDiagonals);\n    const diagonalForwardBase = modifiedEnd - modifiedStart;\n    const diagonalReverseBase = originalEnd - originalStart;\n    const diagonalForwardOffset = originalStart - modifiedStart;\n    const diagonalReverseOffset = originalEnd - modifiedEnd;\n    const delta = diagonalReverseBase - diagonalForwardBase;\n    const deltaIsEven = delta % 2 === 0;\n    forwardPoints[diagonalForwardBase] = originalStart;\n    reversePoints[diagonalReverseBase] = originalEnd;\n    quitEarlyArr[0] = false;\n    for (let numDifferences = 1; numDifferences \u003c= maxDifferences / 2 + 1; numDifferences++) {\n      let furthestOriginalIndex = 0;\n      let furthestModifiedIndex = 0;\n      diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n      diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n      for (let diagonal = diagonalForwardStart; diagonal \u003c= diagonalForwardEnd; diagonal += 2) {\n        if (diagonal === diagonalForwardStart || diagonal \u003c diagonalForwardEnd \u0026\u0026 forwardPoints[diagonal - 1] \u003c forwardPoints[diagonal + 1]) {\n          originalIndex = forwardPoints[diagonal + 1];\n        } else {\n          originalIndex = forwardPoints[diagonal - 1] + 1;\n        }\n        modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n        const tempOriginalIndex = originalIndex;\n        while (originalIndex \u003c originalEnd \u0026\u0026 modifiedIndex \u003c modifiedEnd \u0026\u0026 this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n          originalIndex++;\n          modifiedIndex++;\n        }\n        forwardPoints[diagonal] = originalIndex;\n        if (originalIndex + modifiedIndex \u003e furthestOriginalIndex + furthestModifiedIndex) {\n          furthestOriginalIndex = originalIndex;\n          furthestModifiedIndex = modifiedIndex;\n        }\n        if (!deltaIsEven \u0026\u0026 Math.abs(diagonal - diagonalReverseBase) \u003c= numDifferences - 1) {\n          if (originalIndex \u003e= reversePoints[diagonal]) {\n            midOriginalArr[0] = originalIndex;\n            midModifiedArr[0] = modifiedIndex;\n            if (tempOriginalIndex \u003c= reversePoints[diagonal] \u0026\u0026 1447 \u003e 0 \u0026\u0026 numDifferences \u003c= 1447 + 1) {\n              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n            } else {\n              return null;\n            }\n          }\n        }\n      }\n      const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n      if (this.ContinueProcessingPredicate !== null \u0026\u0026 !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n        quitEarlyArr[0] = true;\n        midOriginalArr[0] = furthestOriginalIndex;\n        midModifiedArr[0] = furthestModifiedIndex;\n        if (matchLengthOfLongest \u003e 0 \u0026\u0026 1447 \u003e 0 \u0026\u0026 numDifferences \u003c= 1447 + 1) {\n          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n        } else {\n          originalStart++;\n          modifiedStart++;\n          return [\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n          ];\n        }\n      }\n      diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n      diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n      for (let diagonal = diagonalReverseStart; diagonal \u003c= diagonalReverseEnd; diagonal += 2) {\n        if (diagonal === diagonalReverseStart || diagonal \u003c diagonalReverseEnd \u0026\u0026 reversePoints[diagonal - 1] \u003e= reversePoints[diagonal + 1]) {\n          originalIndex = reversePoints[diagonal + 1] - 1;\n        } else {\n          originalIndex = reversePoints[diagonal - 1];\n        }\n        modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n        const tempOriginalIndex = originalIndex;\n        while (originalIndex \u003e originalStart \u0026\u0026 modifiedIndex \u003e modifiedStart \u0026\u0026 this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n          originalIndex--;\n          modifiedIndex--;\n        }\n        reversePoints[diagonal] = originalIndex;\n        if (deltaIsEven \u0026\u0026 Math.abs(diagonal - diagonalForwardBase) \u003c= numDifferences) {\n          if (originalIndex \u003c= forwardPoints[diagonal]) {\n            midOriginalArr[0] = originalIndex;\n            midModifiedArr[0] = modifiedIndex;\n            if (tempOriginalIndex \u003e= forwardPoints[diagonal] \u0026\u0026 1447 \u003e 0 \u0026\u0026 numDifferences \u003c= 1447 + 1) {\n              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n            } else {\n              return null;\n            }\n          }\n        }\n      }\n      if (numDifferences \u003c= 1447) {\n        let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n        temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n        MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n        this.m_forwardHistory.push(temp);\n        temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n        temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n        MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n        this.m_reverseHistory.push(temp);\n      }\n    }\n    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n  }\n  /**\n   * Shifts the given changes to provide a more intuitive diff.\n   * While the first element in a diff matches the first element after the diff,\n   * we shift the diff down.\n   *\n   * @param changes The list of changes to shift\n   * @returns The shifted changes\n   */\n  PrettifyChanges(changes) {\n    for (let i = 0; i \u003c changes.length; i++) {\n      const change = changes[i];\n      const originalStop = i \u003c changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n      const modifiedStop = i \u003c changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n      const checkOriginal = change.originalLength \u003e 0;\n      const checkModified = change.modifiedLength \u003e 0;\n      while (change.originalStart + change.originalLength \u003c originalStop \u0026\u0026 change.modifiedStart + change.modifiedLength \u003c modifiedStop \u0026\u0026 (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) \u0026\u0026 (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n        const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n        const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n        if (endStrictEqual \u0026\u0026 !startStrictEqual) {\n          break;\n        }\n        change.originalStart++;\n        change.modifiedStart++;\n      }\n      const mergedChangeArr = [null];\n      if (i \u003c changes.length - 1 \u0026\u0026 this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n        changes[i] = mergedChangeArr[0];\n        changes.splice(i + 1, 1);\n        i--;\n        continue;\n      }\n    }\n    for (let i = changes.length - 1; i \u003e= 0; i--) {\n      const change = changes[i];\n      let originalStop = 0;\n      let modifiedStop = 0;\n      if (i \u003e 0) {\n        const prevChange = changes[i - 1];\n        originalStop = prevChange.originalStart + prevChange.originalLength;\n        modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n      }\n      const checkOriginal = change.originalLength \u003e 0;\n      const checkModified = change.modifiedLength \u003e 0;\n      let bestDelta = 0;\n      let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n      for (let delta = 1; ; delta++) {\n        const originalStart = change.originalStart - delta;\n        const modifiedStart = change.modifiedStart - delta;\n        if (originalStart \u003c originalStop || modifiedStart \u003c modifiedStop) {\n          break;\n        }\n        if (checkOriginal \u0026\u0026 !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n          break;\n        }\n        if (checkModified \u0026\u0026 !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n          break;\n        }\n        const touchingPreviousChange = originalStart === originalStop \u0026\u0026 modifiedStart === modifiedStop;\n        const score2 = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\n        if (score2 \u003e bestScore) {\n          bestScore = score2;\n          bestDelta = delta;\n        }\n      }\n      change.originalStart -= bestDelta;\n      change.modifiedStart -= bestDelta;\n      const mergedChangeArr = [null];\n      if (i \u003e 0 \u0026\u0026 this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n        changes[i - 1] = mergedChangeArr[0];\n        changes.splice(i, 1);\n        i++;\n        continue;\n      }\n    }\n    if (this._hasStrings) {\n      for (let i = 1, len = changes.length; i \u003c len; i++) {\n        const aChange = changes[i - 1];\n        const bChange = changes[i];\n        const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n        const aOriginalStart = aChange.originalStart;\n        const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n        const abOriginalLength = bOriginalEnd - aOriginalStart;\n        const aModifiedStart = aChange.modifiedStart;\n        const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n        const abModifiedLength = bModifiedEnd - aModifiedStart;\n        if (matchedLength \u003c 5 \u0026\u0026 abOriginalLength \u003c 20 \u0026\u0026 abModifiedLength \u003c 20) {\n          const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n          if (t) {\n            const [originalMatchStart, modifiedMatchStart] = t;\n            if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n              aChange.originalLength = originalMatchStart - aChange.originalStart;\n              aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n              bChange.originalStart = originalMatchStart + matchedLength;\n              bChange.modifiedStart = modifiedMatchStart + matchedLength;\n              bChange.originalLength = bOriginalEnd - bChange.originalStart;\n              bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n            }\n          }\n        }\n      }\n    }\n    return changes;\n  }\n  _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n    if (originalLength \u003c desiredLength || modifiedLength \u003c desiredLength) {\n      return null;\n    }\n    const originalMax = originalStart + originalLength - desiredLength + 1;\n    const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n    let bestScore = 0;\n    let bestOriginalStart = 0;\n    let bestModifiedStart = 0;\n    for (let i = originalStart; i \u003c originalMax; i++) {\n      for (let j = modifiedStart; j \u003c modifiedMax; j++) {\n        const score2 = this._contiguousSequenceScore(i, j, desiredLength);\n        if (score2 \u003e 0 \u0026\u0026 score2 \u003e bestScore) {\n          bestScore = score2;\n          bestOriginalStart = i;\n          bestModifiedStart = j;\n        }\n      }\n    }\n    if (bestScore \u003e 0) {\n      return [bestOriginalStart, bestModifiedStart];\n    }\n    return null;\n  }\n  _contiguousSequenceScore(originalStart, modifiedStart, length) {\n    let score2 = 0;\n    for (let l = 0; l \u003c length; l++) {\n      if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n        return 0;\n      }\n      score2 += this._originalStringElements[originalStart + l].length;\n    }\n    return score2;\n  }\n  _OriginalIsBoundary(index) {\n    if (index \u003c= 0 || index \u003e= this._originalElementsOrHash.length - 1) {\n      return true;\n    }\n    return this._hasStrings \u0026\u0026 /^\\s*$/.test(this._originalStringElements[index]);\n  }\n  _OriginalRegionIsBoundary(originalStart, originalLength) {\n    if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n      return true;\n    }\n    if (originalLength \u003e 0) {\n      const originalEnd = originalStart + originalLength;\n      if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _ModifiedIsBoundary(index) {\n    if (index \u003c= 0 || index \u003e= this._modifiedElementsOrHash.length - 1) {\n      return true;\n    }\n    return this._hasStrings \u0026\u0026 /^\\s*$/.test(this._modifiedStringElements[index]);\n  }\n  _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n    if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n      return true;\n    }\n    if (modifiedLength \u003e 0) {\n      const modifiedEnd = modifiedStart + modifiedLength;\n      if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n    const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;\n    const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;\n    return originalScore + modifiedScore;\n  }\n  /**\n   * Concatenates the two input DiffChange lists and returns the resulting\n   * list.\n   * @param The left changes\n   * @param The right changes\n   * @returns The concatenated list\n   */\n  ConcatenateChanges(left, right) {\n    const mergedChangeArr = [];\n    if (left.length === 0 || right.length === 0) {\n      return right.length \u003e 0 ? right : left;\n    } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n      const result = new Array(left.length + right.length - 1);\n      MyArray.Copy(left, 0, result, 0, left.length - 1);\n      result[left.length - 1] = mergedChangeArr[0];\n      MyArray.Copy(right, 1, result, left.length, right.length - 1);\n      return result;\n    } else {\n      const result = new Array(left.length + right.length);\n      MyArray.Copy(left, 0, result, 0, left.length);\n      MyArray.Copy(right, 0, result, left.length, right.length);\n      return result;\n    }\n  }\n  /**\n   * Returns true if the two changes overlap and can be merged into a single\n   * change\n   * @param left The left change\n   * @param right The right change\n   * @param mergedChange The merged change if the two overlap, null otherwise\n   * @returns True if the two changes overlap\n   */\n  ChangesOverlap(left, right, mergedChangeArr) {\n    Debug.Assert(left.originalStart \u003c= right.originalStart, \"Left change is not less than or equal to right change\");\n    Debug.Assert(left.modifiedStart \u003c= right.modifiedStart, \"Left change is not less than or equal to right change\");\n    if (left.originalStart + left.originalLength \u003e= right.originalStart || left.modifiedStart + left.modifiedLength \u003e= right.modifiedStart) {\n      const originalStart = left.originalStart;\n      let originalLength = left.originalLength;\n      const modifiedStart = left.modifiedStart;\n      let modifiedLength = left.modifiedLength;\n      if (left.originalStart + left.originalLength \u003e= right.originalStart) {\n        originalLength = right.originalStart + right.originalLength - left.originalStart;\n      }\n      if (left.modifiedStart + left.modifiedLength \u003e= right.modifiedStart) {\n        modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n      }\n      mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n      return true;\n    } else {\n      mergedChangeArr[0] = null;\n      return false;\n    }\n  }\n  /**\n   * Helper method used to clip a diagonal index to the range of valid\n   * diagonals. This also decides whether or not the diagonal index,\n   * if it exceeds the boundary, should be clipped to the boundary or clipped\n   * one inside the boundary depending on the Even/Odd status of the boundary\n   * and numDifferences.\n   * @param diagonal The index of the diagonal to clip.\n   * @param numDifferences The current number of differences being iterated upon.\n   * @param diagonalBaseIndex The base reference diagonal.\n   * @param numDiagonals The total number of diagonals.\n   * @returns The clipped diagonal index.\n   */\n  ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n    if (diagonal \u003e= 0 \u0026\u0026 diagonal \u003c numDiagonals) {\n      return diagonal;\n    }\n    const diagonalsBelow = diagonalBaseIndex;\n    const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n    const diffEven = numDifferences % 2 === 0;\n    if (diagonal \u003c 0) {\n      const lowerBoundEven = diagonalsBelow % 2 === 0;\n      return diffEven === lowerBoundEven ? 0 : 1;\n    } else {\n      const upperBoundEven = diagonalsAbove % 2 === 0;\n      return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js\nvar Position = class _Position {\n  constructor(lineNumber, column) {\n    this.lineNumber = lineNumber;\n    this.column = column;\n  }\n  /**\n   * Create a new position from this position.\n   *\n   * @param newLineNumber new line number\n   * @param newColumn new column\n   */\n  with(newLineNumber = this.lineNumber, newColumn = this.column) {\n    if (newLineNumber === this.lineNumber \u0026\u0026 newColumn === this.column) {\n      return this;\n    } else {\n      return new _Position(newLineNumber, newColumn);\n    }\n  }\n  /**\n   * Derive a new position from this position.\n   *\n   * @param deltaLineNumber line number delta\n   * @param deltaColumn column delta\n   */\n  delta(deltaLineNumber = 0, deltaColumn = 0) {\n    return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n  }\n  /**\n   * Test if this position equals other position\n   */\n  equals(other) {\n    return _Position.equals(this, other);\n  }\n  /**\n   * Test if position `a` equals position `b`\n   */\n  static equals(a, b) {\n    if (!a \u0026\u0026 !b) {\n      return true;\n    }\n    return !!a \u0026\u0026 !!b \u0026\u0026 a.lineNumber === b.lineNumber \u0026\u0026 a.column === b.column;\n  }\n  /**\n   * Test if this position is before other position.\n   * If the two positions are equal, the result will be false.\n   */\n  isBefore(other) {\n    return _Position.isBefore(this, other);\n  }\n  /**\n   * Test if position `a` is before position `b`.\n   * If the two positions are equal, the result will be false.\n   */\n  static isBefore(a, b) {\n    if (a.lineNumber \u003c b.lineNumber) {\n      return true;\n    }\n    if (b.lineNumber \u003c a.lineNumber) {\n      return false;\n    }\n    return a.column \u003c b.column;\n  }\n  /**\n   * Test if this position is before other position.\n   * If the two positions are equal, the result will be true.\n   */\n  isBeforeOrEqual(other) {\n    return _Position.isBeforeOrEqual(this, other);\n  }\n  /**\n   * Test if position `a` is before position `b`.\n   * If the two positions are equal, the result will be true.\n   */\n  static isBeforeOrEqual(a, b) {\n    if (a.lineNumber \u003c b.lineNumber) {\n      return true;\n    }\n    if (b.lineNumber \u003c a.lineNumber) {\n      return false;\n    }\n    return a.column \u003c= b.column;\n  }\n  /**\n   * A function that compares positions, useful for sorting\n   */\n  static compare(a, b) {\n    const aLineNumber = a.lineNumber | 0;\n    const bLineNumber = b.lineNumber | 0;\n    if (aLineNumber === bLineNumber) {\n      const aColumn = a.column | 0;\n      const bColumn = b.column | 0;\n      return aColumn - bColumn;\n    }\n    return aLineNumber - bLineNumber;\n  }\n  /**\n   * Clone this position.\n   */\n  clone() {\n    return new _Position(this.lineNumber, this.column);\n  }\n  /**\n   * Convert to a human-readable representation.\n   */\n  toString() {\n    return \"(\" + this.lineNumber + \",\" + this.column + \")\";\n  }\n  // ---\n  /**\n   * Create a `Position` from an `IPosition`.\n   */\n  static lift(pos) {\n    return new _Position(pos.lineNumber, pos.column);\n  }\n  /**\n   * Test if `obj` is an `IPosition`.\n   */\n  static isIPosition(obj) {\n    return obj \u0026\u0026 typeof obj.lineNumber === \"number\" \u0026\u0026 typeof obj.column === \"number\";\n  }\n  toJSON() {\n    return {\n      lineNumber: this.lineNumber,\n      column: this.column\n    };\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js\nvar Range = class _Range {\n  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n    if (startLineNumber \u003e endLineNumber || startLineNumber === endLineNumber \u0026\u0026 startColumn \u003e endColumn) {\n      this.startLineNumber = endLineNumber;\n      this.startColumn = endColumn;\n      this.endLineNumber = startLineNumber;\n      this.endColumn = startColumn;\n    } else {\n      this.startLineNumber = startLineNumber;\n      this.startColumn = startColumn;\n      this.endLineNumber = endLineNumber;\n      this.endColumn = endColumn;\n    }\n  }\n  /**\n   * Test if this range is empty.\n   */\n  isEmpty() {\n    return _Range.isEmpty(this);\n  }\n  /**\n   * Test if `range` is empty.\n   */\n  static isEmpty(range) {\n    return range.startLineNumber === range.endLineNumber \u0026\u0026 range.startColumn === range.endColumn;\n  }\n  /**\n   * Test if position is in this range. If the position is at the edges, will return true.\n   */\n  containsPosition(position) {\n    return _Range.containsPosition(this, position);\n  }\n  /**\n   * Test if `position` is in `range`. If the position is at the edges, will return true.\n   */\n  static containsPosition(range, position) {\n    if (position.lineNumber \u003c range.startLineNumber || position.lineNumber \u003e range.endLineNumber) {\n      return false;\n    }\n    if (position.lineNumber === range.startLineNumber \u0026\u0026 position.column \u003c range.startColumn) {\n      return false;\n    }\n    if (position.lineNumber === range.endLineNumber \u0026\u0026 position.column \u003e range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if `position` is in `range`. If the position is at the edges, will return false.\n   * @internal\n   */\n  static strictContainsPosition(range, position) {\n    if (position.lineNumber \u003c range.startLineNumber || position.lineNumber \u003e range.endLineNumber) {\n      return false;\n    }\n    if (position.lineNumber === range.startLineNumber \u0026\u0026 position.column \u003c= range.startColumn) {\n      return false;\n    }\n    if (position.lineNumber === range.endLineNumber \u0026\u0026 position.column \u003e= range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if range is in this range. If the range is equal to this range, will return true.\n   */\n  containsRange(range) {\n    return _Range.containsRange(this, range);\n  }\n  /**\n   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n   */\n  static containsRange(range, otherRange) {\n    if (otherRange.startLineNumber \u003c range.startLineNumber || otherRange.endLineNumber \u003c range.startLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber \u003e range.endLineNumber || otherRange.endLineNumber \u003e range.endLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber === range.startLineNumber \u0026\u0026 otherRange.startColumn \u003c range.startColumn) {\n      return false;\n    }\n    if (otherRange.endLineNumber === range.endLineNumber \u0026\u0026 otherRange.endColumn \u003e range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n   */\n  strictContainsRange(range) {\n    return _Range.strictContainsRange(this, range);\n  }\n  /**\n   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n   */\n  static strictContainsRange(range, otherRange) {\n    if (otherRange.startLineNumber \u003c range.startLineNumber || otherRange.endLineNumber \u003c range.startLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber \u003e range.endLineNumber || otherRange.endLineNumber \u003e range.endLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber === range.startLineNumber \u0026\u0026 otherRange.startColumn \u003c= range.startColumn) {\n      return false;\n    }\n    if (otherRange.endLineNumber === range.endLineNumber \u0026\u0026 otherRange.endColumn \u003e= range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * A reunion of the two ranges.\n   * The smallest position will be used as the start point, and the largest one as the end point.\n   */\n  plusRange(range) {\n    return _Range.plusRange(this, range);\n  }\n  /**\n   * A reunion of the two ranges.\n   * The smallest position will be used as the start point, and the largest one as the end point.\n   */\n  static plusRange(a, b) {\n    let startLineNumber;\n    let startColumn;\n    let endLineNumber;\n    let endColumn;\n    if (b.startLineNumber \u003c a.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = b.startColumn;\n    } else if (b.startLineNumber === a.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = Math.min(b.startColumn, a.startColumn);\n    } else {\n      startLineNumber = a.startLineNumber;\n      startColumn = a.startColumn;\n    }\n    if (b.endLineNumber \u003e a.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = b.endColumn;\n    } else if (b.endLineNumber === a.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = Math.max(b.endColumn, a.endColumn);\n    } else {\n      endLineNumber = a.endLineNumber;\n      endColumn = a.endColumn;\n    }\n    return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  /**\n   * A intersection of the two ranges.\n   */\n  intersectRanges(range) {\n    return _Range.intersectRanges(this, range);\n  }\n  /**\n   * A intersection of the two ranges.\n   */\n  static intersectRanges(a, b) {\n    let resultStartLineNumber = a.startLineNumber;\n    let resultStartColumn = a.startColumn;\n    let resultEndLineNumber = a.endLineNumber;\n    let resultEndColumn = a.endColumn;\n    const otherStartLineNumber = b.startLineNumber;\n    const otherStartColumn = b.startColumn;\n    const otherEndLineNumber = b.endLineNumber;\n    const otherEndColumn = b.endColumn;\n    if (resultStartLineNumber \u003c otherStartLineNumber) {\n      resultStartLineNumber = otherStartLineNumber;\n      resultStartColumn = otherStartColumn;\n    } else if (resultStartLineNumber === otherStartLineNumber) {\n      resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n    }\n    if (resultEndLineNumber \u003e otherEndLineNumber) {\n      resultEndLineNumber = otherEndLineNumber;\n      resultEndColumn = otherEndColumn;\n    } else if (resultEndLineNumber === otherEndLineNumber) {\n      resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n    }\n    if (resultStartLineNumber \u003e resultEndLineNumber) {\n      return null;\n    }\n    if (resultStartLineNumber === resultEndLineNumber \u0026\u0026 resultStartColumn \u003e resultEndColumn) {\n      return null;\n    }\n    return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n  }\n  /**\n   * Test if this range equals other.\n   */\n  equalsRange(other) {\n    return _Range.equalsRange(this, other);\n  }\n  /**\n   * Test if range `a` equals `b`.\n   */\n  static equalsRange(a, b) {\n    if (!a \u0026\u0026 !b) {\n      return true;\n    }\n    return !!a \u0026\u0026 !!b \u0026\u0026 a.startLineNumber === b.startLineNumber \u0026\u0026 a.startColumn === b.startColumn \u0026\u0026 a.endLineNumber === b.endLineNumber \u0026\u0026 a.endColumn === b.endColumn;\n  }\n  /**\n   * Return the end position (which will be after or equal to the start position)\n   */\n  getEndPosition() {\n    return _Range.getEndPosition(this);\n  }\n  /**\n   * Return the end position (which will be after or equal to the start position)\n   */\n  static getEndPosition(range) {\n    return new Position(range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Return the start position (which will be before or equal to the end position)\n   */\n  getStartPosition() {\n    return _Range.getStartPosition(this);\n  }\n  /**\n   * Return the start position (which will be before or equal to the end position)\n   */\n  static getStartPosition(range) {\n    return new Position(range.startLineNumber, range.startColumn);\n  }\n  /**\n   * Transform to a user presentable string representation.\n   */\n  toString() {\n    return \"[\" + this.startLineNumber + \",\" + this.startColumn + \" -\u003e \" + this.endLineNumber + \",\" + this.endColumn + \"]\";\n  }\n  /**\n   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n   */\n  setEndPosition(endLineNumber, endColumn) {\n    return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n  }\n  /**\n   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n   */\n  setStartPosition(startLineNumber, startColumn) {\n    return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n  }\n  /**\n   * Create a new empty range using this range's start position.\n   */\n  collapseToStart() {\n    return _Range.collapseToStart(this);\n  }\n  /**\n   * Create a new empty range using this range's start position.\n   */\n  static collapseToStart(range) {\n    return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n  }\n  /**\n   * Create a new empty range using this range's end position.\n   */\n  collapseToEnd() {\n    return _Range.collapseToEnd(this);\n  }\n  /**\n   * Create a new empty range using this range's end position.\n   */\n  static collapseToEnd(range) {\n    return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Moves the range by the given amount of lines.\n   */\n  delta(lineCount) {\n    return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n  }\n  // ---\n  static fromPositions(start, end = start) {\n    return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n  static lift(range) {\n    if (!range) {\n      return null;\n    }\n    return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Test if `obj` is an `IRange`.\n   */\n  static isIRange(obj) {\n    return obj \u0026\u0026 typeof obj.startLineNumber === \"number\" \u0026\u0026 typeof obj.startColumn === \"number\" \u0026\u0026 typeof obj.endLineNumber === \"number\" \u0026\u0026 typeof obj.endColumn === \"number\";\n  }\n  /**\n   * Test if the two ranges are touching in any way.\n   */\n  static areIntersectingOrTouching(a, b) {\n    if (a.endLineNumber \u003c b.startLineNumber || a.endLineNumber === b.startLineNumber \u0026\u0026 a.endColumn \u003c b.startColumn) {\n      return false;\n    }\n    if (b.endLineNumber \u003c a.startLineNumber || b.endLineNumber === a.startLineNumber \u0026\u0026 b.endColumn \u003c a.startColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n   */\n  static areIntersecting(a, b) {\n    if (a.endLineNumber \u003c b.startLineNumber || a.endLineNumber === b.startLineNumber \u0026\u0026 a.endColumn \u003c= b.startColumn) {\n      return false;\n    }\n    if (b.endLineNumber \u003c a.startLineNumber || b.endLineNumber === a.startLineNumber \u0026\u0026 b.endColumn \u003c= a.startColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * A function that compares ranges, useful for sorting ranges\n   * It will first compare ranges on the startPosition and then on the endPosition\n   */\n  static compareRangesUsingStarts(a, b) {\n    if (a \u0026\u0026 b) {\n      const aStartLineNumber = a.startLineNumber | 0;\n      const bStartLineNumber = b.startLineNumber | 0;\n      if (aStartLineNumber === bStartLineNumber) {\n        const aStartColumn = a.startColumn | 0;\n        const bStartColumn = b.startColumn | 0;\n        if (aStartColumn === bStartColumn) {\n          const aEndLineNumber = a.endLineNumber | 0;\n          const bEndLineNumber = b.endLineNumber | 0;\n          if (aEndLineNumber === bEndLineNumber) {\n            const aEndColumn = a.endColumn | 0;\n            const bEndColumn = b.endColumn | 0;\n            return aEndColumn - bEndColumn;\n          }\n          return aEndLineNumber - bEndLineNumber;\n        }\n        return aStartColumn - bStartColumn;\n      }\n      return aStartLineNumber - bStartLineNumber;\n    }\n    const aExists = a ? 1 : 0;\n    const bExists = b ? 1 : 0;\n    return aExists - bExists;\n  }\n  /**\n   * A function that compares ranges, useful for sorting ranges\n   * It will first compare ranges on the endPosition and then on the startPosition\n   */\n  static compareRangesUsingEnds(a, b) {\n    if (a.endLineNumber === b.endLineNumber) {\n      if (a.endColumn === b.endColumn) {\n        if (a.startLineNumber === b.startLineNumber) {\n          return a.startColumn - b.startColumn;\n        }\n        return a.startLineNumber - b.startLineNumber;\n      }\n      return a.endColumn - b.endColumn;\n    }\n    return a.endLineNumber - b.endLineNumber;\n  }\n  /**\n   * Test if the range spans multiple lines.\n   */\n  static spansMultipleLines(range) {\n    return range.endLineNumber \u003e range.startLineNumber;\n  }\n  toJSON() {\n    return this;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/uint.js\nfunction toUint8(v) {\n  if (v \u003c 0) {\n    return 0;\n  }\n  if (v \u003e 255) {\n    return 255;\n  }\n  return v | 0;\n}\nfunction toUint32(v) {\n  if (v \u003c 0) {\n    return 0;\n  }\n  if (v \u003e 4294967295) {\n    return 4294967295;\n  }\n  return v | 0;\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js\nvar CharacterClassifier = class _CharacterClassifier {\n  constructor(_defaultValue) {\n    const defaultValue = toUint8(_defaultValue);\n    this._defaultValue = defaultValue;\n    this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);\n    this._map = /* @__PURE__ */ new Map();\n  }\n  static _createAsciiMap(defaultValue) {\n    const asciiMap = new Uint8Array(256);\n    asciiMap.fill(defaultValue);\n    return asciiMap;\n  }\n  set(charCode, _value) {\n    const value = toUint8(_value);\n    if (charCode \u003e= 0 \u0026\u0026 charCode \u003c 256) {\n      this._asciiMap[charCode] = value;\n    } else {\n      this._map.set(charCode, value);\n    }\n  }\n  get(charCode) {\n    if (charCode \u003e= 0 \u0026\u0026 charCode \u003c 256) {\n      return this._asciiMap[charCode];\n    } else {\n      return this._map.get(charCode) || this._defaultValue;\n    }\n  }\n  clear() {\n    this._asciiMap.fill(this._defaultValue);\n    this._map.clear();\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js\nvar Uint8Matrix = class {\n  constructor(rows, cols, defaultValue) {\n    const data = new Uint8Array(rows * cols);\n    for (let i = 0, len = rows * cols; i \u003c len; i++) {\n      data[i] = defaultValue;\n    }\n    this._data = data;\n    this.rows = rows;\n    this.cols = cols;\n  }\n  get(row, col) {\n    return this._data[row * this.cols + col];\n  }\n  set(row, col, value) {\n    this._data[row * this.cols + col] = value;\n  }\n};\nvar StateMachine = class {\n  constructor(edges) {\n    let maxCharCode = 0;\n    let maxState = 0;\n    for (let i = 0, len = edges.length; i \u003c len; i++) {\n      const [from, chCode, to] = edges[i];\n      if (chCode \u003e maxCharCode) {\n        maxCharCode = chCode;\n      }\n      if (from \u003e maxState) {\n        maxState = from;\n      }\n      if (to \u003e maxState) {\n        maxState = to;\n      }\n    }\n    maxCharCode++;\n    maxState++;\n    const states = new Uint8Matrix(\n      maxState,\n      maxCharCode,\n      0\n      /* State.Invalid */\n    );\n    for (let i = 0, len = edges.length; i \u003c len; i++) {\n      const [from, chCode, to] = edges[i];\n      states.set(from, chCode, to);\n    }\n    this._states = states;\n    this._maxCharCode = maxCharCode;\n  }\n  nextState(currentState, chCode) {\n    if (chCode \u003c 0 || chCode \u003e= this._maxCharCode) {\n      return 0;\n    }\n    return this._states.get(currentState, chCode);\n  }\n};\nvar _stateMachine = null;\nfunction getStateMachine() {\n  if (_stateMachine === null) {\n    _stateMachine = new StateMachine([\n      [\n        1,\n        104,\n        2\n        /* State.H */\n      ],\n      [\n        1,\n        72,\n        2\n        /* State.H */\n      ],\n      [\n        1,\n        102,\n        6\n        /* State.F */\n      ],\n      [\n        1,\n        70,\n        6\n        /* State.F */\n      ],\n      [\n        2,\n        116,\n        3\n        /* State.HT */\n      ],\n      [\n        2,\n        84,\n        3\n        /* State.HT */\n      ],\n      [\n        3,\n        116,\n        4\n        /* State.HTT */\n      ],\n      [\n        3,\n        84,\n        4\n        /* State.HTT */\n      ],\n      [\n        4,\n        112,\n        5\n        /* State.HTTP */\n      ],\n      [\n        4,\n        80,\n        5\n        /* State.HTTP */\n      ],\n      [\n        5,\n        115,\n        9\n        /* State.BeforeColon */\n      ],\n      [\n        5,\n        83,\n        9\n        /* State.BeforeColon */\n      ],\n      [\n        5,\n        58,\n        10\n        /* State.AfterColon */\n      ],\n      [\n        6,\n        105,\n        7\n        /* State.FI */\n      ],\n      [\n        6,\n        73,\n        7\n        /* State.FI */\n      ],\n      [\n        7,\n        108,\n        8\n        /* State.FIL */\n      ],\n      [\n        7,\n        76,\n        8\n        /* State.FIL */\n      ],\n      [\n        8,\n        101,\n        9\n        /* State.BeforeColon */\n      ],\n      [\n        8,\n        69,\n        9\n        /* State.BeforeColon */\n      ],\n      [\n        9,\n        58,\n        10\n        /* State.AfterColon */\n      ],\n      [\n        10,\n        47,\n        11\n        /* State.AlmostThere */\n      ],\n      [\n        11,\n        47,\n        12\n        /* State.End */\n      ]\n    ]);\n  }\n  return _stateMachine;\n}\nvar _classifier = null;\nfunction getClassifier() {\n  if (_classifier === null) {\n    _classifier = new CharacterClassifier(\n      0\n      /* CharacterClass.None */\n    );\n    const FORCE_TERMINATION_CHARACTERS = ` \t\u003c\u003e'\"\\u3001\\u3002\\uFF61\\uFF64\\uFF0C\\uFF0E\\uFF1A\\uFF1B\\u2018\\u3008\\u300C\\u300E\\u3014\\uFF08\\uFF3B\\uFF5B\\uFF62\\uFF63\\uFF5D\\uFF3D\\uFF09\\u3015\\u300F\\u300D\\u3009\\u2019\\uFF40\\uFF5E\\u2026`;\n    for (let i = 0; i \u003c FORCE_TERMINATION_CHARACTERS.length; i++) {\n      _classifier.set(\n        FORCE_TERMINATION_CHARACTERS.charCodeAt(i),\n        1\n        /* CharacterClass.ForceTermination */\n      );\n    }\n    const CANNOT_END_WITH_CHARACTERS = \".,;:\";\n    for (let i = 0; i \u003c CANNOT_END_WITH_CHARACTERS.length; i++) {\n      _classifier.set(\n        CANNOT_END_WITH_CHARACTERS.charCodeAt(i),\n        2\n        /* CharacterClass.CannotEndIn */\n      );\n    }\n  }\n  return _classifier;\n}\nvar LinkComputer = class _LinkComputer {\n  static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n    let lastIncludedCharIndex = linkEndIndex - 1;\n    do {\n      const chCode = line.charCodeAt(lastIncludedCharIndex);\n      const chClass = classifier.get(chCode);\n      if (chClass !== 2) {\n        break;\n      }\n      lastIncludedCharIndex--;\n    } while (lastIncludedCharIndex \u003e linkBeginIndex);\n    if (linkBeginIndex \u003e 0) {\n      const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n      const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n      if (charCodeBeforeLink === 40 \u0026\u0026 lastCharCodeInLink === 41 || charCodeBeforeLink === 91 \u0026\u0026 lastCharCodeInLink === 93 || charCodeBeforeLink === 123 \u0026\u0026 lastCharCodeInLink === 125) {\n        lastIncludedCharIndex--;\n      }\n    }\n    return {\n      range: {\n        startLineNumber: lineNumber,\n        startColumn: linkBeginIndex + 1,\n        endLineNumber: lineNumber,\n        endColumn: lastIncludedCharIndex + 2\n      },\n      url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n    };\n  }\n  static computeLinks(model, stateMachine = getStateMachine()) {\n    const classifier = getClassifier();\n    const result = [];\n    for (let i = 1, lineCount = model.getLineCount(); i \u003c= lineCount; i++) {\n      const line = model.getLineContent(i);\n      const len = line.length;\n      let j = 0;\n      let linkBeginIndex = 0;\n      let linkBeginChCode = 0;\n      let state = 1;\n      let hasOpenParens = false;\n      let hasOpenSquareBracket = false;\n      let inSquareBrackets = false;\n      let hasOpenCurlyBracket = false;\n      while (j \u003c len) {\n        let resetStateMachine = false;\n        const chCode = line.charCodeAt(j);\n        if (state === 13) {\n          let chClass;\n          switch (chCode) {\n            case 40:\n              hasOpenParens = true;\n              chClass = 0;\n              break;\n            case 41:\n              chClass = hasOpenParens ? 0 : 1;\n              break;\n            case 91:\n              inSquareBrackets = true;\n              hasOpenSquareBracket = true;\n              chClass = 0;\n              break;\n            case 93:\n              inSquareBrackets = false;\n              chClass = hasOpenSquareBracket ? 0 : 1;\n              break;\n            case 123:\n              hasOpenCurlyBracket = true;\n              chClass = 0;\n              break;\n            case 125:\n              chClass = hasOpenCurlyBracket ? 0 : 1;\n              break;\n            case 39:\n            case 34:\n            case 96:\n              if (linkBeginChCode === chCode) {\n                chClass = 1;\n              } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {\n                chClass = 0;\n              } else {\n                chClass = 1;\n              }\n              break;\n            case 42:\n              chClass = linkBeginChCode === 42 ? 1 : 0;\n              break;\n            case 124:\n              chClass = linkBeginChCode === 124 ? 1 : 0;\n              break;\n            case 32:\n              chClass = inSquareBrackets ? 0 : 1;\n              break;\n            default:\n              chClass = classifier.get(chCode);\n          }\n          if (chClass === 1) {\n            result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n            resetStateMachine = true;\n          }\n        } else if (state === 12) {\n          let chClass;\n          if (chCode === 91) {\n            hasOpenSquareBracket = true;\n            chClass = 0;\n          } else {\n            chClass = classifier.get(chCode);\n          }\n          if (chClass === 1) {\n            resetStateMachine = true;\n          } else {\n            state = 13;\n          }\n        } else {\n          state = stateMachine.nextState(state, chCode);\n          if (state === 0) {\n            resetStateMachine = true;\n          }\n        }\n        if (resetStateMachine) {\n          state = 1;\n          hasOpenParens = false;\n          hasOpenSquareBracket = false;\n          hasOpenCurlyBracket = false;\n          linkBeginIndex = j + 1;\n          linkBeginChCode = chCode;\n        }\n        j++;\n      }\n      if (state === 13) {\n        result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n      }\n    }\n    return result;\n  }\n};\nfunction computeLinks(model) {\n  if (!model || typeof model.getLineCount !== \"function\" || typeof model.getLineContent !== \"function\") {\n    return [];\n  }\n  return LinkComputer.computeLinks(model);\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js\nvar BasicInplaceReplace = class _BasicInplaceReplace {\n  constructor() {\n    this._defaultValueSet = [\n      [\"true\", \"false\"],\n      [\"True\", \"False\"],\n      [\"Private\", \"Public\", \"Friend\", \"ReadOnly\", \"Partial\", \"Protected\", \"WriteOnly\"],\n      [\"public\", \"protected\", \"private\"]\n    ];\n  }\n  static {\n    this.INSTANCE = new _BasicInplaceReplace();\n  }\n  navigateValueSet(range1, text1, range2, text2, up) {\n    if (range1 \u0026\u0026 text1) {\n      const result = this.doNavigateValueSet(text1, up);\n      if (result) {\n        return {\n          range: range1,\n          value: result\n        };\n      }\n    }\n    if (range2 \u0026\u0026 text2) {\n      const result = this.doNavigateValueSet(text2, up);\n      if (result) {\n        return {\n          range: range2,\n          value: result\n        };\n      }\n    }\n    return null;\n  }\n  doNavigateValueSet(text, up) {\n    const numberResult = this.numberReplace(text, up);\n    if (numberResult !== null) {\n      return numberResult;\n    }\n    return this.textReplace(text, up);\n  }\n  numberReplace(value, up) {\n    const precision = Math.pow(10, value.length - (value.lastIndexOf(\".\") + 1));\n    let n1 = Number(value);\n    const n2 = parseFloat(value);\n    if (!isNaN(n1) \u0026\u0026 !isNaN(n2) \u0026\u0026 n1 === n2) {\n      if (n1 === 0 \u0026\u0026 !up) {\n        return null;\n      } else {\n        n1 = Math.floor(n1 * precision);\n        n1 += up ? precision : -precision;\n        return String(n1 / precision);\n      }\n    }\n    return null;\n  }\n  textReplace(value, up) {\n    return this.valueSetsReplace(this._defaultValueSet, value, up);\n  }\n  valueSetsReplace(valueSets, value, up) {\n    let result = null;\n    for (let i = 0, len = valueSets.length; result === null \u0026\u0026 i \u003c len; i++) {\n      result = this.valueSetReplace(valueSets[i], value, up);\n    }\n    return result;\n  }\n  valueSetReplace(valueSet, value, up) {\n    let idx = valueSet.indexOf(value);\n    if (idx \u003e= 0) {\n      idx += up ? 1 : -1;\n      if (idx \u003c 0) {\n        idx = valueSet.length - 1;\n      } else {\n        idx %= valueSet.length;\n      }\n      return valueSet[idx];\n    }\n    return null;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js\nvar shortcutEvent = Object.freeze(function(callback, context) {\n  const handle = setTimeout(callback.bind(context), 0);\n  return { dispose() {\n    clearTimeout(handle);\n  } };\n});\nvar CancellationToken;\n(function(CancellationToken2) {\n  function isCancellationToken(thing) {\n    if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {\n      return true;\n    }\n    if (thing instanceof MutableToken) {\n      return true;\n    }\n    if (!thing || typeof thing !== \"object\") {\n      return false;\n    }\n    return typeof thing.isCancellationRequested === \"boolean\" \u0026\u0026 typeof thing.onCancellationRequested === \"function\";\n  }\n  CancellationToken2.isCancellationToken = isCancellationToken;\n  CancellationToken2.None = Object.freeze({\n    isCancellationRequested: false,\n    onCancellationRequested: Event.None\n  });\n  CancellationToken2.Cancelled = Object.freeze({\n    isCancellationRequested: true,\n    onCancellationRequested: shortcutEvent\n  });\n})(CancellationToken || (CancellationToken = {}));\nvar MutableToken = class {\n  constructor() {\n    this._isCancelled = false;\n    this._emitter = null;\n  }\n  cancel() {\n    if (!this._isCancelled) {\n      this._isCancelled = true;\n      if (this._emitter) {\n        this._emitter.fire(void 0);\n        this.dispose();\n      }\n    }\n  }\n  get isCancellationRequested() {\n    return this._isCancelled;\n  }\n  get onCancellationRequested() {\n    if (this._isCancelled) {\n      return shortcutEvent;\n    }\n    if (!this._emitter) {\n      this._emitter = new Emitter();\n    }\n    return this._emitter.event;\n  }\n  dispose() {\n    if (this._emitter) {\n      this._emitter.dispose();\n      this._emitter = null;\n    }\n  }\n};\nvar CancellationTokenSource = class {\n  constructor(parent) {\n    this._token = void 0;\n    this._parentListener = void 0;\n    this._parentListener = parent \u0026\u0026 parent.onCancellationRequested(this.cancel, this);\n  }\n  get token() {\n    if (!this._token) {\n      this._token = new MutableToken();\n    }\n    return this._token;\n  }\n  cancel() {\n    if (!this._token) {\n      this._token = CancellationToken.Cancelled;\n    } else if (this._token instanceof MutableToken) {\n      this._token.cancel();\n    }\n  }\n  dispose(cancel = false) {\n    if (cancel) {\n      this.cancel();\n    }\n    this._parentListener?.dispose();\n    if (!this._token) {\n      this._token = CancellationToken.None;\n    } else if (this._token instanceof MutableToken) {\n      this._token.dispose();\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js\nvar KeyCodeStrMap = class {\n  constructor() {\n    this._keyCodeToStr = [];\n    this._strToKeyCode = /* @__PURE__ */ Object.create(null);\n  }\n  define(keyCode, str) {\n    this._keyCodeToStr[keyCode] = str;\n    this._strToKeyCode[str.toLowerCase()] = keyCode;\n  }\n  keyCodeToStr(keyCode) {\n    return this._keyCodeToStr[keyCode];\n  }\n  strToKeyCode(str) {\n    return this._strToKeyCode[str.toLowerCase()] || 0;\n  }\n};\nvar uiMap = new KeyCodeStrMap();\nvar userSettingsUSMap = new KeyCodeStrMap();\nvar userSettingsGeneralMap = new KeyCodeStrMap();\nvar EVENT_KEY_CODE_MAP = new Array(230);\nvar NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};\nvar scanCodeIntToStr = [];\nvar scanCodeStrToInt = /* @__PURE__ */ Object.create(null);\nvar scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);\nvar IMMUTABLE_CODE_TO_KEY_CODE = [];\nvar IMMUTABLE_KEY_CODE_TO_CODE = [];\nfor (let i = 0; i \u003c= 193; i++) {\n  IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;\n}\nfor (let i = 0; i \u003c= 132; i++) {\n  IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;\n}\n(function() {\n  const empty = \"\";\n  const mappings = [\n    // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel\n    [1, 0, \"None\", 0, \"unknown\", 0, \"VK_UNKNOWN\", empty, empty],\n    [1, 1, \"Hyper\", 0, empty, 0, empty, empty, empty],\n    [1, 2, \"Super\", 0, empty, 0, empty, empty, empty],\n    [1, 3, \"Fn\", 0, empty, 0, empty, empty, empty],\n    [1, 4, \"FnLock\", 0, empty, 0, empty, empty, empty],\n    [1, 5, \"Suspend\", 0, empty, 0, empty, empty, empty],\n    [1, 6, \"Resume\", 0, empty, 0, empty, empty, empty],\n    [1, 7, \"Turbo\", 0, empty, 0, empty, empty, empty],\n    [1, 8, \"Sleep\", 0, empty, 0, \"VK_SLEEP\", empty, empty],\n    [1, 9, \"WakeUp\", 0, empty, 0, empty, empty, empty],\n    [0, 10, \"KeyA\", 31, \"A\", 65, \"VK_A\", empty, empty],\n    [0, 11, \"KeyB\", 32, \"B\", 66, \"VK_B\", empty, empty],\n    [0, 12, \"KeyC\", 33, \"C\", 67, \"VK_C\", empty, empty],\n    [0, 13, \"KeyD\", 34, \"D\", 68, \"VK_D\", empty, empty],\n    [0, 14, \"KeyE\", 35, \"E\", 69, \"VK_E\", empty, empty],\n    [0, 15, \"KeyF\", 36, \"F\", 70, \"VK_F\", empty, empty],\n    [0, 16, \"KeyG\", 37, \"G\", 71, \"VK_G\", empty, empty],\n    [0, 17, \"KeyH\", 38, \"H\", 72, \"VK_H\", empty, empty],\n    [0, 18, \"KeyI\", 39, \"I\", 73, \"VK_I\", empty, empty],\n    [0, 19, \"KeyJ\", 40, \"J\", 74, \"VK_J\", empty, empty],\n    [0, 20, \"KeyK\", 41, \"K\", 75, \"VK_K\", empty, empty],\n    [0, 21, \"KeyL\", 42, \"L\", 76, \"VK_L\", empty, empty],\n    [0, 22, \"KeyM\", 43, \"M\", 77, \"VK_M\", empty, empty],\n    [0, 23, \"KeyN\", 44, \"N\", 78, \"VK_N\", empty, empty],\n    [0, 24, \"KeyO\", 45, \"O\", 79, \"VK_O\", empty, empty],\n    [0, 25, \"KeyP\", 46, \"P\", 80, \"VK_P\", empty, empty],\n    [0, 26, \"KeyQ\", 47, \"Q\", 81, \"VK_Q\", empty, empty],\n    [0, 27, \"KeyR\", 48, \"R\", 82, \"VK_R\", empty, empty],\n    [0, 28, \"KeyS\", 49, \"S\", 83, \"VK_S\", empty, empty],\n    [0, 29, \"KeyT\", 50, \"T\", 84, \"VK_T\", empty, empty],\n    [0, 30, \"KeyU\", 51, \"U\", 85, \"VK_U\", empty, empty],\n    [0, 31, \"KeyV\", 52, \"V\", 86, \"VK_V\", empty, empty],\n    [0, 32, \"KeyW\", 53, \"W\", 87, \"VK_W\", empty, empty],\n    [0, 33, \"KeyX\", 54, \"X\", 88, \"VK_X\", empty, empty],\n    [0, 34, \"KeyY\", 55, \"Y\", 89, \"VK_Y\", empty, empty],\n    [0, 35, \"KeyZ\", 56, \"Z\", 90, \"VK_Z\", empty, empty],\n    [0, 36, \"Digit1\", 22, \"1\", 49, \"VK_1\", empty, empty],\n    [0, 37, \"Digit2\", 23, \"2\", 50, \"VK_2\", empty, empty],\n    [0, 38, \"Digit3\", 24, \"3\", 51, \"VK_3\", empty, empty],\n    [0, 39, \"Digit4\", 25, \"4\", 52, \"VK_4\", empty, empty],\n    [0, 40, \"Digit5\", 26, \"5\", 53, \"VK_5\", empty, empty],\n    [0, 41, \"Digit6\", 27, \"6\", 54, \"VK_6\", empty, empty],\n    [0, 42, \"Digit7\", 28, \"7\", 55, \"VK_7\", empty, empty],\n    [0, 43, \"Digit8\", 29, \"8\", 56, \"VK_8\", empty, empty],\n    [0, 44, \"Digit9\", 30, \"9\", 57, \"VK_9\", empty, empty],\n    [0, 45, \"Digit0\", 21, \"0\", 48, \"VK_0\", empty, empty],\n    [1, 46, \"Enter\", 3, \"Enter\", 13, \"VK_RETURN\", empty, empty],\n    [1, 47, \"Escape\", 9, \"Escape\", 27, \"VK_ESCAPE\", empty, empty],\n    [1, 48, \"Backspace\", 1, \"Backspace\", 8, \"VK_BACK\", empty, empty],\n    [1, 49, \"Tab\", 2, \"Tab\", 9, \"VK_TAB\", empty, empty],\n    [1, 50, \"Space\", 10, \"Space\", 32, \"VK_SPACE\", empty, empty],\n    [0, 51, \"Minus\", 88, \"-\", 189, \"VK_OEM_MINUS\", \"-\", \"OEM_MINUS\"],\n    [0, 52, \"Equal\", 86, \"=\", 187, \"VK_OEM_PLUS\", \"=\", \"OEM_PLUS\"],\n    [0, 53, \"BracketLeft\", 92, \"[\", 219, \"VK_OEM_4\", \"[\", \"OEM_4\"],\n    [0, 54, \"BracketRight\", 94, \"]\", 221, \"VK_OEM_6\", \"]\", \"OEM_6\"],\n    [0, 55, \"Backslash\", 93, \"\\\\\", 220, \"VK_OEM_5\", \"\\\\\", \"OEM_5\"],\n    [0, 56, \"IntlHash\", 0, empty, 0, empty, empty, empty],\n    // has been dropped from the w3c spec\n    [0, 57, \"Semicolon\", 85, \";\", 186, \"VK_OEM_1\", \";\", \"OEM_1\"],\n    [0, 58, \"Quote\", 95, \"'\", 222, \"VK_OEM_7\", \"'\", \"OEM_7\"],\n    [0, 59, \"Backquote\", 91, \"`\", 192, \"VK_OEM_3\", \"`\", \"OEM_3\"],\n    [0, 60, \"Comma\", 87, \",\", 188, \"VK_OEM_COMMA\", \",\", \"OEM_COMMA\"],\n    [0, 61, \"Period\", 89, \".\", 190, \"VK_OEM_PERIOD\", \".\", \"OEM_PERIOD\"],\n    [0, 62, \"Slash\", 90, \"/\", 191, \"VK_OEM_2\", \"/\", \"OEM_2\"],\n    [1, 63, \"CapsLock\", 8, \"CapsLock\", 20, \"VK_CAPITAL\", empty, empty],\n    [1, 64, \"F1\", 59, \"F1\", 112, \"VK_F1\", empty, empty],\n    [1, 65, \"F2\", 60, \"F2\", 113, \"VK_F2\", empty, empty],\n    [1, 66, \"F3\", 61, \"F3\", 114, \"VK_F3\", empty, empty],\n    [1, 67, \"F4\", 62, \"F4\", 115, \"VK_F4\", empty, empty],\n    [1, 68, \"F5\", 63, \"F5\", 116, \"VK_F5\", empty, empty],\n    [1, 69, \"F6\", 64, \"F6\", 117, \"VK_F6\", empty, empty],\n    [1, 70, \"F7\", 65, \"F7\", 118, \"VK_F7\", empty, empty],\n    [1, 71, \"F8\", 66, \"F8\", 119, \"VK_F8\", empty, empty],\n    [1, 72, \"F9\", 67, \"F9\", 120, \"VK_F9\", empty, empty],\n    [1, 73, \"F10\", 68, \"F10\", 121, \"VK_F10\", empty, empty],\n    [1, 74, \"F11\", 69, \"F11\", 122, \"VK_F11\", empty, empty],\n    [1, 75, \"F12\", 70, \"F12\", 123, \"VK_F12\", empty, empty],\n    [1, 76, \"PrintScreen\", 0, empty, 0, empty, empty, empty],\n    [1, 77, \"ScrollLock\", 84, \"ScrollLock\", 145, \"VK_SCROLL\", empty, empty],\n    [1, 78, \"Pause\", 7, \"PauseBreak\", 19, \"VK_PAUSE\", empty, empty],\n    [1, 79, \"Insert\", 19, \"Insert\", 45, \"VK_INSERT\", empty, empty],\n    [1, 80, \"Home\", 14, \"Home\", 36, \"VK_HOME\", empty, empty],\n    [1, 81, \"PageUp\", 11, \"PageUp\", 33, \"VK_PRIOR\", empty, empty],\n    [1, 82, \"Delete\", 20, \"Delete\", 46, \"VK_DELETE\", empty, empty],\n    [1, 83, \"End\", 13, \"End\", 35, \"VK_END\", empty, empty],\n    [1, 84, \"PageDown\", 12, \"PageDown\", 34, \"VK_NEXT\", empty, empty],\n    [1, 85, \"ArrowRight\", 17, \"RightArrow\", 39, \"VK_RIGHT\", \"Right\", empty],\n    [1, 86, \"ArrowLeft\", 15, \"LeftArrow\", 37, \"VK_LEFT\", \"Left\", empty],\n    [1, 87, \"ArrowDown\", 18, \"DownArrow\", 40, \"VK_DOWN\", \"Down\", empty],\n    [1, 88, \"ArrowUp\", 16, \"UpArrow\", 38, \"VK_UP\", \"Up\", empty],\n    [1, 89, \"NumLock\", 83, \"NumLock\", 144, \"VK_NUMLOCK\", empty, empty],\n    [1, 90, \"NumpadDivide\", 113, \"NumPad_Divide\", 111, \"VK_DIVIDE\", empty, empty],\n    [1, 91, \"NumpadMultiply\", 108, \"NumPad_Multiply\", 106, \"VK_MULTIPLY\", empty, empty],\n    [1, 92, \"NumpadSubtract\", 111, \"NumPad_Subtract\", 109, \"VK_SUBTRACT\", empty, empty],\n    [1, 93, \"NumpadAdd\", 109, \"NumPad_Add\", 107, \"VK_ADD\", empty, empty],\n    [1, 94, \"NumpadEnter\", 3, empty, 0, empty, empty, empty],\n    [1, 95, \"Numpad1\", 99, \"NumPad1\", 97, \"VK_NUMPAD1\", empty, empty],\n    [1, 96, \"Numpad2\", 100, \"NumPad2\", 98, \"VK_NUMPAD2\", empty, empty],\n    [1, 97, \"Numpad3\", 101, \"NumPad3\", 99, \"VK_NUMPAD3\", empty, empty],\n    [1, 98, \"Numpad4\", 102, \"NumPad4\", 100, \"VK_NUMPAD4\", empty, empty],\n    [1, 99, \"Numpad5\", 103, \"NumPad5\", 101, \"VK_NUMPAD5\", empty, empty],\n    [1, 100, \"Numpad6\", 104, \"NumPad6\", 102, \"VK_NUMPAD6\", empty, empty],\n    [1, 101, \"Numpad7\", 105, \"NumPad7\", 103, \"VK_NUMPAD7\", empty, empty],\n    [1, 102, \"Numpad8\", 106, \"NumPad8\", 104, \"VK_NUMPAD8\", empty, empty],\n    [1, 103, \"Numpad9\", 107, \"NumPad9\", 105, \"VK_NUMPAD9\", empty, empty],\n    [1, 104, \"Numpad0\", 98, \"NumPad0\", 96, \"VK_NUMPAD0\", empty, empty],\n    [1, 105, \"NumpadDecimal\", 112, \"NumPad_Decimal\", 110, \"VK_DECIMAL\", empty, empty],\n    [0, 106, \"IntlBackslash\", 97, \"OEM_102\", 226, \"VK_OEM_102\", empty, empty],\n    [1, 107, \"ContextMenu\", 58, \"ContextMenu\", 93, empty, empty, empty],\n    [1, 108, \"Power\", 0, empty, 0, empty, empty, empty],\n    [1, 109, \"NumpadEqual\", 0, empty, 0, empty, empty, empty],\n    [1, 110, \"F13\", 71, \"F13\", 124, \"VK_F13\", empty, empty],\n    [1, 111, \"F14\", 72, \"F14\", 125, \"VK_F14\", empty, empty],\n    [1, 112, \"F15\", 73, \"F15\", 126, \"VK_F15\", empty, empty],\n    [1, 113, \"F16\", 74, \"F16\", 127, \"VK_F16\", empty, empty],\n    [1, 114, \"F17\", 75, \"F17\", 128, \"VK_F17\", empty, empty],\n    [1, 115, \"F18\", 76, \"F18\", 129, \"VK_F18\", empty, empty],\n    [1, 116, \"F19\", 77, \"F19\", 130, \"VK_F19\", empty, empty],\n    [1, 117, \"F20\", 78, \"F20\", 131, \"VK_F20\", empty, empty],\n    [1, 118, \"F21\", 79, \"F21\", 132, \"VK_F21\", empty, empty],\n    [1, 119, \"F22\", 80, \"F22\", 133, \"VK_F22\", empty, empty],\n    [1, 120, \"F23\", 81, \"F23\", 134, \"VK_F23\", empty, empty],\n    [1, 121, \"F24\", 82, \"F24\", 135, \"VK_F24\", empty, empty],\n    [1, 122, \"Open\", 0, empty, 0, empty, empty, empty],\n    [1, 123, \"Help\", 0, empty, 0, empty, empty, empty],\n    [1, 124, \"Select\", 0, empty, 0, empty, empty, empty],\n    [1, 125, \"Again\", 0, empty, 0, empty, empty, empty],\n    [1, 126, \"Undo\", 0, empty, 0, empty, empty, empty],\n    [1, 127, \"Cut\", 0, empty, 0, empty, empty, empty],\n    [1, 128, \"Copy\", 0, empty, 0, empty, empty, empty],\n    [1, 129, \"Paste\", 0, empty, 0, empty, empty, empty],\n    [1, 130, \"Find\", 0, empty, 0, empty, empty, empty],\n    [1, 131, \"AudioVolumeMute\", 117, \"AudioVolumeMute\", 173, \"VK_VOLUME_MUTE\", empty, empty],\n    [1, 132, \"AudioVolumeUp\", 118, \"AudioVolumeUp\", 175, \"VK_VOLUME_UP\", empty, empty],\n    [1, 133, \"AudioVolumeDown\", 119, \"AudioVolumeDown\", 174, \"VK_VOLUME_DOWN\", empty, empty],\n    [1, 134, \"NumpadComma\", 110, \"NumPad_Separator\", 108, \"VK_SEPARATOR\", empty, empty],\n    [0, 135, \"IntlRo\", 115, \"ABNT_C1\", 193, \"VK_ABNT_C1\", empty, empty],\n    [1, 136, \"KanaMode\", 0, empty, 0, empty, empty, empty],\n    [0, 137, \"IntlYen\", 0, empty, 0, empty, empty, empty],\n    [1, 138, \"Convert\", 0, empty, 0, empty, empty, empty],\n    [1, 139, \"NonConvert\", 0, empty, 0, empty, empty, empty],\n    [1, 140, \"Lang1\", 0, empty, 0, empty, empty, empty],\n    [1, 141, \"Lang2\", 0, empty, 0, empty, empty, empty],\n    [1, 142, \"Lang3\", 0, empty, 0, empty, empty, empty],\n    [1, 143, \"Lang4\", 0, empty, 0, empty, empty, empty],\n    [1, 144, \"Lang5\", 0, empty, 0, empty, empty, empty],\n    [1, 145, \"Abort\", 0, empty, 0, empty, empty, empty],\n    [1, 146, \"Props\", 0, empty, 0, empty, empty, empty],\n    [1, 147, \"NumpadParenLeft\", 0, empty, 0, empty, empty, empty],\n    [1, 148, \"NumpadParenRight\", 0, empty, 0, empty, empty, empty],\n    [1, 149, \"NumpadBackspace\", 0, empty, 0, empty, empty, empty],\n    [1, 150, \"NumpadMemoryStore\", 0, empty, 0, empty, empty, empty],\n    [1, 151, \"NumpadMemoryRecall\", 0, empty, 0, empty, empty, empty],\n    [1, 152, \"NumpadMemoryClear\", 0, empty, 0, empty, empty, empty],\n    [1, 153, \"NumpadMemoryAdd\", 0, empty, 0, empty, empty, empty],\n    [1, 154, \"NumpadMemorySubtract\", 0, empty, 0, empty, empty, empty],\n    [1, 155, \"NumpadClear\", 131, \"Clear\", 12, \"VK_CLEAR\", empty, empty],\n    [1, 156, \"NumpadClearEntry\", 0, empty, 0, empty, empty, empty],\n    [1, 0, empty, 5, \"Ctrl\", 17, \"VK_CONTROL\", empty, empty],\n    [1, 0, empty, 4, \"Shift\", 16, \"VK_SHIFT\", empty, empty],\n    [1, 0, empty, 6, \"Alt\", 18, \"VK_MENU\", empty, empty],\n    [1, 0, empty, 57, \"Meta\", 91, \"VK_COMMAND\", empty, empty],\n    [1, 157, \"ControlLeft\", 5, empty, 0, \"VK_LCONTROL\", empty, empty],\n    [1, 158, \"ShiftLeft\", 4, empty, 0, \"VK_LSHIFT\", empty, empty],\n    [1, 159, \"AltLeft\", 6, empty, 0, \"VK_LMENU\", empty, empty],\n    [1, 160, \"MetaLeft\", 57, empty, 0, \"VK_LWIN\", empty, empty],\n    [1, 161, \"ControlRight\", 5, empty, 0, \"VK_RCONTROL\", empty, empty],\n    [1, 162, \"ShiftRight\", 4, empty, 0, \"VK_RSHIFT\", empty, empty],\n    [1, 163, \"AltRight\", 6, empty, 0, \"VK_RMENU\", empty, empty],\n    [1, 164, \"MetaRight\", 57, empty, 0, \"VK_RWIN\", empty, empty],\n    [1, 165, \"BrightnessUp\", 0, empty, 0, empty, empty, empty],\n    [1, 166, \"BrightnessDown\", 0, empty, 0, empty, empty, empty],\n    [1, 167, \"MediaPlay\", 0, empty, 0, empty, empty, empty],\n    [1, 168, \"MediaRecord\", 0, empty, 0, empty, empty, empty],\n    [1, 169, \"MediaFastForward\", 0, empty, 0, empty, empty, empty],\n    [1, 170, \"MediaRewind\", 0, empty, 0, empty, empty, empty],\n    [1, 171, \"MediaTrackNext\", 124, \"MediaTrackNext\", 176, \"VK_MEDIA_NEXT_TRACK\", empty, empty],\n    [1, 172, \"MediaTrackPrevious\", 125, \"MediaTrackPrevious\", 177, \"VK_MEDIA_PREV_TRACK\", empty, empty],\n    [1, 173, \"MediaStop\", 126, \"MediaStop\", 178, \"VK_MEDIA_STOP\", empty, empty],\n    [1, 174, \"Eject\", 0, empty, 0, empty, empty, empty],\n    [1, 175, \"MediaPlayPause\", 127, \"MediaPlayPause\", 179, \"VK_MEDIA_PLAY_PAUSE\", empty, empty],\n    [1, 176, \"MediaSelect\", 128, \"LaunchMediaPlayer\", 181, \"VK_MEDIA_LAUNCH_MEDIA_SELECT\", empty, empty],\n    [1, 177, \"LaunchMail\", 129, \"LaunchMail\", 180, \"VK_MEDIA_LAUNCH_MAIL\", empty, empty],\n    [1, 178, \"LaunchApp2\", 130, \"LaunchApp2\", 183, \"VK_MEDIA_LAUNCH_APP2\", empty, empty],\n    [1, 179, \"LaunchApp1\", 0, empty, 0, \"VK_MEDIA_LAUNCH_APP1\", empty, empty],\n    [1, 180, \"SelectTask\", 0, empty, 0, empty, empty, empty],\n    [1, 181, \"LaunchScreenSaver\", 0, empty, 0, empty, empty, empty],\n    [1, 182, \"BrowserSearch\", 120, \"BrowserSearch\", 170, \"VK_BROWSER_SEARCH\", empty, empty],\n    [1, 183, \"BrowserHome\", 121, \"BrowserHome\", 172, \"VK_BROWSER_HOME\", empty, empty],\n    [1, 184, \"BrowserBack\", 122, \"BrowserBack\", 166, \"VK_BROWSER_BACK\", empty, empty],\n    [1, 185, \"BrowserForward\", 123, \"BrowserForward\", 167, \"VK_BROWSER_FORWARD\", empty, empty],\n    [1, 186, \"BrowserStop\", 0, empty, 0, \"VK_BROWSER_STOP\", empty, empty],\n    [1, 187, \"BrowserRefresh\", 0, empty, 0, \"VK_BROWSER_REFRESH\", empty, empty],\n    [1, 188, \"BrowserFavorites\", 0, empty, 0, \"VK_BROWSER_FAVORITES\", empty, empty],\n    [1, 189, \"ZoomToggle\", 0, empty, 0, empty, empty, empty],\n    [1, 190, \"MailReply\", 0, empty, 0, empty, empty, empty],\n    [1, 191, \"MailForward\", 0, empty, 0, empty, empty, empty],\n    [1, 192, \"MailSend\", 0, empty, 0, empty, empty, empty],\n    // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n    // If an Input Method Editor is processing key input and the event is keydown, return 229.\n    [1, 0, empty, 114, \"KeyInComposition\", 229, empty, empty, empty],\n    [1, 0, empty, 116, \"ABNT_C2\", 194, \"VK_ABNT_C2\", empty, empty],\n    [1, 0, empty, 96, \"OEM_8\", 223, \"VK_OEM_8\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_KANA\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_HANGUL\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_JUNJA\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_FINAL\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_HANJA\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_KANJI\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_CONVERT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_NONCONVERT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_ACCEPT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_MODECHANGE\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_SELECT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_PRINT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_EXECUTE\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_SNAPSHOT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_HELP\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_APPS\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_PROCESSKEY\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_PACKET\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_DBE_SBCSCHAR\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_DBE_DBCSCHAR\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_ATTN\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_CRSEL\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_EXSEL\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_EREOF\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_PLAY\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_ZOOM\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_NONAME\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_PA1\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_OEM_CLEAR\", empty, empty]\n  ];\n  const seenKeyCode = [];\n  const seenScanCode = [];\n  for (const mapping of mappings) {\n    const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;\n    if (!seenScanCode[scanCode]) {\n      seenScanCode[scanCode] = true;\n      scanCodeIntToStr[scanCode] = scanCodeStr;\n      scanCodeStrToInt[scanCodeStr] = scanCode;\n      scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;\n      if (immutable) {\n        IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;\n        if (keyCode !== 0 \u0026\u0026 keyCode !== 3 \u0026\u0026 keyCode !== 5 \u0026\u0026 keyCode !== 4 \u0026\u0026 keyCode !== 6 \u0026\u0026 keyCode !== 57) {\n          IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;\n        }\n      }\n    }\n    if (!seenKeyCode[keyCode]) {\n      seenKeyCode[keyCode] = true;\n      if (!keyCodeStr) {\n        throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);\n      }\n      uiMap.define(keyCode, keyCodeStr);\n      userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);\n      userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);\n    }\n    if (eventKeyCode) {\n      EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;\n    }\n    if (vkey) {\n      NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;\n    }\n  }\n  IMMUTABLE_KEY_CODE_TO_CODE[\n    3\n    /* KeyCode.Enter */\n  ] = 46;\n})();\nvar KeyCodeUtils;\n(function(KeyCodeUtils2) {\n  function toString(keyCode) {\n    return uiMap.keyCodeToStr(keyCode);\n  }\n  KeyCodeUtils2.toString = toString;\n  function fromString(key) {\n    return uiMap.strToKeyCode(key);\n  }\n  KeyCodeUtils2.fromString = fromString;\n  function toUserSettingsUS(keyCode) {\n    return userSettingsUSMap.keyCodeToStr(keyCode);\n  }\n  KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;\n  function toUserSettingsGeneral(keyCode) {\n    return userSettingsGeneralMap.keyCodeToStr(keyCode);\n  }\n  KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;\n  function fromUserSettings(key) {\n    return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\n  }\n  KeyCodeUtils2.fromUserSettings = fromUserSettings;\n  function toElectronAccelerator(keyCode) {\n    if (keyCode \u003e= 98 \u0026\u0026 keyCode \u003c= 113) {\n      return null;\n    }\n    switch (keyCode) {\n      case 16:\n        return \"Up\";\n      case 18:\n        return \"Down\";\n      case 15:\n        return \"Left\";\n      case 17:\n        return \"Right\";\n    }\n    return uiMap.keyCodeToStr(keyCode);\n  }\n  KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;\n})(KeyCodeUtils || (KeyCodeUtils = {}));\nfunction KeyChord(firstPart, secondPart) {\n  const chordPart = (secondPart \u0026 65535) \u003c\u003c 16 \u003e\u003e\u003e 0;\n  return (firstPart | chordPart) \u003e\u003e\u003e 0;\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js\nvar Selection = class _Selection extends Range {\n  constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n    super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n    this.selectionStartLineNumber = selectionStartLineNumber;\n    this.selectionStartColumn = selectionStartColumn;\n    this.positionLineNumber = positionLineNumber;\n    this.positionColumn = positionColumn;\n  }\n  /**\n   * Transform to a human-readable representation.\n   */\n  toString() {\n    return \"[\" + this.selectionStartLineNumber + \",\" + this.selectionStartColumn + \" -\u003e \" + this.positionLineNumber + \",\" + this.positionColumn + \"]\";\n  }\n  /**\n   * Test if equals other selection.\n   */\n  equalsSelection(other) {\n    return _Selection.selectionsEqual(this, other);\n  }\n  /**\n   * Test if the two selections are equal.\n   */\n  static selectionsEqual(a, b) {\n    return a.selectionStartLineNumber === b.selectionStartLineNumber \u0026\u0026 a.selectionStartColumn === b.selectionStartColumn \u0026\u0026 a.positionLineNumber === b.positionLineNumber \u0026\u0026 a.positionColumn === b.positionColumn;\n  }\n  /**\n   * Get directions (LTR or RTL).\n   */\n  getDirection() {\n    if (this.selectionStartLineNumber === this.startLineNumber \u0026\u0026 this.selectionStartColumn === this.startColumn) {\n      return 0;\n    }\n    return 1;\n  }\n  /**\n   * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n   */\n  setEndPosition(endLineNumber, endColumn) {\n    if (this.getDirection() === 0) {\n      return new _Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    return new _Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n  }\n  /**\n   * Get the position at `positionLineNumber` and `positionColumn`.\n   */\n  getPosition() {\n    return new Position(this.positionLineNumber, this.positionColumn);\n  }\n  /**\n   * Get the position at the start of the selection.\n  */\n  getSelectionStart() {\n    return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n  }\n  /**\n   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n   */\n  setStartPosition(startLineNumber, startColumn) {\n    if (this.getDirection() === 0) {\n      return new _Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    return new _Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n  }\n  // ----\n  /**\n   * Create a `Selection` from one or two positions\n   */\n  static fromPositions(start, end = start) {\n    return new _Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n  /**\n   * Creates a `Selection` from a range, given a direction.\n   */\n  static fromRange(range, direction) {\n    if (direction === 0) {\n      return new _Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    } else {\n      return new _Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n    }\n  }\n  /**\n   * Create a `Selection` from an `ISelection`.\n   */\n  static liftSelection(sel) {\n    return new _Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n  }\n  /**\n   * `a` equals `b`.\n   */\n  static selectionsArrEqual(a, b) {\n    if (a \u0026\u0026 !b || !a \u0026\u0026 b) {\n      return false;\n    }\n    if (!a \u0026\u0026 !b) {\n      return true;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0, len = a.length; i \u003c len; i++) {\n      if (!this.selectionsEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Test if `obj` is an `ISelection`.\n   */\n  static isISelection(obj) {\n    return obj \u0026\u0026 typeof obj.selectionStartLineNumber === \"number\" \u0026\u0026 typeof obj.selectionStartColumn === \"number\" \u0026\u0026 typeof obj.positionLineNumber === \"number\" \u0026\u0026 typeof obj.positionColumn === \"number\";\n  }\n  /**\n   * Create with a direction.\n   */\n  static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n    if (direction === 0) {\n      return new _Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    return new _Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/types.js\nfunction isString(str) {\n  return typeof str === \"string\";\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js\nvar _codiconFontCharacters = /* @__PURE__ */ Object.create(null);\nfunction register(id, fontCharacter) {\n  if (isString(fontCharacter)) {\n    const val = _codiconFontCharacters[fontCharacter];\n    if (val === void 0) {\n      throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);\n    }\n    fontCharacter = val;\n  }\n  _codiconFontCharacters[id] = fontCharacter;\n  return { id };\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js\nvar codiconsLibrary = {\n  add: register(\"add\", 6e4),\n  plus: register(\"plus\", 6e4),\n  gistNew: register(\"gist-new\", 6e4),\n  repoCreate: register(\"repo-create\", 6e4),\n  lightbulb: register(\"lightbulb\", 60001),\n  lightBulb: register(\"light-bulb\", 60001),\n  repo: register(\"repo\", 60002),\n  repoDelete: register(\"repo-delete\", 60002),\n  gistFork: register(\"gist-fork\", 60003),\n  repoForked: register(\"repo-forked\", 60003),\n  gitPullRequest: register(\"git-pull-request\", 60004),\n  gitPullRequestAbandoned: register(\"git-pull-request-abandoned\", 60004),\n  recordKeys: register(\"record-keys\", 60005),\n  keyboard: register(\"keyboard\", 60005),\n  tag: register(\"tag\", 60006),\n  gitPullRequestLabel: register(\"git-pull-request-label\", 60006),\n  tagAdd: register(\"tag-add\", 60006),\n  tagRemove: register(\"tag-remove\", 60006),\n  person: register(\"person\", 60007),\n  personFollow: register(\"person-follow\", 60007),\n  personOutline: register(\"person-outline\", 60007),\n  personFilled: register(\"person-filled\", 60007),\n  gitBranch: register(\"git-branch\", 60008),\n  gitBranchCreate: register(\"git-branch-create\", 60008),\n  gitBranchDelete: register(\"git-branch-delete\", 60008),\n  sourceControl: register(\"source-control\", 60008),\n  mirror: register(\"mirror\", 60009),\n  mirrorPublic: register(\"mirror-public\", 60009),\n  star: register(\"star\", 60010),\n  starAdd: register(\"star-add\", 60010),\n  starDelete: register(\"star-delete\", 60010),\n  starEmpty: register(\"star-empty\", 60010),\n  comment: register(\"comment\", 60011),\n  commentAdd: register(\"comment-add\", 60011),\n  alert: register(\"alert\", 60012),\n  warning: register(\"warning\", 60012),\n  search: register(\"search\", 60013),\n  searchSave: register(\"search-save\", 60013),\n  logOut: register(\"log-out\", 60014),\n  signOut: register(\"sign-out\", 60014),\n  logIn: register(\"log-in\", 60015),\n  signIn: register(\"sign-in\", 60015),\n  eye: register(\"eye\", 60016),\n  eyeUnwatch: register(\"eye-unwatch\", 60016),\n  eyeWatch: register(\"eye-watch\", 60016),\n  circleFilled: register(\"circle-filled\", 60017),\n  primitiveDot: register(\"primitive-dot\", 60017),\n  closeDirty: register(\"close-dirty\", 60017),\n  debugBreakpoint: register(\"debug-breakpoint\", 60017),\n  debugBreakpointDisabled: register(\"debug-breakpoint-disabled\", 60017),\n  debugHint: register(\"debug-hint\", 60017),\n  terminalDecorationSuccess: register(\"terminal-decoration-success\", 60017),\n  primitiveSquare: register(\"primitive-square\", 60018),\n  edit: register(\"edit\", 60019),\n  pencil: register(\"pencil\", 60019),\n  info: register(\"info\", 60020),\n  issueOpened: register(\"issue-opened\", 60020),\n  gistPrivate: register(\"gist-private\", 60021),\n  gitForkPrivate: register(\"git-fork-private\", 60021),\n  lock: register(\"lock\", 60021),\n  mirrorPrivate: register(\"mirror-private\", 60021),\n  close: register(\"close\", 60022),\n  removeClose: register(\"remove-close\", 60022),\n  x: register(\"x\", 60022),\n  repoSync: register(\"repo-sync\", 60023),\n  sync: register(\"sync\", 60023),\n  clone: register(\"clone\", 60024),\n  desktopDownload: register(\"desktop-download\", 60024),\n  beaker: register(\"beaker\", 60025),\n  microscope: register(\"microscope\", 60025),\n  vm: register(\"vm\", 60026),\n  deviceDesktop: register(\"device-desktop\", 60026),\n  file: register(\"file\", 60027),\n  fileText: register(\"file-text\", 60027),\n  more: register(\"more\", 60028),\n  ellipsis: register(\"ellipsis\", 60028),\n  kebabHorizontal: register(\"kebab-horizontal\", 60028),\n  mailReply: register(\"mail-reply\", 60029),\n  reply: register(\"reply\", 60029),\n  organization: register(\"organization\", 60030),\n  organizationFilled: register(\"organization-filled\", 60030),\n  organizationOutline: register(\"organization-outline\", 60030),\n  newFile: register(\"new-file\", 60031),\n  fileAdd: register(\"file-add\", 60031),\n  newFolder: register(\"new-folder\", 60032),\n  fileDirectoryCreate: register(\"file-directory-create\", 60032),\n  trash: register(\"trash\", 60033),\n  trashcan: register(\"trashcan\", 60033),\n  history: register(\"history\", 60034),\n  clock: register(\"clock\", 60034),\n  folder: register(\"folder\", 60035),\n  fileDirectory: register(\"file-directory\", 60035),\n  symbolFolder: register(\"symbol-folder\", 60035),\n  logoGithub: register(\"logo-github\", 60036),\n  markGithub: register(\"mark-github\", 60036),\n  github: register(\"github\", 60036),\n  terminal: register(\"terminal\", 60037),\n  console: register(\"console\", 60037),\n  repl: register(\"repl\", 60037),\n  zap: register(\"zap\", 60038),\n  symbolEvent: register(\"symbol-event\", 60038),\n  error: register(\"error\", 60039),\n  stop: register(\"stop\", 60039),\n  variable: register(\"variable\", 60040),\n  symbolVariable: register(\"symbol-variable\", 60040),\n  array: register(\"array\", 60042),\n  symbolArray: register(\"symbol-array\", 60042),\n  symbolModule: register(\"symbol-module\", 60043),\n  symbolPackage: register(\"symbol-package\", 60043),\n  symbolNamespace: register(\"symbol-namespace\", 60043),\n  symbolObject: register(\"symbol-object\", 60043),\n  symbolMethod: register(\"symbol-method\", 60044),\n  symbolFunction: register(\"symbol-function\", 60044),\n  symbolConstructor: register(\"symbol-constructor\", 60044),\n  symbolBoolean: register(\"symbol-boolean\", 60047),\n  symbolNull: register(\"symbol-null\", 60047),\n  symbolNumeric: register(\"symbol-numeric\", 60048),\n  symbolNumber: register(\"symbol-number\", 60048),\n  symbolStructure: register(\"symbol-structure\", 60049),\n  symbolStruct: register(\"symbol-struct\", 60049),\n  symbolParameter: register(\"symbol-parameter\", 60050),\n  symbolTypeParameter: register(\"symbol-type-parameter\", 60050),\n  symbolKey: register(\"symbol-key\", 60051),\n  symbolText: register(\"symbol-text\", 60051),\n  symbolReference: register(\"symbol-reference\", 60052),\n  goToFile: register(\"go-to-file\", 60052),\n  symbolEnum: register(\"symbol-enum\", 60053),\n  symbolValue: register(\"symbol-value\", 60053),\n  symbolRuler: register(\"symbol-ruler\", 60054),\n  symbolUnit: register(\"symbol-unit\", 60054),\n  activateBreakpoints: register(\"activate-breakpoints\", 60055),\n  archive: register(\"archive\", 60056),\n  arrowBoth: register(\"arrow-both\", 60057),\n  arrowDown: register(\"arrow-down\", 60058),\n  arrowLeft: register(\"arrow-left\", 60059),\n  arrowRight: register(\"arrow-right\", 60060),\n  arrowSmallDown: register(\"arrow-small-down\", 60061),\n  arrowSmallLeft: register(\"arrow-small-left\", 60062),\n  arrowSmallRight: register(\"arrow-small-right\", 60063),\n  arrowSmallUp: register(\"arrow-small-up\", 60064),\n  arrowUp: register(\"arrow-up\", 60065),\n  bell: register(\"bell\", 60066),\n  bold: register(\"bold\", 60067),\n  book: register(\"book\", 60068),\n  bookmark: register(\"bookmark\", 60069),\n  debugBreakpointConditionalUnverified: register(\"debug-breakpoint-conditional-unverified\", 60070),\n  debugBreakpointConditional: register(\"debug-breakpoint-conditional\", 60071),\n  debugBreakpointConditionalDisabled: register(\"debug-breakpoint-conditional-disabled\", 60071),\n  debugBreakpointDataUnverified: register(\"debug-breakpoint-data-unverified\", 60072),\n  debugBreakpointData: register(\"debug-breakpoint-data\", 60073),\n  debugBreakpointDataDisabled: register(\"debug-breakpoint-data-disabled\", 60073),\n  debugBreakpointLogUnverified: register(\"debug-breakpoint-log-unverified\", 60074),\n  debugBreakpointLog: register(\"debug-breakpoint-log\", 60075),\n  debugBreakpointLogDisabled: register(\"debug-breakpoint-log-disabled\", 60075),\n  briefcase: register(\"briefcase\", 60076),\n  broadcast: register(\"broadcast\", 60077),\n  browser: register(\"browser\", 60078),\n  bug: register(\"bug\", 60079),\n  calendar: register(\"calendar\", 60080),\n  caseSensitive: register(\"case-sensitive\", 60081),\n  check: register(\"check\", 60082),\n  checklist: register(\"checklist\", 60083),\n  chevronDown: register(\"chevron-down\", 60084),\n  chevronLeft: register(\"chevron-left\", 60085),\n  chevronRight: register(\"chevron-right\", 60086),\n  chevronUp: register(\"chevron-up\", 60087),\n  chromeClose: register(\"chrome-close\", 60088),\n  chromeMaximize: register(\"chrome-maximize\", 60089),\n  chromeMinimize: register(\"chrome-minimize\", 60090),\n  chromeRestore: register(\"chrome-restore\", 60091),\n  circleOutline: register(\"circle-outline\", 60092),\n  circle: register(\"circle\", 60092),\n  debugBreakpointUnverified: register(\"debug-breakpoint-unverified\", 60092),\n  terminalDecorationIncomplete: register(\"terminal-decoration-incomplete\", 60092),\n  circleSlash: register(\"circle-slash\", 60093),\n  circuitBoard: register(\"circuit-board\", 60094),\n  clearAll: register(\"clear-all\", 60095),\n  clippy: register(\"clippy\", 60096),\n  closeAll: register(\"close-all\", 60097),\n  cloudDownload: register(\"cloud-download\", 60098),\n  cloudUpload: register(\"cloud-upload\", 60099),\n  code: register(\"code\", 60100),\n  collapseAll: register(\"collapse-all\", 60101),\n  colorMode: register(\"color-mode\", 60102),\n  commentDiscussion: register(\"comment-discussion\", 60103),\n  creditCard: register(\"credit-card\", 60105),\n  dash: register(\"dash\", 60108),\n  dashboard: register(\"dashboard\", 60109),\n  database: register(\"database\", 60110),\n  debugContinue: register(\"debug-continue\", 60111),\n  debugDisconnect: register(\"debug-disconnect\", 60112),\n  debugPause: register(\"debug-pause\", 60113),\n  debugRestart: register(\"debug-restart\", 60114),\n  debugStart: register(\"debug-start\", 60115),\n  debugStepInto: register(\"debug-step-into\", 60116),\n  debugStepOut: register(\"debug-step-out\", 60117),\n  debugStepOver: register(\"debug-step-over\", 60118),\n  debugStop: register(\"debug-stop\", 60119),\n  debug: register(\"debug\", 60120),\n  deviceCameraVideo: register(\"device-camera-video\", 60121),\n  deviceCamera: register(\"device-camera\", 60122),\n  deviceMobile: register(\"device-mobile\", 60123),\n  diffAdded: register(\"diff-added\", 60124),\n  diffIgnored: register(\"diff-ignored\", 60125),\n  diffModified: register(\"diff-modified\", 60126),\n  diffRemoved: register(\"diff-removed\", 60127),\n  diffRenamed: register(\"diff-renamed\", 60128),\n  diff: register(\"diff\", 60129),\n  diffSidebyside: register(\"diff-sidebyside\", 60129),\n  discard: register(\"discard\", 60130),\n  editorLayout: register(\"editor-layout\", 60131),\n  emptyWindow: register(\"empty-window\", 60132),\n  exclude: register(\"exclude\", 60133),\n  extensions: register(\"extensions\", 60134),\n  eyeClosed: register(\"eye-closed\", 60135),\n  fileBinary: register(\"file-binary\", 60136),\n  fileCode: register(\"file-code\", 60137),\n  fileMedia: register(\"file-media\", 60138),\n  filePdf: register(\"file-pdf\", 60139),\n  fileSubmodule: register(\"file-submodule\", 60140),\n  fileSymlinkDirectory: register(\"file-symlink-directory\", 60141),\n  fileSymlinkFile: register(\"file-symlink-file\", 60142),\n  fileZip: register(\"file-zip\", 60143),\n  files: register(\"files\", 60144),\n  filter: register(\"filter\", 60145),\n  flame: register(\"flame\", 60146),\n  foldDown: register(\"fold-down\", 60147),\n  foldUp: register(\"fold-up\", 60148),\n  fold: register(\"fold\", 60149),\n  folderActive: register(\"folder-active\", 60150),\n  folderOpened: register(\"folder-opened\", 60151),\n  gear: register(\"gear\", 60152),\n  gift: register(\"gift\", 60153),\n  gistSecret: register(\"gist-secret\", 60154),\n  gist: register(\"gist\", 60155),\n  gitCommit: register(\"git-commit\", 60156),\n  gitCompare: register(\"git-compare\", 60157),\n  compareChanges: register(\"compare-changes\", 60157),\n  gitMerge: register(\"git-merge\", 60158),\n  githubAction: register(\"github-action\", 60159),\n  githubAlt: register(\"github-alt\", 60160),\n  globe: register(\"globe\", 60161),\n  grabber: register(\"grabber\", 60162),\n  graph: register(\"graph\", 60163),\n  gripper: register(\"gripper\", 60164),\n  heart: register(\"heart\", 60165),\n  home: register(\"home\", 60166),\n  horizontalRule: register(\"horizontal-rule\", 60167),\n  hubot: register(\"hubot\", 60168),\n  inbox: register(\"inbox\", 60169),\n  issueReopened: register(\"issue-reopened\", 60171),\n  issues: register(\"issues\", 60172),\n  italic: register(\"italic\", 60173),\n  jersey: register(\"jersey\", 60174),\n  json: register(\"json\", 60175),\n  kebabVertical: register(\"kebab-vertical\", 60176),\n  key: register(\"key\", 60177),\n  law: register(\"law\", 60178),\n  lightbulbAutofix: register(\"lightbulb-autofix\", 60179),\n  linkExternal: register(\"link-external\", 60180),\n  link: register(\"link\", 60181),\n  listOrdered: register(\"list-ordered\", 60182),\n  listUnordered: register(\"list-unordered\", 60183),\n  liveShare: register(\"live-share\", 60184),\n  loading: register(\"loading\", 60185),\n  location: register(\"location\", 60186),\n  mailRead: register(\"mail-read\", 60187),\n  mail: register(\"mail\", 60188),\n  markdown: register(\"markdown\", 60189),\n  megaphone: register(\"megaphone\", 60190),\n  mention: register(\"mention\", 60191),\n  milestone: register(\"milestone\", 60192),\n  gitPullRequestMilestone: register(\"git-pull-request-milestone\", 60192),\n  mortarBoard: register(\"mortar-board\", 60193),\n  move: register(\"move\", 60194),\n  multipleWindows: register(\"multiple-windows\", 60195),\n  mute: register(\"mute\", 60196),\n  noNewline: register(\"no-newline\", 60197),\n  note: register(\"note\", 60198),\n  octoface: register(\"octoface\", 60199),\n  openPreview: register(\"open-preview\", 60200),\n  package: register(\"package\", 60201),\n  paintcan: register(\"paintcan\", 60202),\n  pin: register(\"pin\", 60203),\n  play: register(\"play\", 60204),\n  run: register(\"run\", 60204),\n  plug: register(\"plug\", 60205),\n  preserveCase: register(\"preserve-case\", 60206),\n  preview: register(\"preview\", 60207),\n  project: register(\"project\", 60208),\n  pulse: register(\"pulse\", 60209),\n  question: register(\"question\", 60210),\n  quote: register(\"quote\", 60211),\n  radioTower: register(\"radio-tower\", 60212),\n  reactions: register(\"reactions\", 60213),\n  references: register(\"references\", 60214),\n  refresh: register(\"refresh\", 60215),\n  regex: register(\"regex\", 60216),\n  remoteExplorer: register(\"remote-explorer\", 60217),\n  remote: register(\"remote\", 60218),\n  remove: register(\"remove\", 60219),\n  replaceAll: register(\"replace-all\", 60220),\n  replace: register(\"replace\", 60221),\n  repoClone: register(\"repo-clone\", 60222),\n  repoForcePush: register(\"repo-force-push\", 60223),\n  repoPull: register(\"repo-pull\", 60224),\n  repoPush: register(\"repo-push\", 60225),\n  report: register(\"report\", 60226),\n  requestChanges: register(\"request-changes\", 60227),\n  rocket: register(\"rocket\", 60228),\n  rootFolderOpened: register(\"root-folder-opened\", 60229),\n  rootFolder: register(\"root-folder\", 60230),\n  rss: register(\"rss\", 60231),\n  ruby: register(\"ruby\", 60232),\n  saveAll: register(\"save-all\", 60233),\n  saveAs: register(\"save-as\", 60234),\n  save: register(\"save\", 60235),\n  screenFull: register(\"screen-full\", 60236),\n  screenNormal: register(\"screen-normal\", 60237),\n  searchStop: register(\"search-stop\", 60238),\n  server: register(\"server\", 60240),\n  settingsGear: register(\"settings-gear\", 60241),\n  settings: register(\"settings\", 60242),\n  shield: register(\"shield\", 60243),\n  smiley: register(\"smiley\", 60244),\n  sortPrecedence: register(\"sort-precedence\", 60245),\n  splitHorizontal: register(\"split-horizontal\", 60246),\n  splitVertical: register(\"split-vertical\", 60247),\n  squirrel: register(\"squirrel\", 60248),\n  starFull: register(\"star-full\", 60249),\n  starHalf: register(\"star-half\", 60250),\n  symbolClass: register(\"symbol-class\", 60251),\n  symbolColor: register(\"symbol-color\", 60252),\n  symbolConstant: register(\"symbol-constant\", 60253),\n  symbolEnumMember: register(\"symbol-enum-member\", 60254),\n  symbolField: register(\"symbol-field\", 60255),\n  symbolFile: register(\"symbol-file\", 60256),\n  symbolInterface: register(\"symbol-interface\", 60257),\n  symbolKeyword: register(\"symbol-keyword\", 60258),\n  symbolMisc: register(\"symbol-misc\", 60259),\n  symbolOperator: register(\"symbol-operator\", 60260),\n  symbolProperty: register(\"symbol-property\", 60261),\n  wrench: register(\"wrench\", 60261),\n  wrenchSubaction: register(\"wrench-subaction\", 60261),\n  symbolSnippet: register(\"symbol-snippet\", 60262),\n  tasklist: register(\"tasklist\", 60263),\n  telescope: register(\"telescope\", 60264),\n  textSize: register(\"text-size\", 60265),\n  threeBars: register(\"three-bars\", 60266),\n  thumbsdown: register(\"thumbsdown\", 60267),\n  thumbsup: register(\"thumbsup\", 60268),\n  tools: register(\"tools\", 60269),\n  triangleDown: register(\"triangle-down\", 60270),\n  triangleLeft: register(\"triangle-left\", 60271),\n  triangleRight: register(\"triangle-right\", 60272),\n  triangleUp: register(\"triangle-up\", 60273),\n  twitter: register(\"twitter\", 60274),\n  unfold: register(\"unfold\", 60275),\n  unlock: register(\"unlock\", 60276),\n  unmute: register(\"unmute\", 60277),\n  unverified: register(\"unverified\", 60278),\n  verified: register(\"verified\", 60279),\n  versions: register(\"versions\", 60280),\n  vmActive: register(\"vm-active\", 60281),\n  vmOutline: register(\"vm-outline\", 60282),\n  vmRunning: register(\"vm-running\", 60283),\n  watch: register(\"watch\", 60284),\n  whitespace: register(\"whitespace\", 60285),\n  wholeWord: register(\"whole-word\", 60286),\n  window: register(\"window\", 60287),\n  wordWrap: register(\"word-wrap\", 60288),\n  zoomIn: register(\"zoom-in\", 60289),\n  zoomOut: register(\"zoom-out\", 60290),\n  listFilter: register(\"list-filter\", 60291),\n  listFlat: register(\"list-flat\", 60292),\n  listSelection: register(\"list-selection\", 60293),\n  selection: register(\"selection\", 60293),\n  listTree: register(\"list-tree\", 60294),\n  debugBreakpointFunctionUnverified: register(\"debug-breakpoint-function-unverified\", 60295),\n  debugBreakpointFunction: register(\"debug-breakpoint-function\", 60296),\n  debugBreakpointFunctionDisabled: register(\"debug-breakpoint-function-disabled\", 60296),\n  debugStackframeActive: register(\"debug-stackframe-active\", 60297),\n  circleSmallFilled: register(\"circle-small-filled\", 60298),\n  debugStackframeDot: register(\"debug-stackframe-dot\", 60298),\n  terminalDecorationMark: register(\"terminal-decoration-mark\", 60298),\n  debugStackframe: register(\"debug-stackframe\", 60299),\n  debugStackframeFocused: register(\"debug-stackframe-focused\", 60299),\n  debugBreakpointUnsupported: register(\"debug-breakpoint-unsupported\", 60300),\n  symbolString: register(\"symbol-string\", 60301),\n  debugReverseContinue: register(\"debug-reverse-continue\", 60302),\n  debugStepBack: register(\"debug-step-back\", 60303),\n  debugRestartFrame: register(\"debug-restart-frame\", 60304),\n  debugAlt: register(\"debug-alt\", 60305),\n  callIncoming: register(\"call-incoming\", 60306),\n  callOutgoing: register(\"call-outgoing\", 60307),\n  menu: register(\"menu\", 60308),\n  expandAll: register(\"expand-all\", 60309),\n  feedback: register(\"feedback\", 60310),\n  gitPullRequestReviewer: register(\"git-pull-request-reviewer\", 60310),\n  groupByRefType: register(\"group-by-ref-type\", 60311),\n  ungroupByRefType: register(\"ungroup-by-ref-type\", 60312),\n  account: register(\"account\", 60313),\n  gitPullRequestAssignee: register(\"git-pull-request-assignee\", 60313),\n  bellDot: register(\"bell-dot\", 60314),\n  debugConsole: register(\"debug-console\", 60315),\n  library: register(\"library\", 60316),\n  output: register(\"output\", 60317),\n  runAll: register(\"run-all\", 60318),\n  syncIgnored: register(\"sync-ignored\", 60319),\n  pinned: register(\"pinned\", 60320),\n  githubInverted: register(\"github-inverted\", 60321),\n  serverProcess: register(\"server-process\", 60322),\n  serverEnvironment: register(\"server-environment\", 60323),\n  pass: register(\"pass\", 60324),\n  issueClosed: register(\"issue-closed\", 60324),\n  stopCircle: register(\"stop-circle\", 60325),\n  playCircle: register(\"play-circle\", 60326),\n  record: register(\"record\", 60327),\n  debugAltSmall: register(\"debug-alt-small\", 60328),\n  vmConnect: register(\"vm-connect\", 60329),\n  cloud: register(\"cloud\", 60330),\n  merge: register(\"merge\", 60331),\n  export: register(\"export\", 60332),\n  graphLeft: register(\"graph-left\", 60333),\n  magnet: register(\"magnet\", 60334),\n  notebook: register(\"notebook\", 60335),\n  redo: register(\"redo\", 60336),\n  checkAll: register(\"check-all\", 60337),\n  pinnedDirty: register(\"pinned-dirty\", 60338),\n  passFilled: register(\"pass-filled\", 60339),\n  circleLargeFilled: register(\"circle-large-filled\", 60340),\n  circleLarge: register(\"circle-large\", 60341),\n  circleLargeOutline: register(\"circle-large-outline\", 60341),\n  combine: register(\"combine\", 60342),\n  gather: register(\"gather\", 60342),\n  table: register(\"table\", 60343),\n  variableGroup: register(\"variable-group\", 60344),\n  typeHierarchy: register(\"type-hierarchy\", 60345),\n  typeHierarchySub: register(\"type-hierarchy-sub\", 60346),\n  typeHierarchySuper: register(\"type-hierarchy-super\", 60347),\n  gitPullRequestCreate: register(\"git-pull-request-create\", 60348),\n  runAbove: register(\"run-above\", 60349),\n  runBelow: register(\"run-below\", 60350),\n  notebookTemplate: register(\"notebook-template\", 60351),\n  debugRerun: register(\"debug-rerun\", 60352),\n  workspaceTrusted: register(\"workspace-trusted\", 60353),\n  workspaceUntrusted: register(\"workspace-untrusted\", 60354),\n  workspaceUnknown: register(\"workspace-unknown\", 60355),\n  terminalCmd: register(\"terminal-cmd\", 60356),\n  terminalDebian: register(\"terminal-debian\", 60357),\n  terminalLinux: register(\"terminal-linux\", 60358),\n  terminalPowershell: register(\"terminal-powershell\", 60359),\n  terminalTmux: register(\"terminal-tmux\", 60360),\n  terminalUbuntu: register(\"terminal-ubuntu\", 60361),\n  terminalBash: register(\"terminal-bash\", 60362),\n  arrowSwap: register(\"arrow-swap\", 60363),\n  copy: register(\"copy\", 60364),\n  personAdd: register(\"person-add\", 60365),\n  filterFilled: register(\"filter-filled\", 60366),\n  wand: register(\"wand\", 60367),\n  debugLineByLine: register(\"debug-line-by-line\", 60368),\n  inspect: register(\"inspect\", 60369),\n  layers: register(\"layers\", 60370),\n  layersDot: register(\"layers-dot\", 60371),\n  layersActive: register(\"layers-active\", 60372),\n  compass: register(\"compass\", 60373),\n  compassDot: register(\"compass-dot\", 60374),\n  compassActive: register(\"compass-active\", 60375),\n  azure: register(\"azure\", 60376),\n  issueDraft: register(\"issue-draft\", 60377),\n  gitPullRequestClosed: register(\"git-pull-request-closed\", 60378),\n  gitPullRequestDraft: register(\"git-pull-request-draft\", 60379),\n  debugAll: register(\"debug-all\", 60380),\n  debugCoverage: register(\"debug-coverage\", 60381),\n  runErrors: register(\"run-errors\", 60382),\n  folderLibrary: register(\"folder-library\", 60383),\n  debugContinueSmall: register(\"debug-continue-small\", 60384),\n  beakerStop: register(\"beaker-stop\", 60385),\n  graphLine: register(\"graph-line\", 60386),\n  graphScatter: register(\"graph-scatter\", 60387),\n  pieChart: register(\"pie-chart\", 60388),\n  bracket: register(\"bracket\", 60175),\n  bracketDot: register(\"bracket-dot\", 60389),\n  bracketError: register(\"bracket-error\", 60390),\n  lockSmall: register(\"lock-small\", 60391),\n  azureDevops: register(\"azure-devops\", 60392),\n  verifiedFilled: register(\"verified-filled\", 60393),\n  newline: register(\"newline\", 60394),\n  layout: register(\"layout\", 60395),\n  layoutActivitybarLeft: register(\"layout-activitybar-left\", 60396),\n  layoutActivitybarRight: register(\"layout-activitybar-right\", 60397),\n  layoutPanelLeft: register(\"layout-panel-left\", 60398),\n  layoutPanelCenter: register(\"layout-panel-center\", 60399),\n  layoutPanelJustify: register(\"layout-panel-justify\", 60400),\n  layoutPanelRight: register(\"layout-panel-right\", 60401),\n  layoutPanel: register(\"layout-panel\", 60402),\n  layoutSidebarLeft: register(\"layout-sidebar-left\", 60403),\n  layoutSidebarRight: register(\"layout-sidebar-right\", 60404),\n  layoutStatusbar: register(\"layout-statusbar\", 60405),\n  layoutMenubar: register(\"layout-menubar\", 60406),\n  layoutCentered: register(\"layout-centered\", 60407),\n  target: register(\"target\", 60408),\n  indent: register(\"indent\", 60409),\n  recordSmall: register(\"record-small\", 60410),\n  errorSmall: register(\"error-small\", 60411),\n  terminalDecorationError: register(\"terminal-decoration-error\", 60411),\n  arrowCircleDown: register(\"arrow-circle-down\", 60412),\n  arrowCircleLeft: register(\"arrow-circle-left\", 60413),\n  arrowCircleRight: register(\"arrow-circle-right\", 60414),\n  arrowCircleUp: register(\"arrow-circle-up\", 60415),\n  layoutSidebarRightOff: register(\"layout-sidebar-right-off\", 60416),\n  layoutPanelOff: register(\"layout-panel-off\", 60417),\n  layoutSidebarLeftOff: register(\"layout-sidebar-left-off\", 60418),\n  blank: register(\"blank\", 60419),\n  heartFilled: register(\"heart-filled\", 60420),\n  map: register(\"map\", 60421),\n  mapHorizontal: register(\"map-horizontal\", 60421),\n  foldHorizontal: register(\"fold-horizontal\", 60421),\n  mapFilled: register(\"map-filled\", 60422),\n  mapHorizontalFilled: register(\"map-horizontal-filled\", 60422),\n  foldHorizontalFilled: register(\"fold-horizontal-filled\", 60422),\n  circleSmall: register(\"circle-small\", 60423),\n  bellSlash: register(\"bell-slash\", 60424),\n  bellSlashDot: register(\"bell-slash-dot\", 60425),\n  commentUnresolved: register(\"comment-unresolved\", 60426),\n  gitPullRequestGoToChanges: register(\"git-pull-request-go-to-changes\", 60427),\n  gitPullRequestNewChanges: register(\"git-pull-request-new-changes\", 60428),\n  searchFuzzy: register(\"search-fuzzy\", 60429),\n  commentDraft: register(\"comment-draft\", 60430),\n  send: register(\"send\", 60431),\n  sparkle: register(\"sparkle\", 60432),\n  insert: register(\"insert\", 60433),\n  mic: register(\"mic\", 60434),\n  thumbsdownFilled: register(\"thumbsdown-filled\", 60435),\n  thumbsupFilled: register(\"thumbsup-filled\", 60436),\n  coffee: register(\"coffee\", 60437),\n  snake: register(\"snake\", 60438),\n  game: register(\"game\", 60439),\n  vr: register(\"vr\", 60440),\n  chip: register(\"chip\", 60441),\n  piano: register(\"piano\", 60442),\n  music: register(\"music\", 60443),\n  micFilled: register(\"mic-filled\", 60444),\n  repoFetch: register(\"repo-fetch\", 60445),\n  copilot: register(\"copilot\", 60446),\n  lightbulbSparkle: register(\"lightbulb-sparkle\", 60447),\n  robot: register(\"robot\", 60448),\n  sparkleFilled: register(\"sparkle-filled\", 60449),\n  diffSingle: register(\"diff-single\", 60450),\n  diffMultiple: register(\"diff-multiple\", 60451),\n  surroundWith: register(\"surround-with\", 60452),\n  share: register(\"share\", 60453),\n  gitStash: register(\"git-stash\", 60454),\n  gitStashApply: register(\"git-stash-apply\", 60455),\n  gitStashPop: register(\"git-stash-pop\", 60456),\n  vscode: register(\"vscode\", 60457),\n  vscodeInsiders: register(\"vscode-insiders\", 60458),\n  codeOss: register(\"code-oss\", 60459),\n  runCoverage: register(\"run-coverage\", 60460),\n  runAllCoverage: register(\"run-all-coverage\", 60461),\n  coverage: register(\"coverage\", 60462),\n  githubProject: register(\"github-project\", 60463),\n  mapVertical: register(\"map-vertical\", 60464),\n  foldVertical: register(\"fold-vertical\", 60464),\n  mapVerticalFilled: register(\"map-vertical-filled\", 60465),\n  foldVerticalFilled: register(\"fold-vertical-filled\", 60465),\n  goToSearch: register(\"go-to-search\", 60466),\n  percentage: register(\"percentage\", 60467),\n  sortPercentage: register(\"sort-percentage\", 60467),\n  attach: register(\"attach\", 60468)\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js\nvar codiconsDerived = {\n  dialogError: register(\"dialog-error\", \"error\"),\n  dialogWarning: register(\"dialog-warning\", \"warning\"),\n  dialogInfo: register(\"dialog-info\", \"info\"),\n  dialogClose: register(\"dialog-close\", \"close\"),\n  treeItemExpanded: register(\"tree-item-expanded\", \"chevron-down\"),\n  // collapsed is done with rotation\n  treeFilterOnTypeOn: register(\"tree-filter-on-type-on\", \"list-filter\"),\n  treeFilterOnTypeOff: register(\"tree-filter-on-type-off\", \"list-selection\"),\n  treeFilterClear: register(\"tree-filter-clear\", \"close\"),\n  treeItemLoading: register(\"tree-item-loading\", \"loading\"),\n  menuSelection: register(\"menu-selection\", \"check\"),\n  menuSubmenu: register(\"menu-submenu\", \"chevron-right\"),\n  menuBarMore: register(\"menubar-more\", \"more\"),\n  scrollbarButtonLeft: register(\"scrollbar-button-left\", \"triangle-left\"),\n  scrollbarButtonRight: register(\"scrollbar-button-right\", \"triangle-right\"),\n  scrollbarButtonUp: register(\"scrollbar-button-up\", \"triangle-up\"),\n  scrollbarButtonDown: register(\"scrollbar-button-down\", \"triangle-down\"),\n  toolBarMore: register(\"toolbar-more\", \"more\"),\n  quickInputBack: register(\"quick-input-back\", \"arrow-left\"),\n  dropDownButton: register(\"drop-down-button\", 60084),\n  symbolCustomColor: register(\"symbol-customcolor\", 60252),\n  exportIcon: register(\"export\", 60332),\n  workspaceUnspecified: register(\"workspace-unspecified\", 60355),\n  newLine: register(\"newline\", 60394),\n  thumbsDownFilled: register(\"thumbsdown-filled\", 60435),\n  thumbsUpFilled: register(\"thumbsup-filled\", 60436),\n  gitFetch: register(\"git-fetch\", 60445),\n  lightbulbSparkleAutofix: register(\"lightbulb-sparkle-autofix\", 60447),\n  debugBreakpointPending: register(\"debug-breakpoint-pending\", 60377)\n};\nvar Codicon = {\n  ...codiconsLibrary,\n  ...codiconsDerived\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js\nvar TokenizationRegistry = class {\n  constructor() {\n    this._tokenizationSupports = /* @__PURE__ */ new Map();\n    this._factories = /* @__PURE__ */ new Map();\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n    this._colorMap = null;\n  }\n  handleChange(languageIds) {\n    this._onDidChange.fire({\n      changedLanguages: languageIds,\n      changedColorMap: false\n    });\n  }\n  register(languageId, support) {\n    this._tokenizationSupports.set(languageId, support);\n    this.handleChange([languageId]);\n    return toDisposable(() =\u003e {\n      if (this._tokenizationSupports.get(languageId) !== support) {\n        return;\n      }\n      this._tokenizationSupports.delete(languageId);\n      this.handleChange([languageId]);\n    });\n  }\n  get(languageId) {\n    return this._tokenizationSupports.get(languageId) || null;\n  }\n  registerFactory(languageId, factory) {\n    this._factories.get(languageId)?.dispose();\n    const myData = new TokenizationSupportFactoryData(this, languageId, factory);\n    this._factories.set(languageId, myData);\n    return toDisposable(() =\u003e {\n      const v = this._factories.get(languageId);\n      if (!v || v !== myData) {\n        return;\n      }\n      this._factories.delete(languageId);\n      v.dispose();\n    });\n  }\n  async getOrCreate(languageId) {\n    const tokenizationSupport = this.get(languageId);\n    if (tokenizationSupport) {\n      return tokenizationSupport;\n    }\n    const factory = this._factories.get(languageId);\n    if (!factory || factory.isResolved) {\n      return null;\n    }\n    await factory.resolve();\n    return this.get(languageId);\n  }\n  isResolved(languageId) {\n    const tokenizationSupport = this.get(languageId);\n    if (tokenizationSupport) {\n      return true;\n    }\n    const factory = this._factories.get(languageId);\n    if (!factory || factory.isResolved) {\n      return true;\n    }\n    return false;\n  }\n  setColorMap(colorMap) {\n    this._colorMap = colorMap;\n    this._onDidChange.fire({\n      changedLanguages: Array.from(this._tokenizationSupports.keys()),\n      changedColorMap: true\n    });\n  }\n  getColorMap() {\n    return this._colorMap;\n  }\n  getDefaultBackground() {\n    if (this._colorMap \u0026\u0026 this._colorMap.length \u003e 2) {\n      return this._colorMap[\n        2\n        /* ColorId.DefaultBackground */\n      ];\n    }\n    return null;\n  }\n};\nvar TokenizationSupportFactoryData = class extends Disposable {\n  get isResolved() {\n    return this._isResolved;\n  }\n  constructor(_registry, _languageId, _factory) {\n    super();\n    this._registry = _registry;\n    this._languageId = _languageId;\n    this._factory = _factory;\n    this._isDisposed = false;\n    this._resolvePromise = null;\n    this._isResolved = false;\n  }\n  dispose() {\n    this._isDisposed = true;\n    super.dispose();\n  }\n  async resolve() {\n    if (!this._resolvePromise) {\n      this._resolvePromise = this._create();\n    }\n    return this._resolvePromise;\n  }\n  async _create() {\n    const value = await this._factory.tokenizationSupport;\n    this._isResolved = true;\n    if (value \u0026\u0026 !this._isDisposed) {\n      this._register(this._registry.register(this._languageId, value));\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js\nvar Token = class {\n  constructor(offset, type, language) {\n    this.offset = offset;\n    this.type = type;\n    this.language = language;\n    this._tokenBrand = void 0;\n  }\n  toString() {\n    return \"(\" + this.offset + \", \" + this.type + \")\";\n  }\n};\nvar HoverVerbosityAction;\n(function(HoverVerbosityAction3) {\n  HoverVerbosityAction3[HoverVerbosityAction3[\"Increase\"] = 0] = \"Increase\";\n  HoverVerbosityAction3[HoverVerbosityAction3[\"Decrease\"] = 1] = \"Decrease\";\n})(HoverVerbosityAction || (HoverVerbosityAction = {}));\nvar CompletionItemKinds;\n(function(CompletionItemKinds2) {\n  const byKind = /* @__PURE__ */ new Map();\n  byKind.set(0, Codicon.symbolMethod);\n  byKind.set(1, Codicon.symbolFunction);\n  byKind.set(2, Codicon.symbolConstructor);\n  byKind.set(3, Codicon.symbolField);\n  byKind.set(4, Codicon.symbolVariable);\n  byKind.set(5, Codicon.symbolClass);\n  byKind.set(6, Codicon.symbolStruct);\n  byKind.set(7, Codicon.symbolInterface);\n  byKind.set(8, Codicon.symbolModule);\n  byKind.set(9, Codicon.symbolProperty);\n  byKind.set(10, Codicon.symbolEvent);\n  byKind.set(11, Codicon.symbolOperator);\n  byKind.set(12, Codicon.symbolUnit);\n  byKind.set(13, Codicon.symbolValue);\n  byKind.set(15, Codicon.symbolEnum);\n  byKind.set(14, Codicon.symbolConstant);\n  byKind.set(15, Codicon.symbolEnum);\n  byKind.set(16, Codicon.symbolEnumMember);\n  byKind.set(17, Codicon.symbolKeyword);\n  byKind.set(27, Codicon.symbolSnippet);\n  byKind.set(18, Codicon.symbolText);\n  byKind.set(19, Codicon.symbolColor);\n  byKind.set(20, Codicon.symbolFile);\n  byKind.set(21, Codicon.symbolReference);\n  byKind.set(22, Codicon.symbolCustomColor);\n  byKind.set(23, Codicon.symbolFolder);\n  byKind.set(24, Codicon.symbolTypeParameter);\n  byKind.set(25, Codicon.account);\n  byKind.set(26, Codicon.issues);\n  function toIcon(kind) {\n    let codicon = byKind.get(kind);\n    if (!codicon) {\n      console.info(\"No codicon found for CompletionItemKind \" + kind);\n      codicon = Codicon.symbolProperty;\n    }\n    return codicon;\n  }\n  CompletionItemKinds2.toIcon = toIcon;\n  const data = /* @__PURE__ */ new Map();\n  data.set(\n    \"method\",\n    0\n    /* CompletionItemKind.Method */\n  );\n  data.set(\n    \"function\",\n    1\n    /* CompletionItemKind.Function */\n  );\n  data.set(\n    \"constructor\",\n    2\n    /* CompletionItemKind.Constructor */\n  );\n  data.set(\n    \"field\",\n    3\n    /* CompletionItemKind.Field */\n  );\n  data.set(\n    \"variable\",\n    4\n    /* CompletionItemKind.Variable */\n  );\n  data.set(\n    \"class\",\n    5\n    /* CompletionItemKind.Class */\n  );\n  data.set(\n    \"struct\",\n    6\n    /* CompletionItemKind.Struct */\n  );\n  data.set(\n    \"interface\",\n    7\n    /* CompletionItemKind.Interface */\n  );\n  data.set(\n    \"module\",\n    8\n    /* CompletionItemKind.Module */\n  );\n  data.set(\n    \"property\",\n    9\n    /* CompletionItemKind.Property */\n  );\n  data.set(\n    \"event\",\n    10\n    /* CompletionItemKind.Event */\n  );\n  data.set(\n    \"operator\",\n    11\n    /* CompletionItemKind.Operator */\n  );\n  data.set(\n    \"unit\",\n    12\n    /* CompletionItemKind.Unit */\n  );\n  data.set(\n    \"value\",\n    13\n    /* CompletionItemKind.Value */\n  );\n  data.set(\n    \"constant\",\n    14\n    /* CompletionItemKind.Constant */\n  );\n  data.set(\n    \"enum\",\n    15\n    /* CompletionItemKind.Enum */\n  );\n  data.set(\n    \"enum-member\",\n    16\n    /* CompletionItemKind.EnumMember */\n  );\n  data.set(\n    \"enumMember\",\n    16\n    /* CompletionItemKind.EnumMember */\n  );\n  data.set(\n    \"keyword\",\n    17\n    /* CompletionItemKind.Keyword */\n  );\n  data.set(\n    \"snippet\",\n    27\n    /* CompletionItemKind.Snippet */\n  );\n  data.set(\n    \"text\",\n    18\n    /* CompletionItemKind.Text */\n  );\n  data.set(\n    \"color\",\n    19\n    /* CompletionItemKind.Color */\n  );\n  data.set(\n    \"file\",\n    20\n    /* CompletionItemKind.File */\n  );\n  data.set(\n    \"reference\",\n    21\n    /* CompletionItemKind.Reference */\n  );\n  data.set(\n    \"customcolor\",\n    22\n    /* CompletionItemKind.Customcolor */\n  );\n  data.set(\n    \"folder\",\n    23\n    /* CompletionItemKind.Folder */\n  );\n  data.set(\n    \"type-parameter\",\n    24\n    /* CompletionItemKind.TypeParameter */\n  );\n  data.set(\n    \"typeParameter\",\n    24\n    /* CompletionItemKind.TypeParameter */\n  );\n  data.set(\n    \"account\",\n    25\n    /* CompletionItemKind.User */\n  );\n  data.set(\n    \"issue\",\n    26\n    /* CompletionItemKind.Issue */\n  );\n  function fromString(value, strict) {\n    let res = data.get(value);\n    if (typeof res === \"undefined\" \u0026\u0026 !strict) {\n      res = 9;\n    }\n    return res;\n  }\n  CompletionItemKinds2.fromString = fromString;\n})(CompletionItemKinds || (CompletionItemKinds = {}));\nvar InlineCompletionTriggerKind;\n(function(InlineCompletionTriggerKind3) {\n  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3[\"Automatic\"] = 0] = \"Automatic\";\n  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nvar DocumentPasteTriggerKind;\n(function(DocumentPasteTriggerKind2) {\n  DocumentPasteTriggerKind2[DocumentPasteTriggerKind2[\"Automatic\"] = 0] = \"Automatic\";\n  DocumentPasteTriggerKind2[DocumentPasteTriggerKind2[\"PasteAs\"] = 1] = \"PasteAs\";\n})(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));\nvar SignatureHelpTriggerKind;\n(function(SignatureHelpTriggerKind3) {\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"Invoke\"] = 1] = \"Invoke\";\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\nvar DocumentHighlightKind;\n(function(DocumentHighlightKind3) {\n  DocumentHighlightKind3[DocumentHighlightKind3[\"Text\"] = 0] = \"Text\";\n  DocumentHighlightKind3[DocumentHighlightKind3[\"Read\"] = 1] = \"Read\";\n  DocumentHighlightKind3[DocumentHighlightKind3[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\nvar symbolKindNames = {\n  [\n    17\n    /* SymbolKind.Array */\n  ]: localize(\"Array\", \"array\"),\n  [\n    16\n    /* SymbolKind.Boolean */\n  ]: localize(\"Boolean\", \"boolean\"),\n  [\n    4\n    /* SymbolKind.Class */\n  ]: localize(\"Class\", \"class\"),\n  [\n    13\n    /* SymbolKind.Constant */\n  ]: localize(\"Constant\", \"constant\"),\n  [\n    8\n    /* SymbolKind.Constructor */\n  ]: localize(\"Constructor\", \"constructor\"),\n  [\n    9\n    /* SymbolKind.Enum */\n  ]: localize(\"Enum\", \"enumeration\"),\n  [\n    21\n    /* SymbolKind.EnumMember */\n  ]: localize(\"EnumMember\", \"enumeration member\"),\n  [\n    23\n    /* SymbolKind.Event */\n  ]: localize(\"Event\", \"event\"),\n  [\n    7\n    /* SymbolKind.Field */\n  ]: localize(\"Field\", \"field\"),\n  [\n    0\n    /* SymbolKind.File */\n  ]: localize(\"File\", \"file\"),\n  [\n    11\n    /* SymbolKind.Function */\n  ]: localize(\"Function\", \"function\"),\n  [\n    10\n    /* SymbolKind.Interface */\n  ]: localize(\"Interface\", \"interface\"),\n  [\n    19\n    /* SymbolKind.Key */\n  ]: localize(\"Key\", \"key\"),\n  [\n    5\n    /* SymbolKind.Method */\n  ]: localize(\"Method\", \"method\"),\n  [\n    1\n    /* SymbolKind.Module */\n  ]: localize(\"Module\", \"module\"),\n  [\n    2\n    /* SymbolKind.Namespace */\n  ]: localize(\"Namespace\", \"namespace\"),\n  [\n    20\n    /* SymbolKind.Null */\n  ]: localize(\"Null\", \"null\"),\n  [\n    15\n    /* SymbolKind.Number */\n  ]: localize(\"Number\", \"number\"),\n  [\n    18\n    /* SymbolKind.Object */\n  ]: localize(\"Object\", \"object\"),\n  [\n    24\n    /* SymbolKind.Operator */\n  ]: localize(\"Operator\", \"operator\"),\n  [\n    3\n    /* SymbolKind.Package */\n  ]: localize(\"Package\", \"package\"),\n  [\n    6\n    /* SymbolKind.Property */\n  ]: localize(\"Property\", \"property\"),\n  [\n    14\n    /* SymbolKind.String */\n  ]: localize(\"String\", \"string\"),\n  [\n    22\n    /* SymbolKind.Struct */\n  ]: localize(\"Struct\", \"struct\"),\n  [\n    25\n    /* SymbolKind.TypeParameter */\n  ]: localize(\"TypeParameter\", \"type parameter\"),\n  [\n    12\n    /* SymbolKind.Variable */\n  ]: localize(\"Variable\", \"variable\")\n};\nvar SymbolKinds;\n(function(SymbolKinds2) {\n  const byKind = /* @__PURE__ */ new Map();\n  byKind.set(0, Codicon.symbolFile);\n  byKind.set(1, Codicon.symbolModule);\n  byKind.set(2, Codicon.symbolNamespace);\n  byKind.set(3, Codicon.symbolPackage);\n  byKind.set(4, Codicon.symbolClass);\n  byKind.set(5, Codicon.symbolMethod);\n  byKind.set(6, Codicon.symbolProperty);\n  byKind.set(7, Codicon.symbolField);\n  byKind.set(8, Codicon.symbolConstructor);\n  byKind.set(9, Codicon.symbolEnum);\n  byKind.set(10, Codicon.symbolInterface);\n  byKind.set(11, Codicon.symbolFunction);\n  byKind.set(12, Codicon.symbolVariable);\n  byKind.set(13, Codicon.symbolConstant);\n  byKind.set(14, Codicon.symbolString);\n  byKind.set(15, Codicon.symbolNumber);\n  byKind.set(16, Codicon.symbolBoolean);\n  byKind.set(17, Codicon.symbolArray);\n  byKind.set(18, Codicon.symbolObject);\n  byKind.set(19, Codicon.symbolKey);\n  byKind.set(20, Codicon.symbolNull);\n  byKind.set(21, Codicon.symbolEnumMember);\n  byKind.set(22, Codicon.symbolStruct);\n  byKind.set(23, Codicon.symbolEvent);\n  byKind.set(24, Codicon.symbolOperator);\n  byKind.set(25, Codicon.symbolTypeParameter);\n  function toIcon(kind) {\n    let icon = byKind.get(kind);\n    if (!icon) {\n      console.info(\"No codicon found for SymbolKind \" + kind);\n      icon = Codicon.symbolProperty;\n    }\n    return icon;\n  }\n  SymbolKinds2.toIcon = toIcon;\n})(SymbolKinds || (SymbolKinds = {}));\nvar FoldingRangeKind = class _FoldingRangeKind {\n  static {\n    this.Comment = new _FoldingRangeKind(\"comment\");\n  }\n  static {\n    this.Imports = new _FoldingRangeKind(\"imports\");\n  }\n  static {\n    this.Region = new _FoldingRangeKind(\"region\");\n  }\n  /**\n   * Returns a {@link FoldingRangeKind} for the given value.\n   *\n   * @param value of the kind.\n   */\n  static fromValue(value) {\n    switch (value) {\n      case \"comment\":\n        return _FoldingRangeKind.Comment;\n      case \"imports\":\n        return _FoldingRangeKind.Imports;\n      case \"region\":\n        return _FoldingRangeKind.Region;\n    }\n    return new _FoldingRangeKind(value);\n  }\n  /**\n   * Creates a new {@link FoldingRangeKind}.\n   *\n   * @param value of the kind.\n   */\n  constructor(value) {\n    this.value = value;\n  }\n};\nvar NewSymbolNameTag;\n(function(NewSymbolNameTag3) {\n  NewSymbolNameTag3[NewSymbolNameTag3[\"AIGenerated\"] = 1] = \"AIGenerated\";\n})(NewSymbolNameTag || (NewSymbolNameTag = {}));\nvar NewSymbolNameTriggerKind;\n(function(NewSymbolNameTriggerKind3) {\n  NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3[\"Invoke\"] = 0] = \"Invoke\";\n  NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3[\"Automatic\"] = 1] = \"Automatic\";\n})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));\nvar Command;\n(function(Command2) {\n  function is(obj) {\n    if (!obj || typeof obj !== \"object\") {\n      return false;\n    }\n    return typeof obj.id === \"string\" \u0026\u0026 typeof obj.title === \"string\";\n  }\n  Command2.is = is;\n})(Command || (Command = {}));\nvar InlayHintKind;\n(function(InlayHintKind3) {\n  InlayHintKind3[InlayHintKind3[\"Type\"] = 1] = \"Type\";\n  InlayHintKind3[InlayHintKind3[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\nvar TokenizationRegistry2 = new TokenizationRegistry();\nvar TreeSitterTokenizationRegistry = new TokenizationRegistry();\nvar InlineEditTriggerKind;\n(function(InlineEditTriggerKind3) {\n  InlineEditTriggerKind3[InlineEditTriggerKind3[\"Invoke\"] = 0] = \"Invoke\";\n  InlineEditTriggerKind3[InlineEditTriggerKind3[\"Automatic\"] = 1] = \"Automatic\";\n})(InlineEditTriggerKind || (InlineEditTriggerKind = {}));\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js\nvar AccessibilitySupport;\n(function(AccessibilitySupport2) {\n  AccessibilitySupport2[AccessibilitySupport2[\"Unknown\"] = 0] = \"Unknown\";\n  AccessibilitySupport2[AccessibilitySupport2[\"Disabled\"] = 1] = \"Disabled\";\n  AccessibilitySupport2[AccessibilitySupport2[\"Enabled\"] = 2] = \"Enabled\";\n})(AccessibilitySupport || (AccessibilitySupport = {}));\nvar CodeActionTriggerType;\n(function(CodeActionTriggerType2) {\n  CodeActionTriggerType2[CodeActionTriggerType2[\"Invoke\"] = 1] = \"Invoke\";\n  CodeActionTriggerType2[CodeActionTriggerType2[\"Auto\"] = 2] = \"Auto\";\n})(CodeActionTriggerType || (CodeActionTriggerType = {}));\nvar CompletionItemInsertTextRule;\n(function(CompletionItemInsertTextRule2) {\n  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2[\"None\"] = 0] = \"None\";\n  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2[\"KeepWhitespace\"] = 1] = \"KeepWhitespace\";\n  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2[\"InsertAsSnippet\"] = 4] = \"InsertAsSnippet\";\n})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));\nvar CompletionItemKind;\n(function(CompletionItemKind2) {\n  CompletionItemKind2[CompletionItemKind2[\"Method\"] = 0] = \"Method\";\n  CompletionItemKind2[CompletionItemKind2[\"Function\"] = 1] = \"Function\";\n  CompletionItemKind2[CompletionItemKind2[\"Constructor\"] = 2] = \"Constructor\";\n  CompletionItemKind2[CompletionItemKind2[\"Field\"] = 3] = \"Field\";\n  CompletionItemKind2[CompletionItemKind2[\"Variable\"] = 4] = \"Variable\";\n  CompletionItemKind2[CompletionItemKind2[\"Class\"] = 5] = \"Class\";\n  CompletionItemKind2[CompletionItemKind2[\"Struct\"] = 6] = \"Struct\";\n  CompletionItemKind2[CompletionItemKind2[\"Interface\"] = 7] = \"Interface\";\n  CompletionItemKind2[CompletionItemKind2[\"Module\"] = 8] = \"Module\";\n  CompletionItemKind2[CompletionItemKind2[\"Property\"] = 9] = \"Property\";\n  CompletionItemKind2[CompletionItemKind2[\"Event\"] = 10] = \"Event\";\n  CompletionItemKind2[CompletionItemKind2[\"Operator\"] = 11] = \"Operator\";\n  CompletionItemKind2[CompletionItemKind2[\"Unit\"] = 12] = \"Unit\";\n  CompletionItemKind2[CompletionItemKind2[\"Value\"] = 13] = \"Value\";\n  CompletionItemKind2[CompletionItemKind2[\"Constant\"] = 14] = \"Constant\";\n  CompletionItemKind2[CompletionItemKind2[\"Enum\"] = 15] = \"Enum\";\n  CompletionItemKind2[CompletionItemKind2[\"EnumMember\"] = 16] = \"EnumMember\";\n  CompletionItemKind2[CompletionItemKind2[\"Keyword\"] = 17] = \"Keyword\";\n  CompletionItemKind2[CompletionItemKind2[\"Text\"] = 18] = \"Text\";\n  CompletionItemKind2[CompletionItemKind2[\"Color\"] = 19] = \"Color\";\n  CompletionItemKind2[CompletionItemKind2[\"File\"] = 20] = \"File\";\n  CompletionItemKind2[CompletionItemKind2[\"Reference\"] = 21] = \"Reference\";\n  CompletionItemKind2[CompletionItemKind2[\"Customcolor\"] = 22] = \"Customcolor\";\n  CompletionItemKind2[CompletionItemKind2[\"Folder\"] = 23] = \"Folder\";\n  CompletionItemKind2[CompletionItemKind2[\"TypeParameter\"] = 24] = \"TypeParameter\";\n  CompletionItemKind2[CompletionItemKind2[\"User\"] = 25] = \"User\";\n  CompletionItemKind2[CompletionItemKind2[\"Issue\"] = 26] = \"Issue\";\n  CompletionItemKind2[CompletionItemKind2[\"Snippet\"] = 27] = \"Snippet\";\n})(CompletionItemKind || (CompletionItemKind = {}));\nvar CompletionItemTag;\n(function(CompletionItemTag2) {\n  CompletionItemTag2[CompletionItemTag2[\"Deprecated\"] = 1] = \"Deprecated\";\n})(CompletionItemTag || (CompletionItemTag = {}));\nvar CompletionTriggerKind;\n(function(CompletionTriggerKind2) {\n  CompletionTriggerKind2[CompletionTriggerKind2[\"Invoke\"] = 0] = \"Invoke\";\n  CompletionTriggerKind2[CompletionTriggerKind2[\"TriggerCharacter\"] = 1] = \"TriggerCharacter\";\n  CompletionTriggerKind2[CompletionTriggerKind2[\"TriggerForIncompleteCompletions\"] = 2] = \"TriggerForIncompleteCompletions\";\n})(CompletionTriggerKind || (CompletionTriggerKind = {}));\nvar ContentWidgetPositionPreference;\n(function(ContentWidgetPositionPreference2) {\n  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2[\"EXACT\"] = 0] = \"EXACT\";\n  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2[\"ABOVE\"] = 1] = \"ABOVE\";\n  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2[\"BELOW\"] = 2] = \"BELOW\";\n})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));\nvar CursorChangeReason;\n(function(CursorChangeReason2) {\n  CursorChangeReason2[CursorChangeReason2[\"NotSet\"] = 0] = \"NotSet\";\n  CursorChangeReason2[CursorChangeReason2[\"ContentFlush\"] = 1] = \"ContentFlush\";\n  CursorChangeReason2[CursorChangeReason2[\"RecoverFromMarkers\"] = 2] = \"RecoverFromMarkers\";\n  CursorChangeReason2[CursorChangeReason2[\"Explicit\"] = 3] = \"Explicit\";\n  CursorChangeReason2[CursorChangeReason2[\"Paste\"] = 4] = \"Paste\";\n  CursorChangeReason2[CursorChangeReason2[\"Undo\"] = 5] = \"Undo\";\n  CursorChangeReason2[CursorChangeReason2[\"Redo\"] = 6] = \"Redo\";\n})(CursorChangeReason || (CursorChangeReason = {}));\nvar DefaultEndOfLine;\n(function(DefaultEndOfLine2) {\n  DefaultEndOfLine2[DefaultEndOfLine2[\"LF\"] = 1] = \"LF\";\n  DefaultEndOfLine2[DefaultEndOfLine2[\"CRLF\"] = 2] = \"CRLF\";\n})(DefaultEndOfLine || (DefaultEndOfLine = {}));\nvar DocumentHighlightKind2;\n(function(DocumentHighlightKind3) {\n  DocumentHighlightKind3[DocumentHighlightKind3[\"Text\"] = 0] = \"Text\";\n  DocumentHighlightKind3[DocumentHighlightKind3[\"Read\"] = 1] = \"Read\";\n  DocumentHighlightKind3[DocumentHighlightKind3[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));\nvar EditorAutoIndentStrategy;\n(function(EditorAutoIndentStrategy2) {\n  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2[\"None\"] = 0] = \"None\";\n  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2[\"Keep\"] = 1] = \"Keep\";\n  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2[\"Brackets\"] = 2] = \"Brackets\";\n  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2[\"Advanced\"] = 3] = \"Advanced\";\n  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2[\"Full\"] = 4] = \"Full\";\n})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));\nvar EditorOption;\n(function(EditorOption2) {\n  EditorOption2[EditorOption2[\"acceptSuggestionOnCommitCharacter\"] = 0] = \"acceptSuggestionOnCommitCharacter\";\n  EditorOption2[EditorOption2[\"acceptSuggestionOnEnter\"] = 1] = \"acceptSuggestionOnEnter\";\n  EditorOption2[EditorOption2[\"accessibilitySupport\"] = 2] = \"accessibilitySupport\";\n  EditorOption2[EditorOption2[\"accessibilityPageSize\"] = 3] = \"accessibilityPageSize\";\n  EditorOption2[EditorOption2[\"ariaLabel\"] = 4] = \"ariaLabel\";\n  EditorOption2[EditorOption2[\"ariaRequired\"] = 5] = \"ariaRequired\";\n  EditorOption2[EditorOption2[\"autoClosingBrackets\"] = 6] = \"autoClosingBrackets\";\n  EditorOption2[EditorOption2[\"autoClosingComments\"] = 7] = \"autoClosingComments\";\n  EditorOption2[EditorOption2[\"screenReaderAnnounceInlineSuggestion\"] = 8] = \"screenReaderAnnounceInlineSuggestion\";\n  EditorOption2[EditorOption2[\"autoClosingDelete\"] = 9] = \"autoClosingDelete\";\n  EditorOption2[EditorOption2[\"autoClosingOvertype\"] = 10] = \"autoClosingOvertype\";\n  EditorOption2[EditorOption2[\"autoClosingQuotes\"] = 11] = \"autoClosingQuotes\";\n  EditorOption2[EditorOption2[\"autoIndent\"] = 12] = \"autoIndent\";\n  EditorOption2[EditorOption2[\"automaticLayout\"] = 13] = \"automaticLayout\";\n  EditorOption2[EditorOption2[\"autoSurround\"] = 14] = \"autoSurround\";\n  EditorOption2[EditorOption2[\"bracketPairColorization\"] = 15] = \"bracketPairColorization\";\n  EditorOption2[EditorOption2[\"guides\"] = 16] = \"guides\";\n  EditorOption2[EditorOption2[\"codeLens\"] = 17] = \"codeLens\";\n  EditorOption2[EditorOption2[\"codeLensFontFamily\"] = 18] = \"codeLensFontFamily\";\n  EditorOption2[EditorOption2[\"codeLensFontSize\"] = 19] = \"codeLensFontSize\";\n  EditorOption2[EditorOption2[\"colorDecorators\"] = 20] = \"colorDecorators\";\n  EditorOption2[EditorOption2[\"colorDecoratorsLimit\"] = 21] = \"colorDecoratorsLimit\";\n  EditorOption2[EditorOption2[\"columnSelection\"] = 22] = \"columnSelection\";\n  EditorOption2[EditorOption2[\"comments\"] = 23] = \"comments\";\n  EditorOption2[EditorOption2[\"contextmenu\"] = 24] = \"contextmenu\";\n  EditorOption2[EditorOption2[\"copyWithSyntaxHighlighting\"] = 25] = \"copyWithSyntaxHighlighting\";\n  EditorOption2[EditorOption2[\"cursorBlinking\"] = 26] = \"cursorBlinking\";\n  EditorOption2[EditorOption2[\"cursorSmoothCaretAnimation\"] = 27] = \"cursorSmoothCaretAnimation\";\n  EditorOption2[EditorOption2[\"cursorStyle\"] = 28] = \"cursorStyle\";\n  EditorOption2[EditorOption2[\"cursorSurroundingLines\"] = 29] = \"cursorSurroundingLines\";\n  EditorOption2[EditorOption2[\"cursorSurroundingLinesStyle\"] = 30] = \"cursorSurroundingLinesStyle\";\n  EditorOption2[EditorOption2[\"cursorWidth\"] = 31] = \"cursorWidth\";\n  EditorOption2[EditorOption2[\"disableLayerHinting\"] = 32] = \"disableLayerHinting\";\n  EditorOption2[EditorOption2[\"disableMonospaceOptimizations\"] = 33] = \"disableMonospaceOptimizations\";\n  EditorOption2[EditorOption2[\"domReadOnly\"] = 34] = \"domReadOnly\";\n  EditorOption2[EditorOption2[\"dragAndDrop\"] = 35] = \"dragAndDrop\";\n  EditorOption2[EditorOption2[\"dropIntoEditor\"] = 36] = \"dropIntoEditor\";\n  EditorOption2[EditorOption2[\"emptySelectionClipboard\"] = 37] = \"emptySelectionClipboard\";\n  EditorOption2[EditorOption2[\"experimentalWhitespaceRendering\"] = 38] = \"experimentalWhitespaceRendering\";\n  EditorOption2[EditorOption2[\"extraEditorClassName\"] = 39] = \"extraEditorClassName\";\n  EditorOption2[EditorOption2[\"fastScrollSensitivity\"] = 40] = \"fastScrollSensitivity\";\n  EditorOption2[EditorOption2[\"find\"] = 41] = \"find\";\n  EditorOption2[EditorOption2[\"fixedOverflowWidgets\"] = 42] = \"fixedOverflowWidgets\";\n  EditorOption2[EditorOption2[\"folding\"] = 43] = \"folding\";\n  EditorOption2[EditorOption2[\"foldingStrategy\"] = 44] = \"foldingStrategy\";\n  EditorOption2[EditorOption2[\"foldingHighlight\"] = 45] = \"foldingHighlight\";\n  EditorOption2[EditorOption2[\"foldingImportsByDefault\"] = 46] = \"foldingImportsByDefault\";\n  EditorOption2[EditorOption2[\"foldingMaximumRegions\"] = 47] = \"foldingMaximumRegions\";\n  EditorOption2[EditorOption2[\"unfoldOnClickAfterEndOfLine\"] = 48] = \"unfoldOnClickAfterEndOfLine\";\n  EditorOption2[EditorOption2[\"fontFamily\"] = 49] = \"fontFamily\";\n  EditorOption2[EditorOption2[\"fontInfo\"] = 50] = \"fontInfo\";\n  EditorOption2[EditorOption2[\"fontLigatures\"] = 51] = \"fontLigatures\";\n  EditorOption2[EditorOption2[\"fontSize\"] = 52] = \"fontSize\";\n  EditorOption2[EditorOption2[\"fontWeight\"] = 53] = \"fontWeight\";\n  EditorOption2[EditorOption2[\"fontVariations\"] = 54] = \"fontVariations\";\n  EditorOption2[EditorOption2[\"formatOnPaste\"] = 55] = \"formatOnPaste\";\n  EditorOption2[EditorOption2[\"formatOnType\"] = 56] = \"formatOnType\";\n  EditorOption2[EditorOption2[\"glyphMargin\"] = 57] = \"glyphMargin\";\n  EditorOption2[EditorOption2[\"gotoLocation\"] = 58] = \"gotoLocation\";\n  EditorOption2[EditorOption2[\"hideCursorInOverviewRuler\"] = 59] = \"hideCursorInOverviewRuler\";\n  EditorOption2[EditorOption2[\"hover\"] = 60] = \"hover\";\n  EditorOption2[EditorOption2[\"inDiffEditor\"] = 61] = \"inDiffEditor\";\n  EditorOption2[EditorOption2[\"inlineSuggest\"] = 62] = \"inlineSuggest\";\n  EditorOption2[EditorOption2[\"inlineEdit\"] = 63] = \"inlineEdit\";\n  EditorOption2[EditorOption2[\"letterSpacing\"] = 64] = \"letterSpacing\";\n  EditorOption2[EditorOption2[\"lightbulb\"] = 65] = \"lightbulb\";\n  EditorOption2[EditorOption2[\"lineDecorationsWidth\"] = 66] = \"lineDecorationsWidth\";\n  EditorOption2[EditorOption2[\"lineHeight\"] = 67] = \"lineHeight\";\n  EditorOption2[EditorOption2[\"lineNumbers\"] = 68] = \"lineNumbers\";\n  EditorOption2[EditorOption2[\"lineNumbersMinChars\"] = 69] = \"lineNumbersMinChars\";\n  EditorOption2[EditorOption2[\"linkedEditing\"] = 70] = \"linkedEditing\";\n  EditorOption2[EditorOption2[\"links\"] = 71] = \"links\";\n  EditorOption2[EditorOption2[\"matchBrackets\"] = 72] = \"matchBrackets\";\n  EditorOption2[EditorOption2[\"minimap\"] = 73] = \"minimap\";\n  EditorOption2[EditorOption2[\"mouseStyle\"] = 74] = \"mouseStyle\";\n  EditorOption2[EditorOption2[\"mouseWheelScrollSensitivity\"] = 75] = \"mouseWheelScrollSensitivity\";\n  EditorOption2[EditorOption2[\"mouseWheelZoom\"] = 76] = \"mouseWheelZoom\";\n  EditorOption2[EditorOption2[\"multiCursorMergeOverlapping\"] = 77] = \"multiCursorMergeOverlapping\";\n  EditorOption2[EditorOption2[\"multiCursorModifier\"] = 78] = \"multiCursorModifier\";\n  EditorOption2[EditorOption2[\"multiCursorPaste\"] = 79] = \"multiCursorPaste\";\n  EditorOption2[EditorOption2[\"multiCursorLimit\"] = 80] = \"multiCursorLimit\";\n  EditorOption2[EditorOption2[\"occurrencesHighlight\"] = 81] = \"occurrencesHighlight\";\n  EditorOption2[EditorOption2[\"overviewRulerBorder\"] = 82] = \"overviewRulerBorder\";\n  EditorOption2[EditorOption2[\"overviewRulerLanes\"] = 83] = \"overviewRulerLanes\";\n  EditorOption2[EditorOption2[\"padding\"] = 84] = \"padding\";\n  EditorOption2[EditorOption2[\"pasteAs\"] = 85] = \"pasteAs\";\n  EditorOption2[EditorOption2[\"parameterHints\"] = 86] = \"parameterHints\";\n  EditorOption2[EditorOption2[\"peekWidgetDefaultFocus\"] = 87] = \"peekWidgetDefaultFocus\";\n  EditorOption2[EditorOption2[\"placeholder\"] = 88] = \"placeholder\";\n  EditorOption2[EditorOption2[\"definitionLinkOpensInPeek\"] = 89] = \"definitionLinkOpensInPeek\";\n  EditorOption2[EditorOption2[\"quickSuggestions\"] = 90] = \"quickSuggestions\";\n  EditorOption2[EditorOption2[\"quickSuggestionsDelay\"] = 91] = \"quickSuggestionsDelay\";\n  EditorOption2[EditorOption2[\"readOnly\"] = 92] = \"readOnly\";\n  EditorOption2[EditorOption2[\"readOnlyMessage\"] = 93] = \"readOnlyMessage\";\n  EditorOption2[EditorOption2[\"renameOnType\"] = 94] = \"renameOnType\";\n  EditorOption2[EditorOption2[\"renderControlCharacters\"] = 95] = \"renderControlCharacters\";\n  EditorOption2[EditorOption2[\"renderFinalNewline\"] = 96] = \"renderFinalNewline\";\n  EditorOption2[EditorOption2[\"renderLineHighlight\"] = 97] = \"renderLineHighlight\";\n  EditorOption2[EditorOption2[\"renderLineHighlightOnlyWhenFocus\"] = 98] = \"renderLineHighlightOnlyWhenFocus\";\n  EditorOption2[EditorOption2[\"renderValidationDecorations\"] = 99] = \"renderValidationDecorations\";\n  EditorOption2[EditorOption2[\"renderWhitespace\"] = 100] = \"renderWhitespace\";\n  EditorOption2[EditorOption2[\"revealHorizontalRightPadding\"] = 101] = \"revealHorizontalRightPadding\";\n  EditorOption2[EditorOption2[\"roundedSelection\"] = 102] = \"roundedSelection\";\n  EditorOption2[EditorOption2[\"rulers\"] = 103] = \"rulers\";\n  EditorOption2[EditorOption2[\"scrollbar\"] = 104] = \"scrollbar\";\n  EditorOption2[EditorOption2[\"scrollBeyondLastColumn\"] = 105] = \"scrollBeyondLastColumn\";\n  EditorOption2[EditorOption2[\"scrollBeyondLastLine\"] = 106] = \"scrollBeyondLastLine\";\n  EditorOption2[EditorOption2[\"scrollPredominantAxis\"] = 107] = \"scrollPredominantAxis\";\n  EditorOption2[EditorOption2[\"selectionClipboard\"] = 108] = \"selectionClipboard\";\n  EditorOption2[EditorOption2[\"selectionHighlight\"] = 109] = \"selectionHighlight\";\n  EditorOption2[EditorOption2[\"selectOnLineNumbers\"] = 110] = \"selectOnLineNumbers\";\n  EditorOption2[EditorOption2[\"showFoldingControls\"] = 111] = \"showFoldingControls\";\n  EditorOption2[EditorOption2[\"showUnused\"] = 112] = \"showUnused\";\n  EditorOption2[EditorOption2[\"snippetSuggestions\"] = 113] = \"snippetSuggestions\";\n  EditorOption2[EditorOption2[\"smartSelect\"] = 114] = \"smartSelect\";\n  EditorOption2[EditorOption2[\"smoothScrolling\"] = 115] = \"smoothScrolling\";\n  EditorOption2[EditorOption2[\"stickyScroll\"] = 116] = \"stickyScroll\";\n  EditorOption2[EditorOption2[\"stickyTabStops\"] = 117] = \"stickyTabStops\";\n  EditorOption2[EditorOption2[\"stopRenderingLineAfter\"] = 118] = \"stopRenderingLineAfter\";\n  EditorOption2[EditorOption2[\"suggest\"] = 119] = \"suggest\";\n  EditorOption2[EditorOption2[\"suggestFontSize\"] = 120] = \"suggestFontSize\";\n  EditorOption2[EditorOption2[\"suggestLineHeight\"] = 121] = \"suggestLineHeight\";\n  EditorOption2[EditorOption2[\"suggestOnTriggerCharacters\"] = 122] = \"suggestOnTriggerCharacters\";\n  EditorOption2[EditorOption2[\"suggestSelection\"] = 123] = \"suggestSelection\";\n  EditorOption2[EditorOption2[\"tabCompletion\"] = 124] = \"tabCompletion\";\n  EditorOption2[EditorOption2[\"tabIndex\"] = 125] = \"tabIndex\";\n  EditorOption2[EditorOption2[\"unicodeHighlighting\"] = 126] = \"unicodeHighlighting\";\n  EditorOption2[EditorOption2[\"unusualLineTerminators\"] = 127] = \"unusualLineTerminators\";\n  EditorOption2[EditorOption2[\"useShadowDOM\"] = 128] = \"useShadowDOM\";\n  EditorOption2[EditorOption2[\"useTabStops\"] = 129] = \"useTabStops\";\n  EditorOption2[EditorOption2[\"wordBreak\"] = 130] = \"wordBreak\";\n  EditorOption2[EditorOption2[\"wordSegmenterLocales\"] = 131] = \"wordSegmenterLocales\";\n  EditorOption2[EditorOption2[\"wordSeparators\"] = 132] = \"wordSeparators\";\n  EditorOption2[EditorOption2[\"wordWrap\"] = 133] = \"wordWrap\";\n  EditorOption2[EditorOption2[\"wordWrapBreakAfterCharacters\"] = 134] = \"wordWrapBreakAfterCharacters\";\n  EditorOption2[EditorOption2[\"wordWrapBreakBeforeCharacters\"] = 135] = \"wordWrapBreakBeforeCharacters\";\n  EditorOption2[EditorOption2[\"wordWrapColumn\"] = 136] = \"wordWrapColumn\";\n  EditorOption2[EditorOption2[\"wordWrapOverride1\"] = 137] = \"wordWrapOverride1\";\n  EditorOption2[EditorOption2[\"wordWrapOverride2\"] = 138] = \"wordWrapOverride2\";\n  EditorOption2[EditorOption2[\"wrappingIndent\"] = 139] = \"wrappingIndent\";\n  EditorOption2[EditorOption2[\"wrappingStrategy\"] = 140] = \"wrappingStrategy\";\n  EditorOption2[EditorOption2[\"showDeprecated\"] = 141] = \"showDeprecated\";\n  EditorOption2[EditorOption2[\"inlayHints\"] = 142] = \"inlayHints\";\n  EditorOption2[EditorOption2[\"editorClassName\"] = 143] = \"editorClassName\";\n  EditorOption2[EditorOption2[\"pixelRatio\"] = 144] = \"pixelRatio\";\n  EditorOption2[EditorOption2[\"tabFocusMode\"] = 145] = \"tabFocusMode\";\n  EditorOption2[EditorOption2[\"layoutInfo\"] = 146] = \"layoutInfo\";\n  EditorOption2[EditorOption2[\"wrappingInfo\"] = 147] = \"wrappingInfo\";\n  EditorOption2[EditorOption2[\"defaultColorDecorators\"] = 148] = \"defaultColorDecorators\";\n  EditorOption2[EditorOption2[\"colorDecoratorsActivatedOn\"] = 149] = \"colorDecoratorsActivatedOn\";\n  EditorOption2[EditorOption2[\"inlineCompletionsAccessibilityVerbose\"] = 150] = \"inlineCompletionsAccessibilityVerbose\";\n})(EditorOption || (EditorOption = {}));\nvar EndOfLinePreference;\n(function(EndOfLinePreference2) {\n  EndOfLinePreference2[EndOfLinePreference2[\"TextDefined\"] = 0] = \"TextDefined\";\n  EndOfLinePreference2[EndOfLinePreference2[\"LF\"] = 1] = \"LF\";\n  EndOfLinePreference2[EndOfLinePreference2[\"CRLF\"] = 2] = \"CRLF\";\n})(EndOfLinePreference || (EndOfLinePreference = {}));\nvar EndOfLineSequence;\n(function(EndOfLineSequence2) {\n  EndOfLineSequence2[EndOfLineSequence2[\"LF\"] = 0] = \"LF\";\n  EndOfLineSequence2[EndOfLineSequence2[\"CRLF\"] = 1] = \"CRLF\";\n})(EndOfLineSequence || (EndOfLineSequence = {}));\nvar GlyphMarginLane;\n(function(GlyphMarginLane3) {\n  GlyphMarginLane3[GlyphMarginLane3[\"Left\"] = 1] = \"Left\";\n  GlyphMarginLane3[GlyphMarginLane3[\"Center\"] = 2] = \"Center\";\n  GlyphMarginLane3[GlyphMarginLane3[\"Right\"] = 3] = \"Right\";\n})(GlyphMarginLane || (GlyphMarginLane = {}));\nvar HoverVerbosityAction2;\n(function(HoverVerbosityAction3) {\n  HoverVerbosityAction3[HoverVerbosityAction3[\"Increase\"] = 0] = \"Increase\";\n  HoverVerbosityAction3[HoverVerbosityAction3[\"Decrease\"] = 1] = \"Decrease\";\n})(HoverVerbosityAction2 || (HoverVerbosityAction2 = {}));\nvar IndentAction;\n(function(IndentAction2) {\n  IndentAction2[IndentAction2[\"None\"] = 0] = \"None\";\n  IndentAction2[IndentAction2[\"Indent\"] = 1] = \"Indent\";\n  IndentAction2[IndentAction2[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n  IndentAction2[IndentAction2[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\nvar InjectedTextCursorStops;\n(function(InjectedTextCursorStops3) {\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Both\"] = 0] = \"Both\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Right\"] = 1] = \"Right\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Left\"] = 2] = \"Left\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nvar InlayHintKind2;\n(function(InlayHintKind3) {\n  InlayHintKind3[InlayHintKind3[\"Type\"] = 1] = \"Type\";\n  InlayHintKind3[InlayHintKind3[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind2 || (InlayHintKind2 = {}));\nvar InlineCompletionTriggerKind2;\n(function(InlineCompletionTriggerKind3) {\n  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3[\"Automatic\"] = 0] = \"Automatic\";\n  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));\nvar InlineEditTriggerKind2;\n(function(InlineEditTriggerKind3) {\n  InlineEditTriggerKind3[InlineEditTriggerKind3[\"Invoke\"] = 0] = \"Invoke\";\n  InlineEditTriggerKind3[InlineEditTriggerKind3[\"Automatic\"] = 1] = \"Automatic\";\n})(InlineEditTriggerKind2 || (InlineEditTriggerKind2 = {}));\nvar KeyCode;\n(function(KeyCode2) {\n  KeyCode2[KeyCode2[\"DependsOnKbLayout\"] = -1] = \"DependsOnKbLayout\";\n  KeyCode2[KeyCode2[\"Unknown\"] = 0] = \"Unknown\";\n  KeyCode2[KeyCode2[\"Backspace\"] = 1] = \"Backspace\";\n  KeyCode2[KeyCode2[\"Tab\"] = 2] = \"Tab\";\n  KeyCode2[KeyCode2[\"Enter\"] = 3] = \"Enter\";\n  KeyCode2[KeyCode2[\"Shift\"] = 4] = \"Shift\";\n  KeyCode2[KeyCode2[\"Ctrl\"] = 5] = \"Ctrl\";\n  KeyCode2[KeyCode2[\"Alt\"] = 6] = \"Alt\";\n  KeyCode2[KeyCode2[\"PauseBreak\"] = 7] = \"PauseBreak\";\n  KeyCode2[KeyCode2[\"CapsLock\"] = 8] = \"CapsLock\";\n  KeyCode2[KeyCode2[\"Escape\"] = 9] = \"Escape\";\n  KeyCode2[KeyCode2[\"Space\"] = 10] = \"Space\";\n  KeyCode2[KeyCode2[\"PageUp\"] = 11] = \"PageUp\";\n  KeyCode2[KeyCode2[\"PageDown\"] = 12] = \"PageDown\";\n  KeyCode2[KeyCode2[\"End\"] = 13] = \"End\";\n  KeyCode2[KeyCode2[\"Home\"] = 14] = \"Home\";\n  KeyCode2[KeyCode2[\"LeftArrow\"] = 15] = \"LeftArrow\";\n  KeyCode2[KeyCode2[\"UpArrow\"] = 16] = \"UpArrow\";\n  KeyCode2[KeyCode2[\"RightArrow\"] = 17] = \"RightArrow\";\n  KeyCode2[KeyCode2[\"DownArrow\"] = 18] = \"DownArrow\";\n  KeyCode2[KeyCode2[\"Insert\"] = 19] = \"Insert\";\n  KeyCode2[KeyCode2[\"Delete\"] = 20] = \"Delete\";\n  KeyCode2[KeyCode2[\"Digit0\"] = 21] = \"Digit0\";\n  KeyCode2[KeyCode2[\"Digit1\"] = 22] = \"Digit1\";\n  KeyCode2[KeyCode2[\"Digit2\"] = 23] = \"Digit2\";\n  KeyCode2[KeyCode2[\"Digit3\"] = 24] = \"Digit3\";\n  KeyCode2[KeyCode2[\"Digit4\"] = 25] = \"Digit4\";\n  KeyCode2[KeyCode2[\"Digit5\"] = 26] = \"Digit5\";\n  KeyCode2[KeyCode2[\"Digit6\"] = 27] = \"Digit6\";\n  KeyCode2[KeyCode2[\"Digit7\"] = 28] = \"Digit7\";\n  KeyCode2[KeyCode2[\"Digit8\"] = 29] = \"Digit8\";\n  KeyCode2[KeyCode2[\"Digit9\"] = 30] = \"Digit9\";\n  KeyCode2[KeyCode2[\"KeyA\"] = 31] = \"KeyA\";\n  KeyCode2[KeyCode2[\"KeyB\"] = 32] = \"KeyB\";\n  KeyCode2[KeyCode2[\"KeyC\"] = 33] = \"KeyC\";\n  KeyCode2[KeyCode2[\"KeyD\"] = 34] = \"KeyD\";\n  KeyCode2[KeyCode2[\"KeyE\"] = 35] = \"KeyE\";\n  KeyCode2[KeyCode2[\"KeyF\"] = 36] = \"KeyF\";\n  KeyCode2[KeyCode2[\"KeyG\"] = 37] = \"KeyG\";\n  KeyCode2[KeyCode2[\"KeyH\"] = 38] = \"KeyH\";\n  KeyCode2[KeyCode2[\"KeyI\"] = 39] = \"KeyI\";\n  KeyCode2[KeyCode2[\"KeyJ\"] = 40] = \"KeyJ\";\n  KeyCode2[KeyCode2[\"KeyK\"] = 41] = \"KeyK\";\n  KeyCode2[KeyCode2[\"KeyL\"] = 42] = \"KeyL\";\n  KeyCode2[KeyCode2[\"KeyM\"] = 43] = \"KeyM\";\n  KeyCode2[KeyCode2[\"KeyN\"] = 44] = \"KeyN\";\n  KeyCode2[KeyCode2[\"KeyO\"] = 45] = \"KeyO\";\n  KeyCode2[KeyCode2[\"KeyP\"] = 46] = \"KeyP\";\n  KeyCode2[KeyCode2[\"KeyQ\"] = 47] = \"KeyQ\";\n  KeyCode2[KeyCode2[\"KeyR\"] = 48] = \"KeyR\";\n  KeyCode2[KeyCode2[\"KeyS\"] = 49] = \"KeyS\";\n  KeyCode2[KeyCode2[\"KeyT\"] = 50] = \"KeyT\";\n  KeyCode2[KeyCode2[\"KeyU\"] = 51] = \"KeyU\";\n  KeyCode2[KeyCode2[\"KeyV\"] = 52] = \"KeyV\";\n  KeyCode2[KeyCode2[\"KeyW\"] = 53] = \"KeyW\";\n  KeyCode2[KeyCode2[\"KeyX\"] = 54] = \"KeyX\";\n  KeyCode2[KeyCode2[\"KeyY\"] = 55] = \"KeyY\";\n  KeyCode2[KeyCode2[\"KeyZ\"] = 56] = \"KeyZ\";\n  KeyCode2[KeyCode2[\"Meta\"] = 57] = \"Meta\";\n  KeyCode2[KeyCode2[\"ContextMenu\"] = 58] = \"ContextMenu\";\n  KeyCode2[KeyCode2[\"F1\"] = 59] = \"F1\";\n  KeyCode2[KeyCode2[\"F2\"] = 60] = \"F2\";\n  KeyCode2[KeyCode2[\"F3\"] = 61] = \"F3\";\n  KeyCode2[KeyCode2[\"F4\"] = 62] = \"F4\";\n  KeyCode2[KeyCode2[\"F5\"] = 63] = \"F5\";\n  KeyCode2[KeyCode2[\"F6\"] = 64] = \"F6\";\n  KeyCode2[KeyCode2[\"F7\"] = 65] = \"F7\";\n  KeyCode2[KeyCode2[\"F8\"] = 66] = \"F8\";\n  KeyCode2[KeyCode2[\"F9\"] = 67] = \"F9\";\n  KeyCode2[KeyCode2[\"F10\"] = 68] = \"F10\";\n  KeyCode2[KeyCode2[\"F11\"] = 69] = \"F11\";\n  KeyCode2[KeyCode2[\"F12\"] = 70] = \"F12\";\n  KeyCode2[KeyCode2[\"F13\"] = 71] = \"F13\";\n  KeyCode2[KeyCode2[\"F14\"] = 72] = \"F14\";\n  KeyCode2[KeyCode2[\"F15\"] = 73] = \"F15\";\n  KeyCode2[KeyCode2[\"F16\"] = 74] = \"F16\";\n  KeyCode2[KeyCode2[\"F17\"] = 75] = \"F17\";\n  KeyCode2[KeyCode2[\"F18\"] = 76] = \"F18\";\n  KeyCode2[KeyCode2[\"F19\"] = 77] = \"F19\";\n  KeyCode2[KeyCode2[\"F20\"] = 78] = \"F20\";\n  KeyCode2[KeyCode2[\"F21\"] = 79] = \"F21\";\n  KeyCode2[KeyCode2[\"F22\"] = 80] = \"F22\";\n  KeyCode2[KeyCode2[\"F23\"] = 81] = \"F23\";\n  KeyCode2[KeyCode2[\"F24\"] = 82] = \"F24\";\n  KeyCode2[KeyCode2[\"NumLock\"] = 83] = \"NumLock\";\n  KeyCode2[KeyCode2[\"ScrollLock\"] = 84] = \"ScrollLock\";\n  KeyCode2[KeyCode2[\"Semicolon\"] = 85] = \"Semicolon\";\n  KeyCode2[KeyCode2[\"Equal\"] = 86] = \"Equal\";\n  KeyCode2[KeyCode2[\"Comma\"] = 87] = \"Comma\";\n  KeyCode2[KeyCode2[\"Minus\"] = 88] = \"Minus\";\n  KeyCode2[KeyCode2[\"Period\"] = 89] = \"Period\";\n  KeyCode2[KeyCode2[\"Slash\"] = 90] = \"Slash\";\n  KeyCode2[KeyCode2[\"Backquote\"] = 91] = \"Backquote\";\n  KeyCode2[KeyCode2[\"BracketLeft\"] = 92] = \"BracketLeft\";\n  KeyCode2[KeyCode2[\"Backslash\"] = 93] = \"Backslash\";\n  KeyCode2[KeyCode2[\"BracketRight\"] = 94] = \"BracketRight\";\n  KeyCode2[KeyCode2[\"Quote\"] = 95] = \"Quote\";\n  KeyCode2[KeyCode2[\"OEM_8\"] = 96] = \"OEM_8\";\n  KeyCode2[KeyCode2[\"IntlBackslash\"] = 97] = \"IntlBackslash\";\n  KeyCode2[KeyCode2[\"Numpad0\"] = 98] = \"Numpad0\";\n  KeyCode2[KeyCode2[\"Numpad1\"] = 99] = \"Numpad1\";\n  KeyCode2[KeyCode2[\"Numpad2\"] = 100] = \"Numpad2\";\n  KeyCode2[KeyCode2[\"Numpad3\"] = 101] = \"Numpad3\";\n  KeyCode2[KeyCode2[\"Numpad4\"] = 102] = \"Numpad4\";\n  KeyCode2[KeyCode2[\"Numpad5\"] = 103] = \"Numpad5\";\n  KeyCode2[KeyCode2[\"Numpad6\"] = 104] = \"Numpad6\";\n  KeyCode2[KeyCode2[\"Numpad7\"] = 105] = \"Numpad7\";\n  KeyCode2[KeyCode2[\"Numpad8\"] = 106] = \"Numpad8\";\n  KeyCode2[KeyCode2[\"Numpad9\"] = 107] = \"Numpad9\";\n  KeyCode2[KeyCode2[\"NumpadMultiply\"] = 108] = \"NumpadMultiply\";\n  KeyCode2[KeyCode2[\"NumpadAdd\"] = 109] = \"NumpadAdd\";\n  KeyCode2[KeyCode2[\"NUMPAD_SEPARATOR\"] = 110] = \"NUMPAD_SEPARATOR\";\n  KeyCode2[KeyCode2[\"NumpadSubtract\"] = 111] = \"NumpadSubtract\";\n  KeyCode2[KeyCode2[\"NumpadDecimal\"] = 112] = \"NumpadDecimal\";\n  KeyCode2[KeyCode2[\"NumpadDivide\"] = 113] = \"NumpadDivide\";\n  KeyCode2[KeyCode2[\"KEY_IN_COMPOSITION\"] = 114] = \"KEY_IN_COMPOSITION\";\n  KeyCode2[KeyCode2[\"ABNT_C1\"] = 115] = \"ABNT_C1\";\n  KeyCode2[KeyCode2[\"ABNT_C2\"] = 116] = \"ABNT_C2\";\n  KeyCode2[KeyCode2[\"AudioVolumeMute\"] = 117] = \"AudioVolumeMute\";\n  KeyCode2[KeyCode2[\"AudioVolumeUp\"] = 118] = \"AudioVolumeUp\";\n  KeyCode2[KeyCode2[\"AudioVolumeDown\"] = 119] = \"AudioVolumeDown\";\n  KeyCode2[KeyCode2[\"BrowserSearch\"] = 120] = \"BrowserSearch\";\n  KeyCode2[KeyCode2[\"BrowserHome\"] = 121] = \"BrowserHome\";\n  KeyCode2[KeyCode2[\"BrowserBack\"] = 122] = \"BrowserBack\";\n  KeyCode2[KeyCode2[\"BrowserForward\"] = 123] = \"BrowserForward\";\n  KeyCode2[KeyCode2[\"MediaTrackNext\"] = 124] = \"MediaTrackNext\";\n  KeyCode2[KeyCode2[\"MediaTrackPrevious\"] = 125] = \"MediaTrackPrevious\";\n  KeyCode2[KeyCode2[\"MediaStop\"] = 126] = \"MediaStop\";\n  KeyCode2[KeyCode2[\"MediaPlayPause\"] = 127] = \"MediaPlayPause\";\n  KeyCode2[KeyCode2[\"LaunchMediaPlayer\"] = 128] = \"LaunchMediaPlayer\";\n  KeyCode2[KeyCode2[\"LaunchMail\"] = 129] = \"LaunchMail\";\n  KeyCode2[KeyCode2[\"LaunchApp2\"] = 130] = \"LaunchApp2\";\n  KeyCode2[KeyCode2[\"Clear\"] = 131] = \"Clear\";\n  KeyCode2[KeyCode2[\"MAX_VALUE\"] = 132] = \"MAX_VALUE\";\n})(KeyCode || (KeyCode = {}));\nvar MarkerSeverity;\n(function(MarkerSeverity2) {\n  MarkerSeverity2[MarkerSeverity2[\"Hint\"] = 1] = \"Hint\";\n  MarkerSeverity2[MarkerSeverity2[\"Info\"] = 2] = \"Info\";\n  MarkerSeverity2[MarkerSeverity2[\"Warning\"] = 4] = \"Warning\";\n  MarkerSeverity2[MarkerSeverity2[\"Error\"] = 8] = \"Error\";\n})(MarkerSeverity || (MarkerSeverity = {}));\nvar MarkerTag;\n(function(MarkerTag2) {\n  MarkerTag2[MarkerTag2[\"Unnecessary\"] = 1] = \"Unnecessary\";\n  MarkerTag2[MarkerTag2[\"Deprecated\"] = 2] = \"Deprecated\";\n})(MarkerTag || (MarkerTag = {}));\nvar MinimapPosition;\n(function(MinimapPosition2) {\n  MinimapPosition2[MinimapPosition2[\"Inline\"] = 1] = \"Inline\";\n  MinimapPosition2[MinimapPosition2[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {}));\nvar MinimapSectionHeaderStyle;\n(function(MinimapSectionHeaderStyle2) {\n  MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2[\"Normal\"] = 1] = \"Normal\";\n  MinimapSectionHeaderStyle2[MinimapSectionHeaderStyle2[\"Underlined\"] = 2] = \"Underlined\";\n})(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {}));\nvar MouseTargetType;\n(function(MouseTargetType2) {\n  MouseTargetType2[MouseTargetType2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  MouseTargetType2[MouseTargetType2[\"TEXTAREA\"] = 1] = \"TEXTAREA\";\n  MouseTargetType2[MouseTargetType2[\"GUTTER_GLYPH_MARGIN\"] = 2] = \"GUTTER_GLYPH_MARGIN\";\n  MouseTargetType2[MouseTargetType2[\"GUTTER_LINE_NUMBERS\"] = 3] = \"GUTTER_LINE_NUMBERS\";\n  MouseTargetType2[MouseTargetType2[\"GUTTER_LINE_DECORATIONS\"] = 4] = \"GUTTER_LINE_DECORATIONS\";\n  MouseTargetType2[MouseTargetType2[\"GUTTER_VIEW_ZONE\"] = 5] = \"GUTTER_VIEW_ZONE\";\n  MouseTargetType2[MouseTargetType2[\"CONTENT_TEXT\"] = 6] = \"CONTENT_TEXT\";\n  MouseTargetType2[MouseTargetType2[\"CONTENT_EMPTY\"] = 7] = \"CONTENT_EMPTY\";\n  MouseTargetType2[MouseTargetType2[\"CONTENT_VIEW_ZONE\"] = 8] = \"CONTENT_VIEW_ZONE\";\n  MouseTargetType2[MouseTargetType2[\"CONTENT_WIDGET\"] = 9] = \"CONTENT_WIDGET\";\n  MouseTargetType2[MouseTargetType2[\"OVERVIEW_RULER\"] = 10] = \"OVERVIEW_RULER\";\n  MouseTargetType2[MouseTargetType2[\"SCROLLBAR\"] = 11] = \"SCROLLBAR\";\n  MouseTargetType2[MouseTargetType2[\"OVERLAY_WIDGET\"] = 12] = \"OVERLAY_WIDGET\";\n  MouseTargetType2[MouseTargetType2[\"OUTSIDE_EDITOR\"] = 13] = \"OUTSIDE_EDITOR\";\n})(MouseTargetType || (MouseTargetType = {}));\nvar NewSymbolNameTag2;\n(function(NewSymbolNameTag3) {\n  NewSymbolNameTag3[NewSymbolNameTag3[\"AIGenerated\"] = 1] = \"AIGenerated\";\n})(NewSymbolNameTag2 || (NewSymbolNameTag2 = {}));\nvar NewSymbolNameTriggerKind2;\n(function(NewSymbolNameTriggerKind3) {\n  NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3[\"Invoke\"] = 0] = \"Invoke\";\n  NewSymbolNameTriggerKind3[NewSymbolNameTriggerKind3[\"Automatic\"] = 1] = \"Automatic\";\n})(NewSymbolNameTriggerKind2 || (NewSymbolNameTriggerKind2 = {}));\nvar OverlayWidgetPositionPreference;\n(function(OverlayWidgetPositionPreference2) {\n  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2[\"TOP_RIGHT_CORNER\"] = 0] = \"TOP_RIGHT_CORNER\";\n  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2[\"BOTTOM_RIGHT_CORNER\"] = 1] = \"BOTTOM_RIGHT_CORNER\";\n  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2[\"TOP_CENTER\"] = 2] = \"TOP_CENTER\";\n})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));\nvar OverviewRulerLane;\n(function(OverviewRulerLane3) {\n  OverviewRulerLane3[OverviewRulerLane3[\"Left\"] = 1] = \"Left\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Center\"] = 2] = \"Center\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Right\"] = 4] = \"Right\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\nvar PartialAcceptTriggerKind;\n(function(PartialAcceptTriggerKind2) {\n  PartialAcceptTriggerKind2[PartialAcceptTriggerKind2[\"Word\"] = 0] = \"Word\";\n  PartialAcceptTriggerKind2[PartialAcceptTriggerKind2[\"Line\"] = 1] = \"Line\";\n  PartialAcceptTriggerKind2[PartialAcceptTriggerKind2[\"Suggest\"] = 2] = \"Suggest\";\n})(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));\nvar PositionAffinity;\n(function(PositionAffinity2) {\n  PositionAffinity2[PositionAffinity2[\"Left\"] = 0] = \"Left\";\n  PositionAffinity2[PositionAffinity2[\"Right\"] = 1] = \"Right\";\n  PositionAffinity2[PositionAffinity2[\"None\"] = 2] = \"None\";\n  PositionAffinity2[PositionAffinity2[\"LeftOfInjectedText\"] = 3] = \"LeftOfInjectedText\";\n  PositionAffinity2[PositionAffinity2[\"RightOfInjectedText\"] = 4] = \"RightOfInjectedText\";\n})(PositionAffinity || (PositionAffinity = {}));\nvar RenderLineNumbersType;\n(function(RenderLineNumbersType2) {\n  RenderLineNumbersType2[RenderLineNumbersType2[\"Off\"] = 0] = \"Off\";\n  RenderLineNumbersType2[RenderLineNumbersType2[\"On\"] = 1] = \"On\";\n  RenderLineNumbersType2[RenderLineNumbersType2[\"Relative\"] = 2] = \"Relative\";\n  RenderLineNumbersType2[RenderLineNumbersType2[\"Interval\"] = 3] = \"Interval\";\n  RenderLineNumbersType2[RenderLineNumbersType2[\"Custom\"] = 4] = \"Custom\";\n})(RenderLineNumbersType || (RenderLineNumbersType = {}));\nvar RenderMinimap;\n(function(RenderMinimap2) {\n  RenderMinimap2[RenderMinimap2[\"None\"] = 0] = \"None\";\n  RenderMinimap2[RenderMinimap2[\"Text\"] = 1] = \"Text\";\n  RenderMinimap2[RenderMinimap2[\"Blocks\"] = 2] = \"Blocks\";\n})(RenderMinimap || (RenderMinimap = {}));\nvar ScrollType;\n(function(ScrollType2) {\n  ScrollType2[ScrollType2[\"Smooth\"] = 0] = \"Smooth\";\n  ScrollType2[ScrollType2[\"Immediate\"] = 1] = \"Immediate\";\n})(ScrollType || (ScrollType = {}));\nvar ScrollbarVisibility;\n(function(ScrollbarVisibility2) {\n  ScrollbarVisibility2[ScrollbarVisibility2[\"Auto\"] = 1] = \"Auto\";\n  ScrollbarVisibility2[ScrollbarVisibility2[\"Hidden\"] = 2] = \"Hidden\";\n  ScrollbarVisibility2[ScrollbarVisibility2[\"Visible\"] = 3] = \"Visible\";\n})(ScrollbarVisibility || (ScrollbarVisibility = {}));\nvar SelectionDirection;\n(function(SelectionDirection2) {\n  SelectionDirection2[SelectionDirection2[\"LTR\"] = 0] = \"LTR\";\n  SelectionDirection2[SelectionDirection2[\"RTL\"] = 1] = \"RTL\";\n})(SelectionDirection || (SelectionDirection = {}));\nvar ShowLightbulbIconMode;\n(function(ShowLightbulbIconMode2) {\n  ShowLightbulbIconMode2[\"Off\"] = \"off\";\n  ShowLightbulbIconMode2[\"OnCode\"] = \"onCode\";\n  ShowLightbulbIconMode2[\"On\"] = \"on\";\n})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));\nvar SignatureHelpTriggerKind2;\n(function(SignatureHelpTriggerKind3) {\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"Invoke\"] = 1] = \"Invoke\";\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));\nvar SymbolKind;\n(function(SymbolKind2) {\n  SymbolKind2[SymbolKind2[\"File\"] = 0] = \"File\";\n  SymbolKind2[SymbolKind2[\"Module\"] = 1] = \"Module\";\n  SymbolKind2[SymbolKind2[\"Namespace\"] = 2] = \"Namespace\";\n  SymbolKind2[SymbolKind2[\"Package\"] = 3] = \"Package\";\n  SymbolKind2[SymbolKind2[\"Class\"] = 4] = \"Class\";\n  SymbolKind2[SymbolKind2[\"Method\"] = 5] = \"Method\";\n  SymbolKind2[SymbolKind2[\"Property\"] = 6] = \"Property\";\n  SymbolKind2[SymbolKind2[\"Field\"] = 7] = \"Field\";\n  SymbolKind2[SymbolKind2[\"Constructor\"] = 8] = \"Constructor\";\n  SymbolKind2[SymbolKind2[\"Enum\"] = 9] = \"Enum\";\n  SymbolKind2[SymbolKind2[\"Interface\"] = 10] = \"Interface\";\n  SymbolKind2[SymbolKind2[\"Function\"] = 11] = \"Function\";\n  SymbolKind2[SymbolKind2[\"Variable\"] = 12] = \"Variable\";\n  SymbolKind2[SymbolKind2[\"Constant\"] = 13] = \"Constant\";\n  SymbolKind2[SymbolKind2[\"String\"] = 14] = \"String\";\n  SymbolKind2[SymbolKind2[\"Number\"] = 15] = \"Number\";\n  SymbolKind2[SymbolKind2[\"Boolean\"] = 16] = \"Boolean\";\n  SymbolKind2[SymbolKind2[\"Array\"] = 17] = \"Array\";\n  SymbolKind2[SymbolKind2[\"Object\"] = 18] = \"Object\";\n  SymbolKind2[SymbolKind2[\"Key\"] = 19] = \"Key\";\n  SymbolKind2[SymbolKind2[\"Null\"] = 20] = \"Null\";\n  SymbolKind2[SymbolKind2[\"EnumMember\"] = 21] = \"EnumMember\";\n  SymbolKind2[SymbolKind2[\"Struct\"] = 22] = \"Struct\";\n  SymbolKind2[SymbolKind2[\"Event\"] = 23] = \"Event\";\n  SymbolKind2[SymbolKind2[\"Operator\"] = 24] = \"Operator\";\n  SymbolKind2[SymbolKind2[\"TypeParameter\"] = 25] = \"TypeParameter\";\n})(SymbolKind || (SymbolKind = {}));\nvar SymbolTag;\n(function(SymbolTag2) {\n  SymbolTag2[SymbolTag2[\"Deprecated\"] = 1] = \"Deprecated\";\n})(SymbolTag || (SymbolTag = {}));\nvar TextEditorCursorBlinkingStyle;\n(function(TextEditorCursorBlinkingStyle2) {\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Hidden\"] = 0] = \"Hidden\";\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Blink\"] = 1] = \"Blink\";\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Smooth\"] = 2] = \"Smooth\";\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Phase\"] = 3] = \"Phase\";\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Expand\"] = 4] = \"Expand\";\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Solid\"] = 5] = \"Solid\";\n})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));\nvar TextEditorCursorStyle;\n(function(TextEditorCursorStyle2) {\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"Line\"] = 1] = \"Line\";\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"Block\"] = 2] = \"Block\";\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"Underline\"] = 3] = \"Underline\";\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"LineThin\"] = 4] = \"LineThin\";\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"BlockOutline\"] = 5] = \"BlockOutline\";\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));\nvar TrackedRangeStickiness;\n(function(TrackedRangeStickiness2) {\n  TrackedRangeStickiness2[TrackedRangeStickiness2[\"AlwaysGrowsWhenTypingAtEdges\"] = 0] = \"AlwaysGrowsWhenTypingAtEdges\";\n  TrackedRangeStickiness2[TrackedRangeStickiness2[\"NeverGrowsWhenTypingAtEdges\"] = 1] = \"NeverGrowsWhenTypingAtEdges\";\n  TrackedRangeStickiness2[TrackedRangeStickiness2[\"GrowsOnlyWhenTypingBefore\"] = 2] = \"GrowsOnlyWhenTypingBefore\";\n  TrackedRangeStickiness2[TrackedRangeStickiness2[\"GrowsOnlyWhenTypingAfter\"] = 3] = \"GrowsOnlyWhenTypingAfter\";\n})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));\nvar WrappingIndent;\n(function(WrappingIndent2) {\n  WrappingIndent2[WrappingIndent2[\"None\"] = 0] = \"None\";\n  WrappingIndent2[WrappingIndent2[\"Same\"] = 1] = \"Same\";\n  WrappingIndent2[WrappingIndent2[\"Indent\"] = 2] = \"Indent\";\n  WrappingIndent2[WrappingIndent2[\"DeepIndent\"] = 3] = \"DeepIndent\";\n})(WrappingIndent || (WrappingIndent = {}));\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js\nvar KeyMod = class {\n  static {\n    this.CtrlCmd = 2048;\n  }\n  static {\n    this.Shift = 1024;\n  }\n  static {\n    this.Alt = 512;\n  }\n  static {\n    this.WinCtrl = 256;\n  }\n  static chord(firstPart, secondPart) {\n    return KeyChord(firstPart, secondPart);\n  }\n};\nfunction createMonacoBaseAPI() {\n  return {\n    editor: void 0,\n    // undefined override expected here\n    languages: void 0,\n    // undefined override expected here\n    CancellationTokenSource,\n    Emitter,\n    KeyCode,\n    KeyMod,\n    Position,\n    Range,\n    Selection,\n    SelectionDirection,\n    MarkerSeverity,\n    MarkerTag,\n    Uri: URI,\n    Token\n  };\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js\nvar EditorWorkerHost = class _EditorWorkerHost {\n  static {\n    this.CHANNEL_NAME = \"editorWorkerHost\";\n  }\n  static getChannel(workerServer) {\n    return workerServer.getChannel(_EditorWorkerHost.CHANNEL_NAME);\n  }\n  static setChannel(workerClient, obj) {\n    workerClient.setChannel(_EditorWorkerHost.CHANNEL_NAME, obj);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/map.js\nvar _a;\nvar _b;\nvar ResourceMapEntry = class {\n  constructor(uri, value) {\n    this.uri = uri;\n    this.value = value;\n  }\n};\nfunction isEntries(arg) {\n  return Array.isArray(arg);\n}\nvar ResourceMap = class _ResourceMap {\n  static {\n    this.defaultToKey = (resource) =\u003e resource.toString();\n  }\n  constructor(arg, toKey) {\n    this[_a] = \"ResourceMap\";\n    if (arg instanceof _ResourceMap) {\n      this.map = new Map(arg.map);\n      this.toKey = toKey ?? _ResourceMap.defaultToKey;\n    } else if (isEntries(arg)) {\n      this.map = /* @__PURE__ */ new Map();\n      this.toKey = toKey ?? _ResourceMap.defaultToKey;\n      for (const [resource, value] of arg) {\n        this.set(resource, value);\n      }\n    } else {\n      this.map = /* @__PURE__ */ new Map();\n      this.toKey = arg ?? _ResourceMap.defaultToKey;\n    }\n  }\n  set(resource, value) {\n    this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n    return this;\n  }\n  get(resource) {\n    return this.map.get(this.toKey(resource))?.value;\n  }\n  has(resource) {\n    return this.map.has(this.toKey(resource));\n  }\n  get size() {\n    return this.map.size;\n  }\n  clear() {\n    this.map.clear();\n  }\n  delete(resource) {\n    return this.map.delete(this.toKey(resource));\n  }\n  forEach(clb, thisArg) {\n    if (typeof thisArg !== \"undefined\") {\n      clb = clb.bind(thisArg);\n    }\n    for (const [_, entry] of this.map) {\n      clb(entry.value, entry.uri, this);\n    }\n  }\n  *values() {\n    for (const entry of this.map.values()) {\n      yield entry.value;\n    }\n  }\n  *keys() {\n    for (const entry of this.map.values()) {\n      yield entry.uri;\n    }\n  }\n  *entries() {\n    for (const entry of this.map.values()) {\n      yield [entry.uri, entry.value];\n    }\n  }\n  *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\n    for (const [, entry] of this.map) {\n      yield [entry.uri, entry.value];\n    }\n  }\n};\nvar LinkedMap = class {\n  constructor() {\n    this[_b] = \"LinkedMap\";\n    this._map = /* @__PURE__ */ new Map();\n    this._head = void 0;\n    this._tail = void 0;\n    this._size = 0;\n    this._state = 0;\n  }\n  clear() {\n    this._map.clear();\n    this._head = void 0;\n    this._tail = void 0;\n    this._size = 0;\n    this._state++;\n  }\n  isEmpty() {\n    return !this._head \u0026\u0026 !this._tail;\n  }\n  get size() {\n    return this._size;\n  }\n  get first() {\n    return this._head?.value;\n  }\n  get last() {\n    return this._tail?.value;\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  get(key, touch = 0) {\n    const item = this._map.get(key);\n    if (!item) {\n      return void 0;\n    }\n    if (touch !== 0) {\n      this.touch(item, touch);\n    }\n    return item.value;\n  }\n  set(key, value, touch = 0) {\n    let item = this._map.get(key);\n    if (item) {\n      item.value = value;\n      if (touch !== 0) {\n        this.touch(item, touch);\n      }\n    } else {\n      item = { key, value, next: void 0, previous: void 0 };\n      switch (touch) {\n        case 0:\n          this.addItemLast(item);\n          break;\n        case 1:\n          this.addItemFirst(item);\n          break;\n        case 2:\n          this.addItemLast(item);\n          break;\n        default:\n          this.addItemLast(item);\n          break;\n      }\n      this._map.set(key, item);\n      this._size++;\n    }\n    return this;\n  }\n  delete(key) {\n    return !!this.remove(key);\n  }\n  remove(key) {\n    const item = this._map.get(key);\n    if (!item) {\n      return void 0;\n    }\n    this._map.delete(key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  shift() {\n    if (!this._head \u0026\u0026 !this._tail) {\n      return void 0;\n    }\n    if (!this._head || !this._tail) {\n      throw new Error(\"Invalid list\");\n    }\n    const item = this._head;\n    this._map.delete(item.key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  forEach(callbackfn, thisArg) {\n    const state = this._state;\n    let current = this._head;\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n      if (this._state !== state) {\n        throw new Error(`LinkedMap got modified during iteration.`);\n      }\n      current = current.next;\n    }\n  }\n  keys() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = { value: current.key, done: false };\n          current = current.next;\n          return result;\n        } else {\n          return { value: void 0, done: true };\n        }\n      }\n    };\n    return iterator;\n  }\n  values() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = { value: current.value, done: false };\n          current = current.next;\n          return result;\n        } else {\n          return { value: void 0, done: true };\n        }\n      }\n    };\n    return iterator;\n  }\n  entries() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = { value: [current.key, current.value], done: false };\n          current = current.next;\n          return result;\n        } else {\n          return { value: void 0, done: true };\n        }\n      }\n    };\n    return iterator;\n  }\n  [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.entries();\n  }\n  trimOld(newSize) {\n    if (newSize \u003e= this.size) {\n      return;\n    }\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n    let current = this._head;\n    let currentSize = this.size;\n    while (current \u0026\u0026 currentSize \u003e newSize) {\n      this._map.delete(current.key);\n      current = current.next;\n      currentSize--;\n    }\n    this._head = current;\n    this._size = currentSize;\n    if (current) {\n      current.previous = void 0;\n    }\n    this._state++;\n  }\n  trimNew(newSize) {\n    if (newSize \u003e= this.size) {\n      return;\n    }\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n    let current = this._tail;\n    let currentSize = this.size;\n    while (current \u0026\u0026 currentSize \u003e newSize) {\n      this._map.delete(current.key);\n      current = current.previous;\n      currentSize--;\n    }\n    this._tail = current;\n    this._size = currentSize;\n    if (current) {\n      current.next = void 0;\n    }\n    this._state++;\n  }\n  addItemFirst(item) {\n    if (!this._head \u0026\u0026 !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error(\"Invalid list\");\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n    this._head = item;\n    this._state++;\n  }\n  addItemLast(item) {\n    if (!this._head \u0026\u0026 !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error(\"Invalid list\");\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n    this._tail = item;\n    this._state++;\n  }\n  removeItem(item) {\n    if (item === this._head \u0026\u0026 item === this._tail) {\n      this._head = void 0;\n      this._tail = void 0;\n    } else if (item === this._head) {\n      if (!item.next) {\n        throw new Error(\"Invalid list\");\n      }\n      item.next.previous = void 0;\n      this._head = item.next;\n    } else if (item === this._tail) {\n      if (!item.previous) {\n        throw new Error(\"Invalid list\");\n      }\n      item.previous.next = void 0;\n      this._tail = item.previous;\n    } else {\n      const next = item.next;\n      const previous = item.previous;\n      if (!next || !previous) {\n        throw new Error(\"Invalid list\");\n      }\n      next.previous = previous;\n      previous.next = next;\n    }\n    item.next = void 0;\n    item.previous = void 0;\n    this._state++;\n  }\n  touch(item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error(\"Invalid list\");\n    }\n    if (touch !== 1 \u0026\u0026 touch !== 2) {\n      return;\n    }\n    if (touch === 1) {\n      if (item === this._head) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      if (item === this._tail) {\n        previous.next = void 0;\n        this._tail = previous;\n      } else {\n        next.previous = previous;\n        previous.next = next;\n      }\n      item.previous = void 0;\n      item.next = this._head;\n      this._head.previous = item;\n      this._head = item;\n      this._state++;\n    } else if (touch === 2) {\n      if (item === this._tail) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      if (item === this._head) {\n        next.previous = void 0;\n        this._head = next;\n      } else {\n        next.previous = previous;\n        previous.next = next;\n      }\n      item.next = void 0;\n      item.previous = this._tail;\n      this._tail.next = item;\n      this._tail = item;\n      this._state++;\n    }\n  }\n  toJSON() {\n    const data = [];\n    this.forEach((value, key) =\u003e {\n      data.push([key, value]);\n    });\n    return data;\n  }\n  fromJSON(data) {\n    this.clear();\n    for (const [key, value] of data) {\n      this.set(key, value);\n    }\n  }\n};\nvar Cache = class extends LinkedMap {\n  constructor(limit, ratio = 1) {\n    super();\n    this._limit = limit;\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n  }\n  get limit() {\n    return this._limit;\n  }\n  set limit(limit) {\n    this._limit = limit;\n    this.checkTrim();\n  }\n  get(key, touch = 2) {\n    return super.get(key, touch);\n  }\n  peek(key) {\n    return super.get(\n      key,\n      0\n      /* Touch.None */\n    );\n  }\n  set(key, value) {\n    super.set(\n      key,\n      value,\n      2\n      /* Touch.AsNew */\n    );\n    return this;\n  }\n  checkTrim() {\n    if (this.size \u003e this._limit) {\n      this.trim(Math.round(this._limit * this._ratio));\n    }\n  }\n};\nvar LRUCache = class extends Cache {\n  constructor(limit, ratio = 1) {\n    super(limit, ratio);\n  }\n  trim(newSize) {\n    this.trimOld(newSize);\n  }\n  set(key, value) {\n    super.set(key, value);\n    this.checkTrim();\n    return this;\n  }\n};\nvar SetMap = class {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map();\n  }\n  add(key, value) {\n    let values = this.map.get(key);\n    if (!values) {\n      values = /* @__PURE__ */ new Set();\n      this.map.set(key, values);\n    }\n    values.add(value);\n  }\n  delete(key, value) {\n    const values = this.map.get(key);\n    if (!values) {\n      return;\n    }\n    values.delete(value);\n    if (values.size === 0) {\n      this.map.delete(key);\n    }\n  }\n  forEach(key, fn) {\n    const values = this.map.get(key);\n    if (!values) {\n      return;\n    }\n    values.forEach(fn);\n  }\n  get(key) {\n    const values = this.map.get(key);\n    if (!values) {\n      return /* @__PURE__ */ new Set();\n    }\n    return values;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js\nvar wordClassifierCache = new LRUCache(10);\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/objects.js\nfunction getAllPropertyNames(obj) {\n  let res = [];\n  while (Object.prototype !== obj) {\n    res = res.concat(Object.getOwnPropertyNames(obj));\n    obj = Object.getPrototypeOf(obj);\n  }\n  return res;\n}\nfunction getAllMethodNames(obj) {\n  const methods = [];\n  for (const prop of getAllPropertyNames(obj)) {\n    if (typeof obj[prop] === \"function\") {\n      methods.push(prop);\n    }\n  }\n  return methods;\n}\nfunction createProxyObject(methodNames, invoke) {\n  const createProxyMethod = (method) =\u003e {\n    return function() {\n      const args = Array.prototype.slice.call(arguments, 0);\n      return invoke(method, args);\n    };\n  };\n  const result = {};\n  for (const methodName of methodNames) {\n    result[methodName] = createProxyMethod(methodName);\n  }\n  return result;\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/model.js\nvar OverviewRulerLane2;\n(function(OverviewRulerLane3) {\n  OverviewRulerLane3[OverviewRulerLane3[\"Left\"] = 1] = \"Left\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Center\"] = 2] = \"Center\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Right\"] = 4] = \"Right\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane2 || (OverviewRulerLane2 = {}));\nvar GlyphMarginLane2;\n(function(GlyphMarginLane3) {\n  GlyphMarginLane3[GlyphMarginLane3[\"Left\"] = 1] = \"Left\";\n  GlyphMarginLane3[GlyphMarginLane3[\"Center\"] = 2] = \"Center\";\n  GlyphMarginLane3[GlyphMarginLane3[\"Right\"] = 3] = \"Right\";\n})(GlyphMarginLane2 || (GlyphMarginLane2 = {}));\nvar InjectedTextCursorStops2;\n(function(InjectedTextCursorStops3) {\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Both\"] = 0] = \"Both\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Right\"] = 1] = \"Right\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Left\"] = 2] = \"Left\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex === 0) {\n    return true;\n  }\n  const charBefore = text.charCodeAt(matchStartIndex - 1);\n  if (wordSeparators.get(charBefore) !== 0) {\n    return true;\n  }\n  if (charBefore === 13 || charBefore === 10) {\n    return true;\n  }\n  if (matchLength \u003e 0) {\n    const firstCharInMatch = text.charCodeAt(matchStartIndex);\n    if (wordSeparators.get(firstCharInMatch) !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex + matchLength === textLength) {\n    return true;\n  }\n  const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n  if (wordSeparators.get(charAfter) !== 0) {\n    return true;\n  }\n  if (charAfter === 13 || charAfter === 10) {\n    return true;\n  }\n  if (matchLength \u003e 0) {\n    const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n    if (wordSeparators.get(lastCharInMatch) !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) \u0026\u0026 rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);\n}\nvar Searcher = class {\n  constructor(wordSeparators, searchRegex) {\n    this._wordSeparators = wordSeparators;\n    this._searchRegex = searchRegex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n  reset(lastIndex) {\n    this._searchRegex.lastIndex = lastIndex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n  next(text) {\n    const textLength = text.length;\n    let m;\n    do {\n      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n        return null;\n      }\n      m = this._searchRegex.exec(text);\n      if (!m) {\n        return null;\n      }\n      const matchStartIndex = m.index;\n      const matchLength = m[0].length;\n      if (matchStartIndex === this._prevMatchStartIndex \u0026\u0026 matchLength === this._prevMatchLength) {\n        if (matchLength === 0) {\n          if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) \u003e 65535) {\n            this._searchRegex.lastIndex += 2;\n          } else {\n            this._searchRegex.lastIndex += 1;\n          }\n          continue;\n        }\n        return null;\n      }\n      this._prevMatchStartIndex = matchStartIndex;\n      this._prevMatchLength = matchLength;\n      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n        return m;\n      }\n    } while (m);\n    return null;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/assert.js\nfunction assertNever(value, message = \"Unreachable\") {\n  throw new Error(message);\n}\nfunction assertFn(condition) {\n  if (!condition()) {\n    debugger;\n    condition();\n    onUnexpectedError(new BugIndicatingError(\"Assertion Failed\"));\n  }\n}\nfunction checkAdjacentItems(items, predicate) {\n  let i = 0;\n  while (i \u003c items.length - 1) {\n    const a = items[i];\n    const b = items[i + 1];\n    if (!predicate(a, b)) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js\nvar USUAL_WORD_SEPARATORS = \"`~!@#$%^\u0026*()-=+[{]}\\\\|;:'\\\",.\u003c\u003e/?\";\nfunction createWordRegExp(allowInWords = \"\") {\n  let source = \"(-?\\\\d*\\\\.\\\\d\\\\w*)|([^\";\n  for (const sep2 of USUAL_WORD_SEPARATORS) {\n    if (allowInWords.indexOf(sep2) \u003e= 0) {\n      continue;\n    }\n    source += \"\\\\\" + sep2;\n  }\n  source += \"\\\\s]+)\";\n  return new RegExp(source, \"g\");\n}\nvar DEFAULT_WORD_REGEXP = createWordRegExp();\nfunction ensureValidWordDefinition(wordDefinition) {\n  let result = DEFAULT_WORD_REGEXP;\n  if (wordDefinition \u0026\u0026 wordDefinition instanceof RegExp) {\n    if (!wordDefinition.global) {\n      let flags = \"g\";\n      if (wordDefinition.ignoreCase) {\n        flags += \"i\";\n      }\n      if (wordDefinition.multiline) {\n        flags += \"m\";\n      }\n      if (wordDefinition.unicode) {\n        flags += \"u\";\n      }\n      result = new RegExp(wordDefinition.source, flags);\n    } else {\n      result = wordDefinition;\n    }\n  }\n  result.lastIndex = 0;\n  return result;\n}\nvar _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n  maxLen: 1e3,\n  windowSize: 15,\n  timeBudget: 150\n});\nfunction getWordAtText(column, wordDefinition, text, textOffset, config) {\n  wordDefinition = ensureValidWordDefinition(wordDefinition);\n  if (!config) {\n    config = Iterable.first(_defaultConfig);\n  }\n  if (text.length \u003e config.maxLen) {\n    let start = column - config.maxLen / 2;\n    if (start \u003c 0) {\n      start = 0;\n    } else {\n      textOffset += start;\n    }\n    text = text.substring(start, column + config.maxLen / 2);\n    return getWordAtText(column, wordDefinition, text, textOffset, config);\n  }\n  const t1 = Date.now();\n  const pos = column - 1 - textOffset;\n  let prevRegexIndex = -1;\n  let match = null;\n  for (let i = 1; ; i++) {\n    if (Date.now() - t1 \u003e= config.timeBudget) {\n      break;\n    }\n    const regexIndex = pos - config.windowSize * i;\n    wordDefinition.lastIndex = Math.max(0, regexIndex);\n    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n    if (!thisMatch \u0026\u0026 match) {\n      break;\n    }\n    match = thisMatch;\n    if (regexIndex \u003c= 0) {\n      break;\n    }\n    prevRegexIndex = regexIndex;\n  }\n  if (match) {\n    const result = {\n      word: match[0],\n      startColumn: textOffset + 1 + match.index,\n      endColumn: textOffset + 1 + match.index + match[0].length\n    };\n    wordDefinition.lastIndex = 0;\n    return result;\n  }\n  return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n  let match;\n  while (match = wordDefinition.exec(text)) {\n    const matchIndex = match.index || 0;\n    if (matchIndex \u003c= pos \u0026\u0026 wordDefinition.lastIndex \u003e= pos) {\n      return match;\n    } else if (stopPos \u003e 0 \u0026\u0026 matchIndex \u003e stopPos) {\n      return null;\n    }\n  }\n  return null;\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js\nvar UnicodeTextModelHighlighter = class {\n  static computeUnicodeHighlights(model, options, range) {\n    const startLine = range ? range.startLineNumber : 1;\n    const endLine = range ? range.endLineNumber : model.getLineCount();\n    const codePointHighlighter = new CodePointHighlighter(options);\n    const candidates = codePointHighlighter.getCandidateCodePoints();\n    let regex;\n    if (candidates === \"allNonBasicAscii\") {\n      regex = new RegExp(\"[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]\", \"g\");\n    } else {\n      regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, \"g\");\n    }\n    const searcher = new Searcher(null, regex);\n    const ranges = [];\n    let hasMore = false;\n    let m;\n    let ambiguousCharacterCount = 0;\n    let invisibleCharacterCount = 0;\n    let nonBasicAsciiCharacterCount = 0;\n    forLoop:\n      for (let lineNumber = startLine, lineCount = endLine; lineNumber \u003c= lineCount; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const lineLength = lineContent.length;\n        searcher.reset(0);\n        do {\n          m = searcher.next(lineContent);\n          if (m) {\n            let startIndex = m.index;\n            let endIndex = m.index + m[0].length;\n            if (startIndex \u003e 0) {\n              const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n              if (isHighSurrogate(charCodeBefore)) {\n                startIndex--;\n              }\n            }\n            if (endIndex + 1 \u003c lineLength) {\n              const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n              if (isHighSurrogate(charCodeBefore)) {\n                endIndex++;\n              }\n            }\n            const str = lineContent.substring(startIndex, endIndex);\n            let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n            if (word \u0026\u0026 word.endColumn \u003c= startIndex + 1) {\n              word = null;\n            }\n            const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n            if (highlightReason !== 0) {\n              if (highlightReason === 3) {\n                ambiguousCharacterCount++;\n              } else if (highlightReason === 2) {\n                invisibleCharacterCount++;\n              } else if (highlightReason === 1) {\n                nonBasicAsciiCharacterCount++;\n              } else {\n                assertNever(highlightReason);\n              }\n              const MAX_RESULT_LENGTH = 1e3;\n              if (ranges.length \u003e= MAX_RESULT_LENGTH) {\n                hasMore = true;\n                break forLoop;\n              }\n              ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n            }\n          }\n        } while (m);\n      }\n    return {\n      ranges,\n      hasMore,\n      ambiguousCharacterCount,\n      invisibleCharacterCount,\n      nonBasicAsciiCharacterCount\n    };\n  }\n  static computeUnicodeHighlightReason(char, options) {\n    const codePointHighlighter = new CodePointHighlighter(options);\n    const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n    switch (reason) {\n      case 0:\n        return null;\n      case 2:\n        return {\n          kind: 1\n          /* UnicodeHighlighterReasonKind.Invisible */\n        };\n      case 3: {\n        const codePoint = char.codePointAt(0);\n        const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n        const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) =\u003e !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n        return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n      }\n      case 1:\n        return {\n          kind: 2\n          /* UnicodeHighlighterReasonKind.NonBasicAscii */\n        };\n    }\n  }\n};\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n  const src = `[${escapeRegExpCharacters(codePoints.map((i) =\u003e String.fromCodePoint(i)).join(\"\"))}]`;\n  return src;\n}\nvar CodePointHighlighter = class {\n  constructor(options) {\n    this.options = options;\n    this.allowedCodePoints = new Set(options.allowedCodePoints);\n    this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n  }\n  getCandidateCodePoints() {\n    if (this.options.nonBasicASCII) {\n      return \"allNonBasicAscii\";\n    }\n    const set = /* @__PURE__ */ new Set();\n    if (this.options.invisibleCharacters) {\n      for (const cp of InvisibleCharacters.codePoints) {\n        if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n          set.add(cp);\n        }\n      }\n    }\n    if (this.options.ambiguousCharacters) {\n      for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n        set.add(cp);\n      }\n    }\n    for (const cp of this.allowedCodePoints) {\n      set.delete(cp);\n    }\n    return set;\n  }\n  shouldHighlightNonBasicASCII(character, wordContext) {\n    const codePoint = character.codePointAt(0);\n    if (this.allowedCodePoints.has(codePoint)) {\n      return 0;\n    }\n    if (this.options.nonBasicASCII) {\n      return 1;\n    }\n    let hasBasicASCIICharacters = false;\n    let hasNonConfusableNonBasicAsciiCharacter = false;\n    if (wordContext) {\n      for (const char of wordContext) {\n        const codePoint2 = char.codePointAt(0);\n        const isBasicASCII2 = isBasicASCII(char);\n        hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;\n        if (!isBasicASCII2 \u0026\u0026 !this.ambiguousCharacters.isAmbiguous(codePoint2) \u0026\u0026 !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {\n          hasNonConfusableNonBasicAsciiCharacter = true;\n        }\n      }\n    }\n    if (\n      /* Don't allow mixing weird looking characters with ASCII */\n      !hasBasicASCIICharacters \u0026\u0026 /* Is there an obviously weird looking character? */\n      hasNonConfusableNonBasicAsciiCharacter\n    ) {\n      return 0;\n    }\n    if (this.options.invisibleCharacters) {\n      if (!isAllowedInvisibleCharacter(character) \u0026\u0026 InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n        return 2;\n      }\n    }\n    if (this.options.ambiguousCharacters) {\n      if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n        return 3;\n      }\n    }\n    return 0;\n  }\n};\nfunction isAllowedInvisibleCharacter(character) {\n  return character === \" \" || character === \"\\n\" || character === \"\t\";\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js\nvar LinesDiff = class {\n  constructor(changes, moves, hitTimeout) {\n    this.changes = changes;\n    this.moves = moves;\n    this.hitTimeout = hitTimeout;\n  }\n};\nvar MovedText = class {\n  constructor(lineRangeMapping, changes) {\n    this.lineRangeMapping = lineRangeMapping;\n    this.changes = changes;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\nvar OffsetRange = class _OffsetRange {\n  static addRange(range, sortedRanges) {\n    let i = 0;\n    while (i \u003c sortedRanges.length \u0026\u0026 sortedRanges[i].endExclusive \u003c range.start) {\n      i++;\n    }\n    let j = i;\n    while (j \u003c sortedRanges.length \u0026\u0026 sortedRanges[j].start \u003c= range.endExclusive) {\n      j++;\n    }\n    if (i === j) {\n      sortedRanges.splice(i, 0, range);\n    } else {\n      const start = Math.min(range.start, sortedRanges[i].start);\n      const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n      sortedRanges.splice(i, j - i, new _OffsetRange(start, end));\n    }\n  }\n  static tryCreate(start, endExclusive) {\n    if (start \u003e endExclusive) {\n      return void 0;\n    }\n    return new _OffsetRange(start, endExclusive);\n  }\n  static ofLength(length) {\n    return new _OffsetRange(0, length);\n  }\n  static ofStartAndLength(start, length) {\n    return new _OffsetRange(start, start + length);\n  }\n  constructor(start, endExclusive) {\n    this.start = start;\n    this.endExclusive = endExclusive;\n    if (start \u003e endExclusive) {\n      throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n    }\n  }\n  get isEmpty() {\n    return this.start === this.endExclusive;\n  }\n  delta(offset) {\n    return new _OffsetRange(this.start + offset, this.endExclusive + offset);\n  }\n  deltaStart(offset) {\n    return new _OffsetRange(this.start + offset, this.endExclusive);\n  }\n  deltaEnd(offset) {\n    return new _OffsetRange(this.start, this.endExclusive + offset);\n  }\n  get length() {\n    return this.endExclusive - this.start;\n  }\n  toString() {\n    return `[${this.start}, ${this.endExclusive})`;\n  }\n  contains(offset) {\n    return this.start \u003c= offset \u0026\u0026 offset \u003c this.endExclusive;\n  }\n  /**\n   * for all numbers n: range1.contains(n) or range2.contains(n) =\u003e range1.join(range2).contains(n)\n   * The joined range is the smallest range that contains both ranges.\n   */\n  join(other) {\n    return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n  }\n  /**\n   * for all numbers n: range1.contains(n) and range2.contains(n) \u003c=\u003e range1.intersect(range2).contains(n)\n   *\n   * The resulting range is empty if the ranges do not intersect, but touch.\n   * If the ranges don't even touch, the result is undefined.\n   */\n  intersect(other) {\n    const start = Math.max(this.start, other.start);\n    const end = Math.min(this.endExclusive, other.endExclusive);\n    if (start \u003c= end) {\n      return new _OffsetRange(start, end);\n    }\n    return void 0;\n  }\n  intersects(other) {\n    const start = Math.max(this.start, other.start);\n    const end = Math.min(this.endExclusive, other.endExclusive);\n    return start \u003c end;\n  }\n  isBefore(other) {\n    return this.endExclusive \u003c= other.start;\n  }\n  isAfter(other) {\n    return this.start \u003e= other.endExclusive;\n  }\n  slice(arr) {\n    return arr.slice(this.start, this.endExclusive);\n  }\n  substring(str) {\n    return str.substring(this.start, this.endExclusive);\n  }\n  /**\n   * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n   * The range must not be empty.\n   */\n  clip(value) {\n    if (this.isEmpty) {\n      throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n    }\n    return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n  }\n  /**\n   * Returns `r := value + k * length` such that `r` is contained in this range.\n   * The range must not be empty.\n   *\n   * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n   */\n  clipCyclic(value) {\n    if (this.isEmpty) {\n      throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n    }\n    if (value \u003c this.start) {\n      return this.endExclusive - (this.start - value) % this.length;\n    }\n    if (value \u003e= this.endExclusive) {\n      return this.start + (value - this.start) % this.length;\n    }\n    return value;\n  }\n  forEach(f) {\n    for (let i = this.start; i \u003c this.endExclusive; i++) {\n      f(i);\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/arraysFind.js\nfunction findLastMonotonous(array, predicate) {\n  const idx = findLastIdxMonotonous(array, predicate);\n  return idx === -1 ? void 0 : array[idx];\n}\nfunction findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n  let i = startIdx;\n  let j = endIdxEx;\n  while (i \u003c j) {\n    const k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      i = k + 1;\n    } else {\n      j = k;\n    }\n  }\n  return i - 1;\n}\nfunction findFirstMonotonous(array, predicate) {\n  const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n  return idx === array.length ? void 0 : array[idx];\n}\nfunction findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\n  let i = startIdx;\n  let j = endIdxEx;\n  while (i \u003c j) {\n    const k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      j = k;\n    } else {\n      i = k + 1;\n    }\n  }\n  return i;\n}\nvar MonotonousArray = class _MonotonousArray {\n  static {\n    this.assertInvariants = false;\n  }\n  constructor(_array) {\n    this._array = _array;\n    this._findLastMonotonousLastIdx = 0;\n  }\n  /**\n   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n   */\n  findLastMonotonous(predicate) {\n    if (_MonotonousArray.assertInvariants) {\n      if (this._prevFindLastPredicate) {\n        for (const item of this._array) {\n          if (this._prevFindLastPredicate(item) \u0026\u0026 !predicate(item)) {\n            throw new Error(\"MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.\");\n          }\n        }\n      }\n      this._prevFindLastPredicate = predicate;\n    }\n    const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n    this._findLastMonotonousLastIdx = idx + 1;\n    return idx === -1 ? void 0 : this._array[idx];\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js\nvar LineRange = class _LineRange {\n  static fromRangeInclusive(range) {\n    return new _LineRange(range.startLineNumber, range.endLineNumber + 1);\n  }\n  /**\n   * @param lineRanges An array of sorted line ranges.\n   */\n  static joinMany(lineRanges) {\n    if (lineRanges.length === 0) {\n      return [];\n    }\n    let result = new LineRangeSet(lineRanges[0].slice());\n    for (let i = 1; i \u003c lineRanges.length; i++) {\n      result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n    }\n    return result.ranges;\n  }\n  static join(lineRanges) {\n    if (lineRanges.length === 0) {\n      throw new BugIndicatingError(\"lineRanges cannot be empty\");\n    }\n    let startLineNumber = lineRanges[0].startLineNumber;\n    let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n    for (let i = 1; i \u003c lineRanges.length; i++) {\n      startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n      endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n    }\n    return new _LineRange(startLineNumber, endLineNumberExclusive);\n  }\n  static ofLength(startLineNumber, length) {\n    return new _LineRange(startLineNumber, startLineNumber + length);\n  }\n  /**\n   * @internal\n   */\n  static deserialize(lineRange) {\n    return new _LineRange(lineRange[0], lineRange[1]);\n  }\n  constructor(startLineNumber, endLineNumberExclusive) {\n    if (startLineNumber \u003e endLineNumberExclusive) {\n      throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n    }\n    this.startLineNumber = startLineNumber;\n    this.endLineNumberExclusive = endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range contains the given line number.\n   */\n  contains(lineNumber) {\n    return this.startLineNumber \u003c= lineNumber \u0026\u0026 lineNumber \u003c this.endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range is empty.\n   */\n  get isEmpty() {\n    return this.startLineNumber === this.endLineNumberExclusive;\n  }\n  /**\n   * Moves this line range by the given offset of line numbers.\n   */\n  delta(offset) {\n    return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n  }\n  deltaLength(offset) {\n    return new _LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n  }\n  /**\n   * The number of lines this line range spans.\n   */\n  get length() {\n    return this.endLineNumberExclusive - this.startLineNumber;\n  }\n  /**\n   * Creates a line range that combines this and the given line range.\n   */\n  join(other) {\n    return new _LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n  }\n  toString() {\n    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n  }\n  /**\n   * The resulting range is empty if the ranges do not intersect, but touch.\n   * If the ranges don't even touch, the result is undefined.\n   */\n  intersect(other) {\n    const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n    const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n    if (startLineNumber \u003c= endLineNumberExclusive) {\n      return new _LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    return void 0;\n  }\n  intersectsStrict(other) {\n    return this.startLineNumber \u003c other.endLineNumberExclusive \u0026\u0026 other.startLineNumber \u003c this.endLineNumberExclusive;\n  }\n  overlapOrTouch(other) {\n    return this.startLineNumber \u003c= other.endLineNumberExclusive \u0026\u0026 other.startLineNumber \u003c= this.endLineNumberExclusive;\n  }\n  equals(b) {\n    return this.startLineNumber === b.startLineNumber \u0026\u0026 this.endLineNumberExclusive === b.endLineNumberExclusive;\n  }\n  toInclusiveRange() {\n    if (this.isEmpty) {\n      return null;\n    }\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n  }\n  /**\n   * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n  */\n  toExclusiveRange() {\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n  }\n  mapToLineArray(f) {\n    const result = [];\n    for (let lineNumber = this.startLineNumber; lineNumber \u003c this.endLineNumberExclusive; lineNumber++) {\n      result.push(f(lineNumber));\n    }\n    return result;\n  }\n  forEach(f) {\n    for (let lineNumber = this.startLineNumber; lineNumber \u003c this.endLineNumberExclusive; lineNumber++) {\n      f(lineNumber);\n    }\n  }\n  /**\n   * @internal\n   */\n  serialize() {\n    return [this.startLineNumber, this.endLineNumberExclusive];\n  }\n  includes(lineNumber) {\n    return this.startLineNumber \u003c= lineNumber \u0026\u0026 lineNumber \u003c this.endLineNumberExclusive;\n  }\n  /**\n   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n   * @internal\n   */\n  toOffsetRange() {\n    return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n  }\n};\nvar LineRangeSet = class _LineRangeSet {\n  constructor(_normalizedRanges = []) {\n    this._normalizedRanges = _normalizedRanges;\n  }\n  get ranges() {\n    return this._normalizedRanges;\n  }\n  addRange(range) {\n    if (range.length === 0) {\n      return;\n    }\n    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) =\u003e r.endLineNumberExclusive \u003e= range.startLineNumber);\n    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) =\u003e r.startLineNumber \u003c= range.endLineNumberExclusive) + 1;\n    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n      this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n    } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n      const joinRange = this._normalizedRanges[joinRangeStartIdx];\n      this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n    } else {\n      const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n      this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n    }\n  }\n  contains(lineNumber) {\n    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) =\u003e r.startLineNumber \u003c= lineNumber);\n    return !!rangeThatStartsBeforeEnd \u0026\u0026 rangeThatStartsBeforeEnd.endLineNumberExclusive \u003e lineNumber;\n  }\n  intersects(range) {\n    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) =\u003e r.startLineNumber \u003c range.endLineNumberExclusive);\n    return !!rangeThatStartsBeforeEnd \u0026\u0026 rangeThatStartsBeforeEnd.endLineNumberExclusive \u003e range.startLineNumber;\n  }\n  getUnion(other) {\n    if (this._normalizedRanges.length === 0) {\n      return other;\n    }\n    if (other._normalizedRanges.length === 0) {\n      return this;\n    }\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    let current = null;\n    while (i1 \u003c this._normalizedRanges.length || i2 \u003c other._normalizedRanges.length) {\n      let next = null;\n      if (i1 \u003c this._normalizedRanges.length \u0026\u0026 i2 \u003c other._normalizedRanges.length) {\n        const lineRange1 = this._normalizedRanges[i1];\n        const lineRange2 = other._normalizedRanges[i2];\n        if (lineRange1.startLineNumber \u003c lineRange2.startLineNumber) {\n          next = lineRange1;\n          i1++;\n        } else {\n          next = lineRange2;\n          i2++;\n        }\n      } else if (i1 \u003c this._normalizedRanges.length) {\n        next = this._normalizedRanges[i1];\n        i1++;\n      } else {\n        next = other._normalizedRanges[i2];\n        i2++;\n      }\n      if (current === null) {\n        current = next;\n      } else {\n        if (current.endLineNumberExclusive \u003e= next.startLineNumber) {\n          current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n        } else {\n          result.push(current);\n          current = next;\n        }\n      }\n    }\n    if (current !== null) {\n      result.push(current);\n    }\n    return new _LineRangeSet(result);\n  }\n  /**\n   * Subtracts all ranges in this set from `range` and returns the result.\n   */\n  subtractFrom(range) {\n    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) =\u003e r.endLineNumberExclusive \u003e= range.startLineNumber);\n    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) =\u003e r.startLineNumber \u003c= range.endLineNumberExclusive) + 1;\n    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n      return new _LineRangeSet([range]);\n    }\n    const result = [];\n    let startLineNumber = range.startLineNumber;\n    for (let i = joinRangeStartIdx; i \u003c joinRangeEndIdxExclusive; i++) {\n      const r = this._normalizedRanges[i];\n      if (r.startLineNumber \u003e startLineNumber) {\n        result.push(new LineRange(startLineNumber, r.startLineNumber));\n      }\n      startLineNumber = r.endLineNumberExclusive;\n    }\n    if (startLineNumber \u003c range.endLineNumberExclusive) {\n      result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n    }\n    return new _LineRangeSet(result);\n  }\n  toString() {\n    return this._normalizedRanges.map((r) =\u003e r.toString()).join(\", \");\n  }\n  getIntersection(other) {\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    while (i1 \u003c this._normalizedRanges.length \u0026\u0026 i2 \u003c other._normalizedRanges.length) {\n      const r1 = this._normalizedRanges[i1];\n      const r2 = other._normalizedRanges[i2];\n      const i = r1.intersect(r2);\n      if (i \u0026\u0026 !i.isEmpty) {\n        result.push(i);\n      }\n      if (r1.endLineNumberExclusive \u003c r2.endLineNumberExclusive) {\n        i1++;\n      } else {\n        i2++;\n      }\n    }\n    return new _LineRangeSet(result);\n  }\n  getWithDelta(value) {\n    return new _LineRangeSet(this._normalizedRanges.map((r) =\u003e r.delta(value)));\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js\nvar TextLength = class _TextLength {\n  static {\n    this.zero = new _TextLength(0, 0);\n  }\n  static betweenPositions(position1, position2) {\n    if (position1.lineNumber === position2.lineNumber) {\n      return new _TextLength(0, position2.column - position1.column);\n    } else {\n      return new _TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n    }\n  }\n  static ofRange(range) {\n    return _TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n  }\n  static ofText(text) {\n    let line = 0;\n    let column = 0;\n    for (const c of text) {\n      if (c === \"\\n\") {\n        line++;\n        column = 0;\n      } else {\n        column++;\n      }\n    }\n    return new _TextLength(line, column);\n  }\n  constructor(lineCount, columnCount) {\n    this.lineCount = lineCount;\n    this.columnCount = columnCount;\n  }\n  isGreaterThanOrEqualTo(other) {\n    if (this.lineCount !== other.lineCount) {\n      return this.lineCount \u003e other.lineCount;\n    }\n    return this.columnCount \u003e= other.columnCount;\n  }\n  createRange(startPosition) {\n    if (this.lineCount === 0) {\n      return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n    } else {\n      return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n    }\n  }\n  addToPosition(position) {\n    if (this.lineCount === 0) {\n      return new Position(position.lineNumber, position.column + this.columnCount);\n    } else {\n      return new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n    }\n  }\n  toString() {\n    return `${this.lineCount},${this.columnCount}`;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js\nvar SingleTextEdit = class {\n  constructor(range, text) {\n    this.range = range;\n    this.text = text;\n  }\n  toSingleEditOperation() {\n    return {\n      range: this.range,\n      text: this.text\n    };\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js\nvar LineRangeMapping = class _LineRangeMapping {\n  static inverse(mapping, originalLineCount, modifiedLineCount) {\n    const result = [];\n    let lastOriginalEndLineNumber = 1;\n    let lastModifiedEndLineNumber = 1;\n    for (const m of mapping) {\n      const r2 = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\n      if (!r2.modified.isEmpty) {\n        result.push(r2);\n      }\n      lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n      lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n    }\n    const r = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\n    if (!r.modified.isEmpty) {\n      result.push(r);\n    }\n    return result;\n  }\n  static clip(mapping, originalRange, modifiedRange) {\n    const result = [];\n    for (const m of mapping) {\n      const original = m.original.intersect(originalRange);\n      const modified = m.modified.intersect(modifiedRange);\n      if (original \u0026\u0026 !original.isEmpty \u0026\u0026 modified \u0026\u0026 !modified.isEmpty) {\n        result.push(new _LineRangeMapping(original, modified));\n      }\n    }\n    return result;\n  }\n  constructor(originalRange, modifiedRange) {\n    this.original = originalRange;\n    this.modified = modifiedRange;\n  }\n  toString() {\n    return `{${this.original.toString()}-\u003e${this.modified.toString()}}`;\n  }\n  flip() {\n    return new _LineRangeMapping(this.modified, this.original);\n  }\n  join(other) {\n    return new _LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n  }\n  /**\n   * This method assumes that the LineRangeMapping describes a valid diff!\n   * I.e. if one range is empty, the other range cannot be the entire document.\n   * It avoids various problems when the line range points to non-existing line-numbers.\n  */\n  toRangeMapping() {\n    const origInclusiveRange = this.original.toInclusiveRange();\n    const modInclusiveRange = this.modified.toInclusiveRange();\n    if (origInclusiveRange \u0026\u0026 modInclusiveRange) {\n      return new RangeMapping(origInclusiveRange, modInclusiveRange);\n    } else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n      if (!(this.modified.startLineNumber === 1 \u0026\u0026 this.original.startLineNumber === 1)) {\n        throw new BugIndicatingError(\"not a valid diff\");\n      }\n      return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n    } else {\n      return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n    }\n  }\n  /**\n   * This method assumes that the LineRangeMapping describes a valid diff!\n   * I.e. if one range is empty, the other range cannot be the entire document.\n   * It avoids various problems when the line range points to non-existing line-numbers.\n  */\n  toRangeMapping2(original, modified) {\n    if (isValidLineNumber(this.original.endLineNumberExclusive, original) \u0026\u0026 isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n      return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n    }\n    if (!this.original.isEmpty \u0026\u0026 !this.modified.isEmpty) {\n      return new RangeMapping(Range.fromPositions(new Position(this.original.startLineNumber, 1), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(new Position(this.modified.startLineNumber, 1), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n    }\n    if (this.original.startLineNumber \u003e 1 \u0026\u0026 this.modified.startLineNumber \u003e 1) {\n      return new RangeMapping(Range.fromPositions(normalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(normalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n    }\n    throw new BugIndicatingError();\n  }\n};\nfunction normalizePosition(position, content) {\n  if (position.lineNumber \u003c 1) {\n    return new Position(1, 1);\n  }\n  if (position.lineNumber \u003e content.length) {\n    return new Position(content.length, content[content.length - 1].length + 1);\n  }\n  const line = content[position.lineNumber - 1];\n  if (position.column \u003e line.length + 1) {\n    return new Position(position.lineNumber, line.length + 1);\n  }\n  return position;\n}\nfunction isValidLineNumber(lineNumber, lines) {\n  return lineNumber \u003e= 1 \u0026\u0026 lineNumber \u003c= lines.length;\n}\nvar DetailedLineRangeMapping = class _DetailedLineRangeMapping extends LineRangeMapping {\n  static fromRangeMappings(rangeMappings) {\n    const originalRange = LineRange.join(rangeMappings.map((r) =\u003e LineRange.fromRangeInclusive(r.originalRange)));\n    const modifiedRange = LineRange.join(rangeMappings.map((r) =\u003e LineRange.fromRangeInclusive(r.modifiedRange)));\n    return new _DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n  }\n  constructor(originalRange, modifiedRange, innerChanges) {\n    super(originalRange, modifiedRange);\n    this.innerChanges = innerChanges;\n  }\n  flip() {\n    return new _DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map((c) =\u003e c.flip()));\n  }\n  withInnerChangesFromLineRanges() {\n    return new _DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n  }\n};\nvar RangeMapping = class _RangeMapping {\n  static assertSorted(rangeMappings) {\n    for (let i = 1; i \u003c rangeMappings.length; i++) {\n      const previous = rangeMappings[i - 1];\n      const current = rangeMappings[i];\n      if (!(previous.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition()) \u0026\u0026 previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition()))) {\n        throw new BugIndicatingError(\"Range mappings must be sorted\");\n      }\n    }\n  }\n  constructor(originalRange, modifiedRange) {\n    this.originalRange = originalRange;\n    this.modifiedRange = modifiedRange;\n  }\n  toString() {\n    return `{${this.originalRange.toString()}-\u003e${this.modifiedRange.toString()}}`;\n  }\n  flip() {\n    return new _RangeMapping(this.modifiedRange, this.originalRange);\n  }\n  /**\n   * Creates a single text edit that describes the change from the original to the modified text.\n  */\n  toTextEdit(modified) {\n    const newText = modified.getValueOfRange(this.modifiedRange);\n    return new SingleTextEdit(this.originalRange, newText);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js\nvar MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nvar LegacyLinesDiffComputer = class {\n  computeDiff(originalLines, modifiedLines, options) {\n    const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n      maxComputationTime: options.maxComputationTimeMs,\n      shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n      shouldComputeCharChanges: true,\n      shouldMakePrettyDiff: true,\n      shouldPostProcessCharChanges: true\n    });\n    const result = diffComputer.computeDiff();\n    const changes = [];\n    let lastChange = null;\n    for (const c of result.changes) {\n      let originalRange;\n      if (c.originalEndLineNumber === 0) {\n        originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n      } else {\n        originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n      }\n      let modifiedRange;\n      if (c.modifiedEndLineNumber === 0) {\n        modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n      } else {\n        modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n      }\n      let change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map((c2) =\u003e new RangeMapping(new Range(c2.originalStartLineNumber, c2.originalStartColumn, c2.originalEndLineNumber, c2.originalEndColumn), new Range(c2.modifiedStartLineNumber, c2.modifiedStartColumn, c2.modifiedEndLineNumber, c2.modifiedEndColumn))));\n      if (lastChange) {\n        if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n          change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges \u0026\u0026 change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);\n          changes.pop();\n        }\n      }\n      changes.push(change);\n      lastChange = change;\n    }\n    assertFn(() =\u003e {\n      return checkAdjacentItems(changes, (m1, m2) =\u003e m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive \u0026\u0026 // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n      m1.original.endLineNumberExclusive \u003c m2.original.startLineNumber \u0026\u0026 m1.modified.endLineNumberExclusive \u003c m2.modified.startLineNumber);\n    });\n    return new LinesDiff(changes, [], result.quitEarly);\n  }\n};\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n  return diffAlgo.ComputeDiff(pretty);\n}\nvar LineSequence = class {\n  constructor(lines) {\n    const startColumns = [];\n    const endColumns = [];\n    for (let i = 0, length = lines.length; i \u003c length; i++) {\n      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n      endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n    }\n    this.lines = lines;\n    this._startColumns = startColumns;\n    this._endColumns = endColumns;\n  }\n  getElements() {\n    const elements = [];\n    for (let i = 0, len = this.lines.length; i \u003c len; i++) {\n      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n    }\n    return elements;\n  }\n  getStrictElement(index) {\n    return this.lines[index];\n  }\n  getStartLineNumber(i) {\n    return i + 1;\n  }\n  getEndLineNumber(i) {\n    return i + 1;\n  }\n  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n    const charCodes = [];\n    const lineNumbers = [];\n    const columns = [];\n    let len = 0;\n    for (let index = startIndex; index \u003c= endIndex; index++) {\n      const lineContent = this.lines[index];\n      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;\n      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;\n      for (let col = startColumn; col \u003c endColumn; col++) {\n        charCodes[len] = lineContent.charCodeAt(col - 1);\n        lineNumbers[len] = index + 1;\n        columns[len] = col;\n        len++;\n      }\n      if (!shouldIgnoreTrimWhitespace \u0026\u0026 index \u003c endIndex) {\n        charCodes[len] = 10;\n        lineNumbers[len] = index + 1;\n        columns[len] = lineContent.length + 1;\n        len++;\n      }\n    }\n    return new CharSequence(charCodes, lineNumbers, columns);\n  }\n};\nvar CharSequence = class {\n  constructor(charCodes, lineNumbers, columns) {\n    this._charCodes = charCodes;\n    this._lineNumbers = lineNumbers;\n    this._columns = columns;\n  }\n  toString() {\n    return \"[\" + this._charCodes.map((s, idx) =\u003e (s === 10 ? \"\\\\n\" : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(\", \") + \"]\";\n  }\n  _assertIndex(index, arr) {\n    if (index \u003c 0 || index \u003e= arr.length) {\n      throw new Error(`Illegal index`);\n    }\n  }\n  getElements() {\n    return this._charCodes;\n  }\n  getStartLineNumber(i) {\n    if (i \u003e 0 \u0026\u0026 i === this._lineNumbers.length) {\n      return this.getEndLineNumber(i - 1);\n    }\n    this._assertIndex(i, this._lineNumbers);\n    return this._lineNumbers[i];\n  }\n  getEndLineNumber(i) {\n    if (i === -1) {\n      return this.getStartLineNumber(i + 1);\n    }\n    this._assertIndex(i, this._lineNumbers);\n    if (this._charCodes[i] === 10) {\n      return this._lineNumbers[i] + 1;\n    }\n    return this._lineNumbers[i];\n  }\n  getStartColumn(i) {\n    if (i \u003e 0 \u0026\u0026 i === this._columns.length) {\n      return this.getEndColumn(i - 1);\n    }\n    this._assertIndex(i, this._columns);\n    return this._columns[i];\n  }\n  getEndColumn(i) {\n    if (i === -1) {\n      return this.getStartColumn(i + 1);\n    }\n    this._assertIndex(i, this._columns);\n    if (this._charCodes[i] === 10) {\n      return 1;\n    }\n    return this._columns[i] + 1;\n  }\n};\nvar CharChange = class _CharChange {\n  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalStartColumn = originalStartColumn;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.originalEndColumn = originalEndColumn;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedStartColumn = modifiedStartColumn;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.modifiedEndColumn = modifiedEndColumn;\n  }\n  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n    const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n    const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n    const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n    const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n    const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n    const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n    const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n  }\n};\nfunction postProcessCharChanges(rawChanges) {\n  if (rawChanges.length \u003c= 1) {\n    return rawChanges;\n  }\n  const result = [rawChanges[0]];\n  let prevChange = result[0];\n  for (let i = 1, len = rawChanges.length; i \u003c len; i++) {\n    const currChange = rawChanges[i];\n    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n    if (matchingLength \u003c MINIMUM_MATCHING_CHARACTER_LENGTH) {\n      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;\n      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;\n    } else {\n      result.push(currChange);\n      prevChange = currChange;\n    }\n  }\n  return result;\n}\nvar LineChange = class _LineChange {\n  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.charChanges = charChanges;\n  }\n  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n    let originalStartLineNumber;\n    let originalEndLineNumber;\n    let modifiedStartLineNumber;\n    let modifiedEndLineNumber;\n    let charChanges = void 0;\n    if (diffChange.originalLength === 0) {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n      originalEndLineNumber = 0;\n    } else {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n    }\n    if (diffChange.modifiedLength === 0) {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n      modifiedEndLineNumber = 0;\n    } else {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    }\n    if (shouldComputeCharChanges \u0026\u0026 diffChange.originalLength \u003e 0 \u0026\u0026 diffChange.originalLength \u003c 20 \u0026\u0026 diffChange.modifiedLength \u003e 0 \u0026\u0026 diffChange.modifiedLength \u003c 20 \u0026\u0026 continueCharDiff()) {\n      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      if (originalCharSequence.getElements().length \u003e 0 \u0026\u0026 modifiedCharSequence.getElements().length \u003e 0) {\n        let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n        if (shouldPostProcessCharChanges) {\n          rawChanges = postProcessCharChanges(rawChanges);\n        }\n        charChanges = [];\n        for (let i = 0, length = rawChanges.length; i \u003c length; i++) {\n          charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n        }\n      }\n    }\n    return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n  }\n};\nvar DiffComputer = class {\n  constructor(originalLines, modifiedLines, opts) {\n    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n    this.originalLines = originalLines;\n    this.modifiedLines = modifiedLines;\n    this.original = new LineSequence(originalLines);\n    this.modified = new LineSequence(modifiedLines);\n    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));\n  }\n  computeDiff() {\n    if (this.original.lines.length === 1 \u0026\u0026 this.original.lines[0].length === 0) {\n      if (this.modified.lines.length === 1 \u0026\u0026 this.modified.lines[0].length === 0) {\n        return {\n          quitEarly: false,\n          changes: []\n        };\n      }\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: 1,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: this.modified.lines.length,\n          charChanges: void 0\n        }]\n      };\n    }\n    if (this.modified.lines.length === 1 \u0026\u0026 this.modified.lines[0].length === 0) {\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: this.original.lines.length,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: 1,\n          charChanges: void 0\n        }]\n      };\n    }\n    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n    const rawChanges = diffResult.changes;\n    const quitEarly = diffResult.quitEarly;\n    if (this.shouldIgnoreTrimWhitespace) {\n      const lineChanges = [];\n      for (let i = 0, length = rawChanges.length; i \u003c length; i++) {\n        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n      }\n      return {\n        quitEarly,\n        changes: lineChanges\n      };\n    }\n    const result = [];\n    let originalLineIndex = 0;\n    let modifiedLineIndex = 0;\n    for (let i = -1, len = rawChanges.length; i \u003c len; i++) {\n      const nextChange = i + 1 \u003c len ? rawChanges[i + 1] : null;\n      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;\n      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;\n      while (originalLineIndex \u003c originalStop \u0026\u0026 modifiedLineIndex \u003c modifiedStop) {\n        const originalLine = this.originalLines[originalLineIndex];\n        const modifiedLine = this.modifiedLines[modifiedLineIndex];\n        if (originalLine !== modifiedLine) {\n          {\n            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n            while (originalStartColumn \u003e 1 \u0026\u0026 modifiedStartColumn \u003e 1) {\n              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n              originalStartColumn--;\n              modifiedStartColumn--;\n            }\n            if (originalStartColumn \u003e 1 || modifiedStartColumn \u003e 1) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n            }\n          }\n          {\n            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n            const originalMaxColumn = originalLine.length + 1;\n            const modifiedMaxColumn = modifiedLine.length + 1;\n            while (originalEndColumn \u003c originalMaxColumn \u0026\u0026 modifiedEndColumn \u003c modifiedMaxColumn) {\n              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n              originalEndColumn++;\n              modifiedEndColumn++;\n            }\n            if (originalEndColumn \u003c originalMaxColumn || modifiedEndColumn \u003c modifiedMaxColumn) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n            }\n          }\n        }\n        originalLineIndex++;\n        modifiedLineIndex++;\n      }\n      if (nextChange) {\n        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n        originalLineIndex += nextChange.originalLength;\n        modifiedLineIndex += nextChange.modifiedLength;\n      }\n    }\n    return {\n      quitEarly,\n      changes: result\n    };\n  }\n  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n      return;\n    }\n    let charChanges = void 0;\n    if (this.shouldComputeCharChanges) {\n      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n    }\n    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n  }\n  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    const len = result.length;\n    if (len === 0) {\n      return false;\n    }\n    const prevChange = result[len - 1];\n    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n      return false;\n    }\n    if (prevChange.originalEndLineNumber === originalLineNumber \u0026\u0026 prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n      if (this.shouldComputeCharChanges \u0026\u0026 prevChange.charChanges) {\n        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n      }\n      return true;\n    }\n    if (prevChange.originalEndLineNumber + 1 === originalLineNumber \u0026\u0026 prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n      prevChange.originalEndLineNumber = originalLineNumber;\n      prevChange.modifiedEndLineNumber = modifiedLineNumber;\n      if (this.shouldComputeCharChanges \u0026\u0026 prevChange.charChanges) {\n        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n      }\n      return true;\n    }\n    return false;\n  }\n};\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n  const r = firstNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n  const r = lastNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n  if (maximumRuntime === 0) {\n    return () =\u003e true;\n  }\n  const startTime = Date.now();\n  return () =\u003e {\n    return Date.now() - startTime \u003c maximumRuntime;\n  };\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js\nfunction equals2(one, other, itemEquals = (a, b) =\u003e a === b) {\n  if (one === other) {\n    return true;\n  }\n  if (!one || !other) {\n    return false;\n  }\n  if (one.length !== other.length) {\n    return false;\n  }\n  for (let i = 0, len = one.length; i \u003c len; i++) {\n    if (!itemEquals(one[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction* groupAdjacentBy(items, shouldBeGrouped) {\n  let currentGroup;\n  let last;\n  for (const item of items) {\n    if (last !== void 0 \u0026\u0026 shouldBeGrouped(last, item)) {\n      currentGroup.push(item);\n    } else {\n      if (currentGroup) {\n        yield currentGroup;\n      }\n      currentGroup = [item];\n    }\n    last = item;\n  }\n  if (currentGroup) {\n    yield currentGroup;\n  }\n}\nfunction forEachAdjacent(arr, f) {\n  for (let i = 0; i \u003c= arr.length; i++) {\n    f(i === 0 ? void 0 : arr[i - 1], i === arr.length ? void 0 : arr[i]);\n  }\n}\nfunction forEachWithNeighbors(arr, f) {\n  for (let i = 0; i \u003c arr.length; i++) {\n    f(i === 0 ? void 0 : arr[i - 1], arr[i], i + 1 === arr.length ? void 0 : arr[i + 1]);\n  }\n}\nfunction pushMany(arr, items) {\n  for (const item of items) {\n    arr.push(item);\n  }\n}\nvar CompareResult;\n(function(CompareResult2) {\n  function isLessThan(result) {\n    return result \u003c 0;\n  }\n  CompareResult2.isLessThan = isLessThan;\n  function isLessThanOrEqual(result) {\n    return result \u003c= 0;\n  }\n  CompareResult2.isLessThanOrEqual = isLessThanOrEqual;\n  function isGreaterThan(result) {\n    return result \u003e 0;\n  }\n  CompareResult2.isGreaterThan = isGreaterThan;\n  function isNeitherLessOrGreaterThan(result) {\n    return result === 0;\n  }\n  CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;\n  CompareResult2.greaterThan = 1;\n  CompareResult2.lessThan = -1;\n  CompareResult2.neitherLessOrGreaterThan = 0;\n})(CompareResult || (CompareResult = {}));\nfunction compareBy(selector, comparator) {\n  return (a, b) =\u003e comparator(selector(a), selector(b));\n}\nvar numberComparator = (a, b) =\u003e a - b;\nfunction reverseOrder(comparator) {\n  return (a, b) =\u003e -comparator(a, b);\n}\nvar CallbackIterable = class _CallbackIterable {\n  static {\n    this.empty = new _CallbackIterable((_callback) =\u003e {\n    });\n  }\n  constructor(iterate) {\n    this.iterate = iterate;\n  }\n  toArray() {\n    const result = [];\n    this.iterate((item) =\u003e {\n      result.push(item);\n      return true;\n    });\n    return result;\n  }\n  filter(predicate) {\n    return new _CallbackIterable((cb) =\u003e this.iterate((item) =\u003e predicate(item) ? cb(item) : true));\n  }\n  map(mapFn) {\n    return new _CallbackIterable((cb) =\u003e this.iterate((item) =\u003e cb(mapFn(item))));\n  }\n  findLast(predicate) {\n    let result;\n    this.iterate((item) =\u003e {\n      if (predicate(item)) {\n        result = item;\n      }\n      return true;\n    });\n    return result;\n  }\n  findLastMaxBy(comparator) {\n    let result;\n    let first = true;\n    this.iterate((item) =\u003e {\n      if (first || CompareResult.isGreaterThan(comparator(item, result))) {\n        first = false;\n        result = item;\n      }\n      return true;\n    });\n    return result;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js\nvar DiffAlgorithmResult = class _DiffAlgorithmResult {\n  static trivial(seq1, seq2) {\n    return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n  }\n  static trivialTimedOut(seq1, seq2) {\n    return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n  }\n  constructor(diffs, hitTimeout) {\n    this.diffs = diffs;\n    this.hitTimeout = hitTimeout;\n  }\n};\nvar SequenceDiff = class _SequenceDiff {\n  static invert(sequenceDiffs, doc1Length) {\n    const result = [];\n    forEachAdjacent(sequenceDiffs, (a, b) =\u003e {\n      result.push(_SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));\n    });\n    return result;\n  }\n  static fromOffsetPairs(start, endExclusive) {\n    return new _SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));\n  }\n  static assertSorted(sequenceDiffs) {\n    let last = void 0;\n    for (const cur of sequenceDiffs) {\n      if (last) {\n        if (!(last.seq1Range.endExclusive \u003c= cur.seq1Range.start \u0026\u0026 last.seq2Range.endExclusive \u003c= cur.seq2Range.start)) {\n          throw new BugIndicatingError(\"Sequence diffs must be sorted\");\n        }\n      }\n      last = cur;\n    }\n  }\n  constructor(seq1Range, seq2Range) {\n    this.seq1Range = seq1Range;\n    this.seq2Range = seq2Range;\n  }\n  swap() {\n    return new _SequenceDiff(this.seq2Range, this.seq1Range);\n  }\n  toString() {\n    return `${this.seq1Range} \u003c-\u003e ${this.seq2Range}`;\n  }\n  join(other) {\n    return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n  }\n  delta(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n  }\n  deltaStart(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new _SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n  }\n  deltaEnd(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new _SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n  }\n  intersect(other) {\n    const i1 = this.seq1Range.intersect(other.seq1Range);\n    const i2 = this.seq2Range.intersect(other.seq2Range);\n    if (!i1 || !i2) {\n      return void 0;\n    }\n    return new _SequenceDiff(i1, i2);\n  }\n  getStarts() {\n    return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n  }\n  getEndExclusives() {\n    return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n  }\n};\nvar OffsetPair = class _OffsetPair {\n  static {\n    this.zero = new _OffsetPair(0, 0);\n  }\n  static {\n    this.max = new _OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n  }\n  constructor(offset1, offset2) {\n    this.offset1 = offset1;\n    this.offset2 = offset2;\n  }\n  toString() {\n    return `${this.offset1} \u003c-\u003e ${this.offset2}`;\n  }\n  delta(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new _OffsetPair(this.offset1 + offset, this.offset2 + offset);\n  }\n  equals(other) {\n    return this.offset1 === other.offset1 \u0026\u0026 this.offset2 === other.offset2;\n  }\n};\nvar InfiniteTimeout = class _InfiniteTimeout {\n  static {\n    this.instance = new _InfiniteTimeout();\n  }\n  isValid() {\n    return true;\n  }\n};\nvar DateTimeout = class {\n  constructor(timeout) {\n    this.timeout = timeout;\n    this.startTime = Date.now();\n    this.valid = true;\n    if (timeout \u003c= 0) {\n      throw new BugIndicatingError(\"timeout must be positive\");\n    }\n  }\n  // Recommendation: Set a log-point `{this.disable()}` in the body\n  isValid() {\n    const valid = Date.now() - this.startTime \u003c this.timeout;\n    if (!valid \u0026\u0026 this.valid) {\n      this.valid = false;\n      debugger;\n    }\n    return this.valid;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js\nvar Array2D = class {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.array = [];\n    this.array = new Array(width * height);\n  }\n  get(x, y) {\n    return this.array[x + y * this.width];\n  }\n  set(x, y, value) {\n    this.array[x + y * this.width] = value;\n  }\n};\nfunction isSpace(charCode) {\n  return charCode === 32 || charCode === 9;\n}\nvar LineRangeFragment = class _LineRangeFragment {\n  static {\n    this.chrKeys = /* @__PURE__ */ new Map();\n  }\n  static getKey(chr) {\n    let key = this.chrKeys.get(chr);\n    if (key === void 0) {\n      key = this.chrKeys.size;\n      this.chrKeys.set(chr, key);\n    }\n    return key;\n  }\n  constructor(range, lines, source) {\n    this.range = range;\n    this.lines = lines;\n    this.source = source;\n    this.histogram = [];\n    let counter = 0;\n    for (let i = range.startLineNumber - 1; i \u003c range.endLineNumberExclusive - 1; i++) {\n      const line = lines[i];\n      for (let j = 0; j \u003c line.length; j++) {\n        counter++;\n        const chr = line[j];\n        const key2 = _LineRangeFragment.getKey(chr);\n        this.histogram[key2] = (this.histogram[key2] || 0) + 1;\n      }\n      counter++;\n      const key = _LineRangeFragment.getKey(\"\\n\");\n      this.histogram[key] = (this.histogram[key] || 0) + 1;\n    }\n    this.totalCount = counter;\n  }\n  computeSimilarity(other) {\n    let sumDifferences = 0;\n    const maxLength = Math.max(this.histogram.length, other.histogram.length);\n    for (let i = 0; i \u003c maxLength; i++) {\n      sumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));\n    }\n    return 1 - sumDifferences / (this.totalCount + other.totalCount);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js\nvar DynamicProgrammingDiffing = class {\n  compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n    if (sequence1.length === 0 || sequence2.length === 0) {\n      return DiffAlgorithmResult.trivial(sequence1, sequence2);\n    }\n    const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n    const directions = new Array2D(sequence1.length, sequence2.length);\n    const lengths = new Array2D(sequence1.length, sequence2.length);\n    for (let s12 = 0; s12 \u003c sequence1.length; s12++) {\n      for (let s22 = 0; s22 \u003c sequence2.length; s22++) {\n        if (!timeout.isValid()) {\n          return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n        }\n        const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);\n        const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);\n        let extendedSeqScore;\n        if (sequence1.getElement(s12) === sequence2.getElement(s22)) {\n          if (s12 === 0 || s22 === 0) {\n            extendedSeqScore = 0;\n          } else {\n            extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);\n          }\n          if (s12 \u003e 0 \u0026\u0026 s22 \u003e 0 \u0026\u0026 directions.get(s12 - 1, s22 - 1) === 3) {\n            extendedSeqScore += lengths.get(s12 - 1, s22 - 1);\n          }\n          extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;\n        } else {\n          extendedSeqScore = -1;\n        }\n        const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n        if (newValue === extendedSeqScore) {\n          const prevLen = s12 \u003e 0 \u0026\u0026 s22 \u003e 0 ? lengths.get(s12 - 1, s22 - 1) : 0;\n          lengths.set(s12, s22, prevLen + 1);\n          directions.set(s12, s22, 3);\n        } else if (newValue === horizontalLen) {\n          lengths.set(s12, s22, 0);\n          directions.set(s12, s22, 1);\n        } else if (newValue === verticalLen) {\n          lengths.set(s12, s22, 0);\n          directions.set(s12, s22, 2);\n        }\n        lcsLengths.set(s12, s22, newValue);\n      }\n    }\n    const result = [];\n    let lastAligningPosS1 = sequence1.length;\n    let lastAligningPosS2 = sequence2.length;\n    function reportDecreasingAligningPositions(s12, s22) {\n      if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {\n        result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));\n      }\n      lastAligningPosS1 = s12;\n      lastAligningPosS2 = s22;\n    }\n    let s1 = sequence1.length - 1;\n    let s2 = sequence2.length - 1;\n    while (s1 \u003e= 0 \u0026\u0026 s2 \u003e= 0) {\n      if (directions.get(s1, s2) === 3) {\n        reportDecreasingAligningPositions(s1, s2);\n        s1--;\n        s2--;\n      } else {\n        if (directions.get(s1, s2) === 1) {\n          s1--;\n        } else {\n          s2--;\n        }\n      }\n    }\n    reportDecreasingAligningPositions(-1, -1);\n    result.reverse();\n    return new DiffAlgorithmResult(result, false);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js\nvar MyersDiffAlgorithm = class {\n  compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n    if (seq1.length === 0 || seq2.length === 0) {\n      return DiffAlgorithmResult.trivial(seq1, seq2);\n    }\n    const seqX = seq1;\n    const seqY = seq2;\n    function getXAfterSnake(x, y) {\n      while (x \u003c seqX.length \u0026\u0026 y \u003c seqY.length \u0026\u0026 seqX.getElement(x) === seqY.getElement(y)) {\n        x++;\n        y++;\n      }\n      return x;\n    }\n    let d = 0;\n    const V = new FastInt32Array();\n    V.set(0, getXAfterSnake(0, 0));\n    const paths = new FastArrayNegativeIndices();\n    paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n    let k = 0;\n    loop:\n      while (true) {\n        d++;\n        if (!timeout.isValid()) {\n          return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n        }\n        const lowerBound = -Math.min(d, seqY.length + d % 2);\n        const upperBound = Math.min(d, seqX.length + d % 2);\n        for (k = lowerBound; k \u003c= upperBound; k += 2) {\n          let step = 0;\n          const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1);\n          const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1;\n          step++;\n          const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n          const y = x - k;\n          step++;\n          if (x \u003e seqX.length || y \u003e seqY.length) {\n            continue;\n          }\n          const newMaxX = getXAfterSnake(x, y);\n          V.set(k, newMaxX);\n          const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n          paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n          if (V.get(k) === seqX.length \u0026\u0026 V.get(k) - k === seqY.length) {\n            break loop;\n          }\n        }\n      }\n    let path = paths.get(k);\n    const result = [];\n    let lastAligningPosS1 = seqX.length;\n    let lastAligningPosS2 = seqY.length;\n    while (true) {\n      const endX = path ? path.x + path.length : 0;\n      const endY = path ? path.y + path.length : 0;\n      if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n        result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n      }\n      if (!path) {\n        break;\n      }\n      lastAligningPosS1 = path.x;\n      lastAligningPosS2 = path.y;\n      path = path.prev;\n    }\n    result.reverse();\n    return new DiffAlgorithmResult(result, false);\n  }\n};\nvar SnakePath = class {\n  constructor(prev, x, y, length) {\n    this.prev = prev;\n    this.x = x;\n    this.y = y;\n    this.length = length;\n  }\n};\nvar FastInt32Array = class {\n  constructor() {\n    this.positiveArr = new Int32Array(10);\n    this.negativeArr = new Int32Array(10);\n  }\n  get(idx) {\n    if (idx \u003c 0) {\n      idx = -idx - 1;\n      return this.negativeArr[idx];\n    } else {\n      return this.positiveArr[idx];\n    }\n  }\n  set(idx, value) {\n    if (idx \u003c 0) {\n      idx = -idx - 1;\n      if (idx \u003e= this.negativeArr.length) {\n        const arr = this.negativeArr;\n        this.negativeArr = new Int32Array(arr.length * 2);\n        this.negativeArr.set(arr);\n      }\n      this.negativeArr[idx] = value;\n    } else {\n      if (idx \u003e= this.positiveArr.length) {\n        const arr = this.positiveArr;\n        this.positiveArr = new Int32Array(arr.length * 2);\n        this.positiveArr.set(arr);\n      }\n      this.positiveArr[idx] = value;\n    }\n  }\n};\nvar FastArrayNegativeIndices = class {\n  constructor() {\n    this.positiveArr = [];\n    this.negativeArr = [];\n  }\n  get(idx) {\n    if (idx \u003c 0) {\n      idx = -idx - 1;\n      return this.negativeArr[idx];\n    } else {\n      return this.positiveArr[idx];\n    }\n  }\n  set(idx, value) {\n    if (idx \u003c 0) {\n      idx = -idx - 1;\n      this.negativeArr[idx] = value;\n    } else {\n      this.positiveArr[idx] = value;\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js\nvar LinesSliceCharSequence = class {\n  constructor(lines, range, considerWhitespaceChanges) {\n    this.lines = lines;\n    this.range = range;\n    this.considerWhitespaceChanges = considerWhitespaceChanges;\n    this.elements = [];\n    this.firstElementOffsetByLineIdx = [];\n    this.lineStartOffsets = [];\n    this.trimmedWsLengthsByLineIdx = [];\n    this.firstElementOffsetByLineIdx.push(0);\n    for (let lineNumber = this.range.startLineNumber; lineNumber \u003c= this.range.endLineNumber; lineNumber++) {\n      let line = lines[lineNumber - 1];\n      let lineStartOffset = 0;\n      if (lineNumber === this.range.startLineNumber \u0026\u0026 this.range.startColumn \u003e 1) {\n        lineStartOffset = this.range.startColumn - 1;\n        line = line.substring(lineStartOffset);\n      }\n      this.lineStartOffsets.push(lineStartOffset);\n      let trimmedWsLength = 0;\n      if (!considerWhitespaceChanges) {\n        const trimmedStartLine = line.trimStart();\n        trimmedWsLength = line.length - trimmedStartLine.length;\n        line = trimmedStartLine.trimEnd();\n      }\n      this.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n      const lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n      for (let i = 0; i \u003c lineLength; i++) {\n        this.elements.push(line.charCodeAt(i));\n      }\n      if (lineNumber \u003c this.range.endLineNumber) {\n        this.elements.push(\"\\n\".charCodeAt(0));\n        this.firstElementOffsetByLineIdx.push(this.elements.length);\n      }\n    }\n  }\n  toString() {\n    return `Slice: \"${this.text}\"`;\n  }\n  get text() {\n    return this.getText(new OffsetRange(0, this.length));\n  }\n  getText(range) {\n    return this.elements.slice(range.start, range.endExclusive).map((e) =\u003e String.fromCharCode(e)).join(\"\");\n  }\n  getElement(offset) {\n    return this.elements[offset];\n  }\n  get length() {\n    return this.elements.length;\n  }\n  getBoundaryScore(length) {\n    const prevCategory = getCategory(length \u003e 0 ? this.elements[length - 1] : -1);\n    const nextCategory = getCategory(length \u003c this.elements.length ? this.elements[length] : -1);\n    if (prevCategory === 7 \u0026\u0026 nextCategory === 8) {\n      return 0;\n    }\n    if (prevCategory === 8) {\n      return 150;\n    }\n    let score2 = 0;\n    if (prevCategory !== nextCategory) {\n      score2 += 10;\n      if (prevCategory === 0 \u0026\u0026 nextCategory === 1) {\n        score2 += 1;\n      }\n    }\n    score2 += getCategoryBoundaryScore(prevCategory);\n    score2 += getCategoryBoundaryScore(nextCategory);\n    return score2;\n  }\n  translateOffset(offset, preference = \"right\") {\n    const i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) =\u003e value \u003c= offset);\n    const lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n    return new Position(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + lineOffset + (lineOffset === 0 \u0026\u0026 preference === \"left\" ? 0 : this.trimmedWsLengthsByLineIdx[i]));\n  }\n  translateRange(range) {\n    const pos1 = this.translateOffset(range.start, \"right\");\n    const pos2 = this.translateOffset(range.endExclusive, \"left\");\n    if (pos2.isBefore(pos1)) {\n      return Range.fromPositions(pos2, pos2);\n    }\n    return Range.fromPositions(pos1, pos2);\n  }\n  /**\n   * Finds the word that contains the character at the given offset\n   */\n  findWordContaining(offset) {\n    if (offset \u003c 0 || offset \u003e= this.elements.length) {\n      return void 0;\n    }\n    if (!isWordChar(this.elements[offset])) {\n      return void 0;\n    }\n    let start = offset;\n    while (start \u003e 0 \u0026\u0026 isWordChar(this.elements[start - 1])) {\n      start--;\n    }\n    let end = offset;\n    while (end \u003c this.elements.length \u0026\u0026 isWordChar(this.elements[end])) {\n      end++;\n    }\n    return new OffsetRange(start, end);\n  }\n  countLinesIn(range) {\n    return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n  }\n  isStronglyEqual(offset1, offset2) {\n    return this.elements[offset1] === this.elements[offset2];\n  }\n  extendToFullLines(range) {\n    const start = findLastMonotonous(this.firstElementOffsetByLineIdx, (x) =\u003e x \u003c= range.start) ?? 0;\n    const end = findFirstMonotonous(this.firstElementOffsetByLineIdx, (x) =\u003e range.endExclusive \u003c= x) ?? this.elements.length;\n    return new OffsetRange(start, end);\n  }\n};\nfunction isWordChar(charCode) {\n  return charCode \u003e= 97 \u0026\u0026 charCode \u003c= 122 || charCode \u003e= 65 \u0026\u0026 charCode \u003c= 90 || charCode \u003e= 48 \u0026\u0026 charCode \u003c= 57;\n}\nvar score = {\n  [\n    0\n    /* CharBoundaryCategory.WordLower */\n  ]: 0,\n  [\n    1\n    /* CharBoundaryCategory.WordUpper */\n  ]: 0,\n  [\n    2\n    /* CharBoundaryCategory.WordNumber */\n  ]: 0,\n  [\n    3\n    /* CharBoundaryCategory.End */\n  ]: 10,\n  [\n    4\n    /* CharBoundaryCategory.Other */\n  ]: 2,\n  [\n    5\n    /* CharBoundaryCategory.Separator */\n  ]: 30,\n  [\n    6\n    /* CharBoundaryCategory.Space */\n  ]: 3,\n  [\n    7\n    /* CharBoundaryCategory.LineBreakCR */\n  ]: 10,\n  [\n    8\n    /* CharBoundaryCategory.LineBreakLF */\n  ]: 10\n};\nfunction getCategoryBoundaryScore(category) {\n  return score[category];\n}\nfunction getCategory(charCode) {\n  if (charCode === 10) {\n    return 8;\n  } else if (charCode === 13) {\n    return 7;\n  } else if (isSpace(charCode)) {\n    return 6;\n  } else if (charCode \u003e= 97 \u0026\u0026 charCode \u003c= 122) {\n    return 0;\n  } else if (charCode \u003e= 65 \u0026\u0026 charCode \u003c= 90) {\n    return 1;\n  } else if (charCode \u003e= 48 \u0026\u0026 charCode \u003c= 57) {\n    return 2;\n  } else if (charCode === -1) {\n    return 3;\n  } else if (charCode === 44 || charCode === 59) {\n    return 5;\n  } else {\n    return 4;\n  }\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js\nfunction computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n  let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n  if (!timeout.isValid()) {\n    return [];\n  }\n  const filteredChanges = changes.filter((c) =\u003e !excludedChanges.has(c));\n  const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n  pushMany(moves, unchangedMoves);\n  moves = joinCloseConsecutiveMoves(moves);\n  moves = moves.filter((current) =\u003e {\n    const lines = current.original.toOffsetRange().slice(originalLines).map((l) =\u003e l.trim());\n    const originalText = lines.join(\"\\n\");\n    return originalText.length \u003e= 15 \u0026\u0026 countWhere(lines, (l) =\u003e l.length \u003e= 2) \u003e= 2;\n  });\n  moves = removeMovesInSameDiff(changes, moves);\n  return moves;\n}\nfunction countWhere(arr, predicate) {\n  let count = 0;\n  for (const t of arr) {\n    if (predicate(t)) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n  const moves = [];\n  const deletions = changes.filter((c) =\u003e c.modified.isEmpty \u0026\u0026 c.original.length \u003e= 3).map((d) =\u003e new LineRangeFragment(d.original, originalLines, d));\n  const insertions = new Set(changes.filter((c) =\u003e c.original.isEmpty \u0026\u0026 c.modified.length \u003e= 3).map((d) =\u003e new LineRangeFragment(d.modified, modifiedLines, d)));\n  const excludedChanges = /* @__PURE__ */ new Set();\n  for (const deletion of deletions) {\n    let highestSimilarity = -1;\n    let best;\n    for (const insertion of insertions) {\n      const similarity = deletion.computeSimilarity(insertion);\n      if (similarity \u003e highestSimilarity) {\n        highestSimilarity = similarity;\n        best = insertion;\n      }\n    }\n    if (highestSimilarity \u003e 0.9 \u0026\u0026 best) {\n      insertions.delete(best);\n      moves.push(new LineRangeMapping(deletion.range, best.range));\n      excludedChanges.add(deletion.source);\n      excludedChanges.add(best.source);\n    }\n    if (!timeout.isValid()) {\n      return { moves, excludedChanges };\n    }\n  }\n  return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n  const moves = [];\n  const original3LineHashes = new SetMap();\n  for (const change of changes) {\n    for (let i = change.original.startLineNumber; i \u003c change.original.endLineNumberExclusive - 2; i++) {\n      const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n      original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n    }\n  }\n  const possibleMappings = [];\n  changes.sort(compareBy((c) =\u003e c.modified.startLineNumber, numberComparator));\n  for (const change of changes) {\n    let lastMappings = [];\n    for (let i = change.modified.startLineNumber; i \u003c change.modified.endLineNumberExclusive - 2; i++) {\n      const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n      const currentModifiedRange = new LineRange(i, i + 3);\n      const nextMappings = [];\n      original3LineHashes.forEach(key, ({ range }) =\u003e {\n        for (const lastMapping of lastMappings) {\n          if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive \u0026\u0026 lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n            lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n            lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n            nextMappings.push(lastMapping);\n            return;\n          }\n        }\n        const mapping = {\n          modifiedLineRange: currentModifiedRange,\n          originalLineRange: range\n        };\n        possibleMappings.push(mapping);\n        nextMappings.push(mapping);\n      });\n      lastMappings = nextMappings;\n    }\n    if (!timeout.isValid()) {\n      return [];\n    }\n  }\n  possibleMappings.sort(reverseOrder(compareBy((m) =\u003e m.modifiedLineRange.length, numberComparator)));\n  const modifiedSet = new LineRangeSet();\n  const originalSet = new LineRangeSet();\n  for (const mapping of possibleMappings) {\n    const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n    const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n    const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n    const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n    for (const s of modifiedIntersectedSections.ranges) {\n      if (s.length \u003c 3) {\n        continue;\n      }\n      const modifiedLineRange = s;\n      const originalLineRange = s.delta(-diffOrigToMod);\n      moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n      modifiedSet.addRange(modifiedLineRange);\n      originalSet.addRange(originalLineRange);\n    }\n  }\n  moves.sort(compareBy((m) =\u003e m.original.startLineNumber, numberComparator));\n  const monotonousChanges = new MonotonousArray(changes);\n  for (let i = 0; i \u003c moves.length; i++) {\n    const move = moves[i];\n    const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) =\u003e c.original.startLineNumber \u003c= move.original.startLineNumber);\n    const firstTouchingChangeMod = findLastMonotonous(changes, (c) =\u003e c.modified.startLineNumber \u003c= move.modified.startLineNumber);\n    const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n    const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) =\u003e c.original.startLineNumber \u003c move.original.endLineNumberExclusive);\n    const lastTouchingChangeMod = findLastMonotonous(changes, (c) =\u003e c.modified.startLineNumber \u003c move.modified.endLineNumberExclusive);\n    const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n    let extendToTop;\n    for (extendToTop = 0; extendToTop \u003c linesAbove; extendToTop++) {\n      const origLine = move.original.startLineNumber - extendToTop - 1;\n      const modLine = move.modified.startLineNumber - extendToTop - 1;\n      if (origLine \u003e originalLines.length || modLine \u003e modifiedLines.length) {\n        break;\n      }\n      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n        break;\n      }\n      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n        break;\n      }\n    }\n    if (extendToTop \u003e 0) {\n      originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n      modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n    }\n    let extendToBottom;\n    for (extendToBottom = 0; extendToBottom \u003c linesBelow; extendToBottom++) {\n      const origLine = move.original.endLineNumberExclusive + extendToBottom;\n      const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n      if (origLine \u003e originalLines.length || modLine \u003e modifiedLines.length) {\n        break;\n      }\n      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n        break;\n      }\n      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n        break;\n      }\n    }\n    if (extendToBottom \u003e 0) {\n      originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n      modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n    }\n    if (extendToTop \u003e 0 || extendToBottom \u003e 0) {\n      moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n    }\n  }\n  return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n  if (line1.trim() === line2.trim()) {\n    return true;\n  }\n  if (line1.length \u003e 300 \u0026\u0026 line2.length \u003e 300) {\n    return false;\n  }\n  const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false), new LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false), timeout);\n  let commonNonSpaceCharCount = 0;\n  const inverted = SequenceDiff.invert(result.diffs, line1.length);\n  for (const seq of inverted) {\n    seq.seq1Range.forEach((idx) =\u003e {\n      if (!isSpace(line1.charCodeAt(idx))) {\n        commonNonSpaceCharCount++;\n      }\n    });\n  }\n  function countNonWsChars(str) {\n    let count = 0;\n    for (let i = 0; i \u003c line1.length; i++) {\n      if (!isSpace(str.charCodeAt(i))) {\n        count++;\n      }\n    }\n    return count;\n  }\n  const longerLineLength = countNonWsChars(line1.length \u003e line2.length ? line1 : line2);\n  const r = commonNonSpaceCharCount / longerLineLength \u003e 0.6 \u0026\u0026 longerLineLength \u003e 10;\n  return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n  if (moves.length === 0) {\n    return moves;\n  }\n  moves.sort(compareBy((m) =\u003e m.original.startLineNumber, numberComparator));\n  const result = [moves[0]];\n  for (let i = 1; i \u003c moves.length; i++) {\n    const last = result[result.length - 1];\n    const current = moves[i];\n    const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n    const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n    const currentMoveAfterLast = originalDist \u003e= 0 \u0026\u0026 modifiedDist \u003e= 0;\n    if (currentMoveAfterLast \u0026\u0026 originalDist + modifiedDist \u003c= 2) {\n      result[result.length - 1] = last.join(current);\n      continue;\n    }\n    result.push(current);\n  }\n  return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n  const changesMonotonous = new MonotonousArray(changes);\n  moves = moves.filter((m) =\u003e {\n    const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous((c) =\u003e c.original.startLineNumber \u003c m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n    const diffBeforeEndOfMoveModified = findLastMonotonous(changes, (c) =\u003e c.modified.startLineNumber \u003c m.modified.endLineNumberExclusive);\n    const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n    return differentDiffs;\n  });\n  return moves;\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js\nfunction optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  let result = sequenceDiffs;\n  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n  result = shiftSequenceDiffs(sequence1, sequence2, result);\n  return result;\n}\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n  if (sequenceDiffs.length === 0) {\n    return sequenceDiffs;\n  }\n  const result = [];\n  result.push(sequenceDiffs[0]);\n  for (let i = 1; i \u003c sequenceDiffs.length; i++) {\n    const prevResult = result[result.length - 1];\n    let cur = sequenceDiffs[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n      let d;\n      for (d = 1; d \u003c= length; d++) {\n        if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n          break;\n        }\n      }\n      d--;\n      if (d === length) {\n        result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n        continue;\n      }\n      cur = cur.delta(-d);\n    }\n    result.push(cur);\n  }\n  const result2 = [];\n  for (let i = 0; i \u003c result.length - 1; i++) {\n    const nextResult = result[i + 1];\n    let cur = result[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n      let d;\n      for (d = 0; d \u003c length; d++) {\n        if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) || !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n          break;\n        }\n      }\n      if (d === length) {\n        result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n        continue;\n      }\n      if (d \u003e 0) {\n        cur = cur.delta(d);\n      }\n    }\n    result2.push(cur);\n  }\n  if (result.length \u003e 0) {\n    result2.push(result[result.length - 1]);\n  }\n  return result2;\n}\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n    return sequenceDiffs;\n  }\n  for (let i = 0; i \u003c sequenceDiffs.length; i++) {\n    const prevDiff = i \u003e 0 ? sequenceDiffs[i - 1] : void 0;\n    const diff = sequenceDiffs[i];\n    const nextDiff = i + 1 \u003c sequenceDiffs.length ? sequenceDiffs[i + 1] : void 0;\n    const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n    const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n    if (diff.seq1Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n    } else if (diff.seq2Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n    }\n  }\n  return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n  const maxShiftLimit = 100;\n  let deltaBefore = 1;\n  while (diff.seq1Range.start - deltaBefore \u003e= seq1ValidRange.start \u0026\u0026 diff.seq2Range.start - deltaBefore \u003e= seq2ValidRange.start \u0026\u0026 sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) \u0026\u0026 deltaBefore \u003c maxShiftLimit) {\n    deltaBefore++;\n  }\n  deltaBefore--;\n  let deltaAfter = 0;\n  while (diff.seq1Range.start + deltaAfter \u003c seq1ValidRange.endExclusive \u0026\u0026 diff.seq2Range.endExclusive + deltaAfter \u003c seq2ValidRange.endExclusive \u0026\u0026 sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) \u0026\u0026 deltaAfter \u003c maxShiftLimit) {\n    deltaAfter++;\n  }\n  if (deltaBefore === 0 \u0026\u0026 deltaAfter === 0) {\n    return diff;\n  }\n  let bestDelta = 0;\n  let bestScore = -1;\n  for (let delta = -deltaBefore; delta \u003c= deltaAfter; delta++) {\n    const seq2OffsetStart = diff.seq2Range.start + delta;\n    const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n    const seq1Offset = diff.seq1Range.start + delta;\n    const score2 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n    if (score2 \u003e bestScore) {\n      bestScore = score2;\n      bestDelta = delta;\n    }\n  }\n  return diff.delta(bestDelta);\n}\nfunction removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n  const result = [];\n  for (const s of sequenceDiffs) {\n    const last = result[result.length - 1];\n    if (!last) {\n      result.push(s);\n      continue;\n    }\n    if (s.seq1Range.start - last.seq1Range.endExclusive \u003c= 2 || s.seq2Range.start - last.seq2Range.endExclusive \u003c= 2) {\n      result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n    } else {\n      result.push(s);\n    }\n  }\n  return result;\n}\nfunction extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n  const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n  const additional = [];\n  let lastPoint = new OffsetPair(0, 0);\n  function scanWord(pair, equalMapping) {\n    if (pair.offset1 \u003c lastPoint.offset1 || pair.offset2 \u003c lastPoint.offset2) {\n      return;\n    }\n    const w1 = sequence1.findWordContaining(pair.offset1);\n    const w2 = sequence2.findWordContaining(pair.offset2);\n    if (!w1 || !w2) {\n      return;\n    }\n    let w = new SequenceDiff(w1, w2);\n    const equalPart = w.intersect(equalMapping);\n    let equalChars1 = equalPart.seq1Range.length;\n    let equalChars2 = equalPart.seq2Range.length;\n    while (equalMappings.length \u003e 0) {\n      const next = equalMappings[0];\n      const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n      if (!intersects) {\n        break;\n      }\n      const v1 = sequence1.findWordContaining(next.seq1Range.start);\n      const v2 = sequence2.findWordContaining(next.seq2Range.start);\n      const v = new SequenceDiff(v1, v2);\n      const equalPart2 = v.intersect(next);\n      equalChars1 += equalPart2.seq1Range.length;\n      equalChars2 += equalPart2.seq2Range.length;\n      w = w.join(v);\n      if (w.seq1Range.endExclusive \u003e= next.seq1Range.endExclusive) {\n        equalMappings.shift();\n      } else {\n        break;\n      }\n    }\n    if (equalChars1 + equalChars2 \u003c (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n      additional.push(w);\n    }\n    lastPoint = w.getEndExclusives();\n  }\n  while (equalMappings.length \u003e 0) {\n    const next = equalMappings.shift();\n    if (next.seq1Range.isEmpty) {\n      continue;\n    }\n    scanWord(next.getStarts(), next);\n    scanWord(next.getEndExclusives().delta(-1), next);\n  }\n  const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n  return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n  const result = [];\n  while (sequenceDiffs1.length \u003e 0 || sequenceDiffs2.length \u003e 0) {\n    const sd1 = sequenceDiffs1[0];\n    const sd2 = sequenceDiffs2[0];\n    let next;\n    if (sd1 \u0026\u0026 (!sd2 || sd1.seq1Range.start \u003c sd2.seq1Range.start)) {\n      next = sequenceDiffs1.shift();\n    } else {\n      next = sequenceDiffs2.shift();\n    }\n    if (result.length \u003e 0 \u0026\u0026 result[result.length - 1].seq1Range.endExclusive \u003e= next.seq1Range.start) {\n      result[result.length - 1] = result[result.length - 1].join(next);\n    } else {\n      result.push(next);\n    }\n  }\n  return result;\n}\nfunction removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n  let diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  let counter = 0;\n  let shouldRepeat;\n  do {\n    shouldRepeat = false;\n    const result = [\n      diffs[0]\n    ];\n    for (let i = 1; i \u003c diffs.length; i++) {\n      let shouldJoinDiffs = function(before, after) {\n        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        const unchangedText = sequence1.getText(unchangedRange);\n        const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, \"\");\n        if (unchangedTextWithoutWs.length \u003c= 4 \u0026\u0026 (before.seq1Range.length + before.seq2Range.length \u003e 5 || after.seq1Range.length + after.seq2Range.length \u003e 5)) {\n          return true;\n        }\n        return false;\n      };\n      const cur = diffs[i];\n      const lastResult = result[result.length - 1];\n      const shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    }\n    diffs = result;\n  } while (counter++ \u003c 10 \u0026\u0026 shouldRepeat);\n  return diffs;\n}\nfunction removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n  let diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  let counter = 0;\n  let shouldRepeat;\n  do {\n    shouldRepeat = false;\n    const result = [\n      diffs[0]\n    ];\n    for (let i = 1; i \u003c diffs.length; i++) {\n      let shouldJoinDiffs = function(before, after) {\n        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n        if (unchangedLineCount \u003e 5 || unchangedRange.length \u003e 500) {\n          return false;\n        }\n        const unchangedText = sequence1.getText(unchangedRange).trim();\n        if (unchangedText.length \u003e 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length \u003e 1) {\n          return false;\n        }\n        const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n        const beforeSeq1Length = before.seq1Range.length;\n        const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n        const beforeSeq2Length = before.seq2Range.length;\n        const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n        const afterSeq1Length = after.seq1Range.length;\n        const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n        const afterSeq2Length = after.seq2Range.length;\n        const max = 2 * 40 + 50;\n        function cap(v) {\n          return Math.min(v, max);\n        }\n        if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) \u003e (max ** 1.5) ** 1.5 * 1.3) {\n          return true;\n        }\n        return false;\n      };\n      const cur = diffs[i];\n      const lastResult = result[result.length - 1];\n      const shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    }\n    diffs = result;\n  } while (counter++ \u003c 10 \u0026\u0026 shouldRepeat);\n  const newDiffs = [];\n  forEachWithNeighbors(diffs, (prev, cur, next) =\u003e {\n    let newDiff = cur;\n    function shouldMarkAsChanged(text) {\n      return text.length \u003e 0 \u0026\u0026 text.trim().length \u003c= 3 \u0026\u0026 cur.seq1Range.length + cur.seq2Range.length \u003e 100;\n    }\n    const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n    const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n    if (shouldMarkAsChanged(prefix)) {\n      newDiff = newDiff.deltaStart(-prefix.length);\n    }\n    const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n    if (shouldMarkAsChanged(suffix)) {\n      newDiff = newDiff.deltaEnd(suffix.length);\n    }\n    const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n    const result = newDiff.intersect(availableSpace);\n    if (newDiffs.length \u003e 0 \u0026\u0026 result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n      newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n    } else {\n      newDiffs.push(result);\n    }\n  });\n  return newDiffs;\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js\nvar LineSequence2 = class {\n  constructor(trimmedHash, lines) {\n    this.trimmedHash = trimmedHash;\n    this.lines = lines;\n  }\n  getElement(offset) {\n    return this.trimmedHash[offset];\n  }\n  get length() {\n    return this.trimmedHash.length;\n  }\n  getBoundaryScore(length) {\n    const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n    const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n    return 1e3 - (indentationBefore + indentationAfter);\n  }\n  getText(range) {\n    return this.lines.slice(range.start, range.endExclusive).join(\"\\n\");\n  }\n  isStronglyEqual(offset1, offset2) {\n    return this.lines[offset1] === this.lines[offset2];\n  }\n};\nfunction getIndentation(str) {\n  let i = 0;\n  while (i \u003c str.length \u0026\u0026 (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {\n    i++;\n  }\n  return i;\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js\nvar DefaultLinesDiffComputer = class {\n  constructor() {\n    this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n    this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  }\n  computeDiff(originalLines, modifiedLines, options) {\n    if (originalLines.length \u003c= 1 \u0026\u0026 equals2(originalLines, modifiedLines, (a, b) =\u003e a === b)) {\n      return new LinesDiff([], [], false);\n    }\n    if (originalLines.length === 1 \u0026\u0026 originalLines[0].length === 0 || modifiedLines.length === 1 \u0026\u0026 modifiedLines[0].length === 0) {\n      return new LinesDiff([\n        new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n          new RangeMapping(new Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))\n        ])\n      ], [], false);\n    }\n    const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n    const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n    const perfectHashes = /* @__PURE__ */ new Map();\n    function getOrCreateHash(text) {\n      let hash = perfectHashes.get(text);\n      if (hash === void 0) {\n        hash = perfectHashes.size;\n        perfectHashes.set(text, hash);\n      }\n      return hash;\n    }\n    const originalLinesHashes = originalLines.map((l) =\u003e getOrCreateHash(l.trim()));\n    const modifiedLinesHashes = modifiedLines.map((l) =\u003e getOrCreateHash(l.trim()));\n    const sequence1 = new LineSequence2(originalLinesHashes, originalLines);\n    const sequence2 = new LineSequence2(modifiedLinesHashes, modifiedLines);\n    const lineAlignmentResult = (() =\u003e {\n      if (sequence1.length + sequence2.length \u003c 1700) {\n        return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) =\u003e originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);\n      }\n      return this.myersDiffingAlgorithm.compute(sequence1, sequence2, timeout);\n    })();\n    let lineAlignments = lineAlignmentResult.diffs;\n    let hitTimeout = lineAlignmentResult.hitTimeout;\n    lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n    lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n    const alignments = [];\n    const scanForWhitespaceChanges = (equalLinesCount) =\u003e {\n      if (!considerWhitespaceChanges) {\n        return;\n      }\n      for (let i = 0; i \u003c equalLinesCount; i++) {\n        const seq1Offset = seq1LastStart + i;\n        const seq2Offset = seq2LastStart + i;\n        if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n          const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n          for (const a of characterDiffs.mappings) {\n            alignments.push(a);\n          }\n          if (characterDiffs.hitTimeout) {\n            hitTimeout = true;\n          }\n        }\n      }\n    };\n    let seq1LastStart = 0;\n    let seq2LastStart = 0;\n    for (const diff of lineAlignments) {\n      assertFn(() =\u003e diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n      const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n      scanForWhitespaceChanges(equalLinesCount);\n      seq1LastStart = diff.seq1Range.endExclusive;\n      seq2LastStart = diff.seq2Range.endExclusive;\n      const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n      if (characterDiffs.hitTimeout) {\n        hitTimeout = true;\n      }\n      for (const a of characterDiffs.mappings) {\n        alignments.push(a);\n      }\n    }\n    scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n    const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n    let moves = [];\n    if (options.computeMoves) {\n      moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n    }\n    assertFn(() =\u003e {\n      function validatePosition(pos, lines) {\n        if (pos.lineNumber \u003c 1 || pos.lineNumber \u003e lines.length) {\n          return false;\n        }\n        const line = lines[pos.lineNumber - 1];\n        if (pos.column \u003c 1 || pos.column \u003e line.length + 1) {\n          return false;\n        }\n        return true;\n      }\n      function validateRange(range, lines) {\n        if (range.startLineNumber \u003c 1 || range.startLineNumber \u003e lines.length + 1) {\n          return false;\n        }\n        if (range.endLineNumberExclusive \u003c 1 || range.endLineNumberExclusive \u003e lines.length + 1) {\n          return false;\n        }\n        return true;\n      }\n      for (const c of changes) {\n        if (!c.innerChanges) {\n          return false;\n        }\n        for (const ic of c.innerChanges) {\n          const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) \u0026\u0026 validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) \u0026\u0026 validatePosition(ic.originalRange.getStartPosition(), originalLines) \u0026\u0026 validatePosition(ic.originalRange.getEndPosition(), originalLines);\n          if (!valid) {\n            return false;\n          }\n        }\n        if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n          return false;\n        }\n      }\n      return true;\n    });\n    return new LinesDiff(changes, moves, hitTimeout);\n  }\n  computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n    const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n    const movesWithDiffs = moves.map((m) =\u003e {\n      const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n      const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n      return new MovedText(m, mappings);\n    });\n    return movesWithDiffs;\n  }\n  refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n    const lineRangeMapping = toLineRangeMapping(diff);\n    const rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);\n    const slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);\n    const slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);\n    const diffResult = slice1.length + slice2.length \u003c 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n    const check = false;\n    let diffs = diffResult.diffs;\n    if (check) {\n      SequenceDiff.assertSorted(diffs);\n    }\n    diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n    if (check) {\n      SequenceDiff.assertSorted(diffs);\n    }\n    diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n    if (check) {\n      SequenceDiff.assertSorted(diffs);\n    }\n    diffs = removeShortMatches(slice1, slice2, diffs);\n    if (check) {\n      SequenceDiff.assertSorted(diffs);\n    }\n    diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n    if (check) {\n      SequenceDiff.assertSorted(diffs);\n    }\n    const result = diffs.map((d) =\u003e new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n    if (check) {\n      RangeMapping.assertSorted(result);\n    }\n    return {\n      mappings: result,\n      hitTimeout: diffResult.hitTimeout\n    };\n  }\n};\nfunction lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n  const changes = [];\n  for (const g of groupAdjacentBy(alignments.map((a) =\u003e getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) =\u003e a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified))) {\n    const first = g[0];\n    const last = g[g.length - 1];\n    changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map((a) =\u003e a.innerChanges[0])));\n  }\n  assertFn(() =\u003e {\n    if (!dontAssertStartLine \u0026\u0026 changes.length \u003e 0) {\n      if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n        return false;\n      }\n      if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\n        return false;\n      }\n    }\n    return checkAdjacentItems(changes, (m1, m2) =\u003e m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive \u0026\u0026 // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n    m1.original.endLineNumberExclusive \u003c m2.original.startLineNumber \u0026\u0026 m1.modified.endLineNumberExclusive \u003c m2.modified.startLineNumber);\n  });\n  return changes;\n}\nfunction getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n  let lineStartDelta = 0;\n  let lineEndDelta = 0;\n  if (rangeMapping.modifiedRange.endColumn === 1 \u0026\u0026 rangeMapping.originalRange.endColumn === 1 \u0026\u0026 rangeMapping.originalRange.startLineNumber + lineStartDelta \u003c= rangeMapping.originalRange.endLineNumber \u0026\u0026 rangeMapping.modifiedRange.startLineNumber + lineStartDelta \u003c= rangeMapping.modifiedRange.endLineNumber) {\n    lineEndDelta = -1;\n  }\n  if (rangeMapping.modifiedRange.startColumn - 1 \u003e= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length \u0026\u0026 rangeMapping.originalRange.startColumn - 1 \u003e= originalLines[rangeMapping.originalRange.startLineNumber - 1].length \u0026\u0026 rangeMapping.originalRange.startLineNumber \u003c= rangeMapping.originalRange.endLineNumber + lineEndDelta \u0026\u0026 rangeMapping.modifiedRange.startLineNumber \u003c= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n    lineStartDelta = 1;\n  }\n  const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n  const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n  return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\nfunction toLineRangeMapping(sequenceDiff) {\n  return new LineRangeMapping(new LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1), new LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1));\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js\nvar linesDiffComputers = {\n  getLegacy: () =\u003e new LegacyLinesDiffComputer(),\n  getDefault: () =\u003e new DefaultLinesDiffComputer()\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/color.js\nfunction roundFloat(number, decimalPoints) {\n  const decimal = Math.pow(10, decimalPoints);\n  return Math.round(number * decimal) / decimal;\n}\nvar RGBA = class {\n  constructor(r, g, b, a = 1) {\n    this._rgbaBrand = void 0;\n    this.r = Math.min(255, Math.max(0, r)) | 0;\n    this.g = Math.min(255, Math.max(0, g)) | 0;\n    this.b = Math.min(255, Math.max(0, b)) | 0;\n    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n  }\n  static equals(a, b) {\n    return a.r === b.r \u0026\u0026 a.g === b.g \u0026\u0026 a.b === b.b \u0026\u0026 a.a === b.a;\n  }\n};\nvar HSLA = class _HSLA {\n  constructor(h, s, l, a) {\n    this._hslaBrand = void 0;\n    this.h = Math.max(Math.min(360, h), 0) | 0;\n    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n    this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);\n    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n  }\n  static equals(a, b) {\n    return a.h === b.h \u0026\u0026 a.s === b.s \u0026\u0026 a.l === b.l \u0026\u0026 a.a === b.a;\n  }\n  /**\n   * Converts an RGB color value to HSL. Conversion formula\n   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n   * Assumes r, g, and b are contained in the set [0, 255] and\n   * returns h in the set [0, 360], s, and l in the set [0, 1].\n   */\n  static fromRGBA(rgba) {\n    const r = rgba.r / 255;\n    const g = rgba.g / 255;\n    const b = rgba.b / 255;\n    const a = rgba.a;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h = 0;\n    let s = 0;\n    const l = (min + max) / 2;\n    const chroma = max - min;\n    if (chroma \u003e 0) {\n      s = Math.min(l \u003c= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);\n      switch (max) {\n        case r:\n          h = (g - b) / chroma + (g \u003c b ? 6 : 0);\n          break;\n        case g:\n          h = (b - r) / chroma + 2;\n          break;\n        case b:\n          h = (r - g) / chroma + 4;\n          break;\n      }\n      h *= 60;\n      h = Math.round(h);\n    }\n    return new _HSLA(h, s, l, a);\n  }\n  static _hue2rgb(p, q, t) {\n    if (t \u003c 0) {\n      t += 1;\n    }\n    if (t \u003e 1) {\n      t -= 1;\n    }\n    if (t \u003c 1 / 6) {\n      return p + (q - p) * 6 * t;\n    }\n    if (t \u003c 1 / 2) {\n      return q;\n    }\n    if (t \u003c 2 / 3) {\n      return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n  }\n  /**\n   * Converts an HSL color value to RGB. Conversion formula\n   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and\n   * returns r, g, and b in the set [0, 255].\n   */\n  static toRGBA(hsla) {\n    const h = hsla.h / 360;\n    const { s, l, a } = hsla;\n    let r, g, b;\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const q = l \u003c 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = _HSLA._hue2rgb(p, q, h + 1 / 3);\n      g = _HSLA._hue2rgb(p, q, h);\n      b = _HSLA._hue2rgb(p, q, h - 1 / 3);\n    }\n    return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);\n  }\n};\nvar HSVA = class _HSVA {\n  constructor(h, s, v, a) {\n    this._hsvaBrand = void 0;\n    this.h = Math.max(Math.min(360, h), 0) | 0;\n    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n    this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);\n    this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n  }\n  static equals(a, b) {\n    return a.h === b.h \u0026\u0026 a.s === b.s \u0026\u0026 a.v === b.v \u0026\u0026 a.a === b.a;\n  }\n  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm\n  static fromRGBA(rgba) {\n    const r = rgba.r / 255;\n    const g = rgba.g / 255;\n    const b = rgba.b / 255;\n    const cmax = Math.max(r, g, b);\n    const cmin = Math.min(r, g, b);\n    const delta = cmax - cmin;\n    const s = cmax === 0 ? 0 : delta / cmax;\n    let m;\n    if (delta === 0) {\n      m = 0;\n    } else if (cmax === r) {\n      m = ((g - b) / delta % 6 + 6) % 6;\n    } else if (cmax === g) {\n      m = (b - r) / delta + 2;\n    } else {\n      m = (r - g) / delta + 4;\n    }\n    return new _HSVA(Math.round(m * 60), s, cmax, rgba.a);\n  }\n  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm\n  static toRGBA(hsva) {\n    const { h, s, v, a } = hsva;\n    const c = v * s;\n    const x = c * (1 - Math.abs(h / 60 % 2 - 1));\n    const m = v - c;\n    let [r, g, b] = [0, 0, 0];\n    if (h \u003c 60) {\n      r = c;\n      g = x;\n    } else if (h \u003c 120) {\n      r = x;\n      g = c;\n    } else if (h \u003c 180) {\n      g = c;\n      b = x;\n    } else if (h \u003c 240) {\n      g = x;\n      b = c;\n    } else if (h \u003c 300) {\n      r = x;\n      b = c;\n    } else if (h \u003c= 360) {\n      r = c;\n      b = x;\n    }\n    r = Math.round((r + m) * 255);\n    g = Math.round((g + m) * 255);\n    b = Math.round((b + m) * 255);\n    return new RGBA(r, g, b, a);\n  }\n};\nvar Color = class _Color {\n  static fromHex(hex) {\n    return _Color.Format.CSS.parseHex(hex) || _Color.red;\n  }\n  static equals(a, b) {\n    if (!a \u0026\u0026 !b) {\n      return true;\n    }\n    if (!a || !b) {\n      return false;\n    }\n    return a.equals(b);\n  }\n  get hsla() {\n    if (this._hsla) {\n      return this._hsla;\n    } else {\n      return HSLA.fromRGBA(this.rgba);\n    }\n  }\n  get hsva() {\n    if (this._hsva) {\n      return this._hsva;\n    }\n    return HSVA.fromRGBA(this.rgba);\n  }\n  constructor(arg) {\n    if (!arg) {\n      throw new Error(\"Color needs a value\");\n    } else if (arg instanceof RGBA) {\n      this.rgba = arg;\n    } else if (arg instanceof HSLA) {\n      this._hsla = arg;\n      this.rgba = HSLA.toRGBA(arg);\n    } else if (arg instanceof HSVA) {\n      this._hsva = arg;\n      this.rgba = HSVA.toRGBA(arg);\n    } else {\n      throw new Error(\"Invalid color ctor argument\");\n    }\n  }\n  equals(other) {\n    return !!other \u0026\u0026 RGBA.equals(this.rgba, other.rgba) \u0026\u0026 HSLA.equals(this.hsla, other.hsla) \u0026\u0026 HSVA.equals(this.hsva, other.hsva);\n  }\n  /**\n   * http://www.w3.org/TR/WCAG20/#relativeluminancedef\n   * Returns the number in the set [0, 1]. O =\u003e Darkest Black. 1 =\u003e Lightest white.\n   */\n  getRelativeLuminance() {\n    const R = _Color._relativeLuminanceForComponent(this.rgba.r);\n    const G = _Color._relativeLuminanceForComponent(this.rgba.g);\n    const B = _Color._relativeLuminanceForComponent(this.rgba.b);\n    const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;\n    return roundFloat(luminance, 4);\n  }\n  static _relativeLuminanceForComponent(color) {\n    const c = color / 255;\n    return c \u003c= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);\n  }\n  /**\n   *\thttp://24ways.org/2010/calculating-color-contrast\n   *  Return 'true' if lighter color otherwise 'false'\n   */\n  isLighter() {\n    const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;\n    return yiq \u003e= 128;\n  }\n  isLighterThan(another) {\n    const lum1 = this.getRelativeLuminance();\n    const lum2 = another.getRelativeLuminance();\n    return lum1 \u003e lum2;\n  }\n  isDarkerThan(another) {\n    const lum1 = this.getRelativeLuminance();\n    const lum2 = another.getRelativeLuminance();\n    return lum1 \u003c lum2;\n  }\n  lighten(factor) {\n    return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));\n  }\n  darken(factor) {\n    return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));\n  }\n  transparent(factor) {\n    const { r, g, b, a } = this.rgba;\n    return new _Color(new RGBA(r, g, b, a * factor));\n  }\n  isTransparent() {\n    return this.rgba.a === 0;\n  }\n  isOpaque() {\n    return this.rgba.a === 1;\n  }\n  opposite() {\n    return new _Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));\n  }\n  makeOpaque(opaqueBackground) {\n    if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {\n      return this;\n    }\n    const { r, g, b, a } = this.rgba;\n    return new _Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));\n  }\n  toString() {\n    if (!this._toString) {\n      this._toString = _Color.Format.CSS.format(this);\n    }\n    return this._toString;\n  }\n  static getLighterColor(of, relative2, factor) {\n    if (of.isLighterThan(relative2)) {\n      return of;\n    }\n    factor = factor ? factor : 0.5;\n    const lum1 = of.getRelativeLuminance();\n    const lum2 = relative2.getRelativeLuminance();\n    factor = factor * (lum2 - lum1) / lum2;\n    return of.lighten(factor);\n  }\n  static getDarkerColor(of, relative2, factor) {\n    if (of.isDarkerThan(relative2)) {\n      return of;\n    }\n    factor = factor ? factor : 0.5;\n    const lum1 = of.getRelativeLuminance();\n    const lum2 = relative2.getRelativeLuminance();\n    factor = factor * (lum1 - lum2) / lum1;\n    return of.darken(factor);\n  }\n  static {\n    this.white = new _Color(new RGBA(255, 255, 255, 1));\n  }\n  static {\n    this.black = new _Color(new RGBA(0, 0, 0, 1));\n  }\n  static {\n    this.red = new _Color(new RGBA(255, 0, 0, 1));\n  }\n  static {\n    this.blue = new _Color(new RGBA(0, 0, 255, 1));\n  }\n  static {\n    this.green = new _Color(new RGBA(0, 255, 0, 1));\n  }\n  static {\n    this.cyan = new _Color(new RGBA(0, 255, 255, 1));\n  }\n  static {\n    this.lightgrey = new _Color(new RGBA(211, 211, 211, 1));\n  }\n  static {\n    this.transparent = new _Color(new RGBA(0, 0, 0, 0));\n  }\n};\n(function(Color2) {\n  let Format;\n  (function(Format2) {\n    let CSS;\n    (function(CSS2) {\n      function formatRGB(color) {\n        if (color.rgba.a === 1) {\n          return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;\n        }\n        return Color2.Format.CSS.formatRGBA(color);\n      }\n      CSS2.formatRGB = formatRGB;\n      function formatRGBA(color) {\n        return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;\n      }\n      CSS2.formatRGBA = formatRGBA;\n      function formatHSL(color) {\n        if (color.hsla.a === 1) {\n          return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;\n        }\n        return Color2.Format.CSS.formatHSLA(color);\n      }\n      CSS2.formatHSL = formatHSL;\n      function formatHSLA(color) {\n        return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;\n      }\n      CSS2.formatHSLA = formatHSLA;\n      function _toTwoDigitHex(n) {\n        const r = n.toString(16);\n        return r.length !== 2 ? \"0\" + r : r;\n      }\n      function formatHex(color) {\n        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;\n      }\n      CSS2.formatHex = formatHex;\n      function formatHexA(color, compact = false) {\n        if (compact \u0026\u0026 color.rgba.a === 1) {\n          return Color2.Format.CSS.formatHex(color);\n        }\n        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;\n      }\n      CSS2.formatHexA = formatHexA;\n      function format(color) {\n        if (color.isOpaque()) {\n          return Color2.Format.CSS.formatHex(color);\n        }\n        return Color2.Format.CSS.formatRGBA(color);\n      }\n      CSS2.format = format;\n      function parseHex(hex) {\n        const length = hex.length;\n        if (length === 0) {\n          return null;\n        }\n        if (hex.charCodeAt(0) !== 35) {\n          return null;\n        }\n        if (length === 7) {\n          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n          return new Color2(new RGBA(r, g, b, 1));\n        }\n        if (length === 9) {\n          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n          const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));\n          return new Color2(new RGBA(r, g, b, a / 255));\n        }\n        if (length === 4) {\n          const r = _parseHexDigit(hex.charCodeAt(1));\n          const g = _parseHexDigit(hex.charCodeAt(2));\n          const b = _parseHexDigit(hex.charCodeAt(3));\n          return new Color2(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));\n        }\n        if (length === 5) {\n          const r = _parseHexDigit(hex.charCodeAt(1));\n          const g = _parseHexDigit(hex.charCodeAt(2));\n          const b = _parseHexDigit(hex.charCodeAt(3));\n          const a = _parseHexDigit(hex.charCodeAt(4));\n          return new Color2(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));\n        }\n        return null;\n      }\n      CSS2.parseHex = parseHex;\n      function _parseHexDigit(charCode) {\n        switch (charCode) {\n          case 48:\n            return 0;\n          case 49:\n            return 1;\n          case 50:\n            return 2;\n          case 51:\n            return 3;\n          case 52:\n            return 4;\n          case 53:\n            return 5;\n          case 54:\n            return 6;\n          case 55:\n            return 7;\n          case 56:\n            return 8;\n          case 57:\n            return 9;\n          case 97:\n            return 10;\n          case 65:\n            return 10;\n          case 98:\n            return 11;\n          case 66:\n            return 11;\n          case 99:\n            return 12;\n          case 67:\n            return 12;\n          case 100:\n            return 13;\n          case 68:\n            return 13;\n          case 101:\n            return 14;\n          case 69:\n            return 14;\n          case 102:\n            return 15;\n          case 70:\n            return 15;\n        }\n        return 0;\n      }\n    })(CSS = Format2.CSS || (Format2.CSS = {}));\n  })(Format = Color2.Format || (Color2.Format = {}));\n})(Color || (Color = {}));\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js\nfunction _parseCaptureGroups(captureGroups) {\n  const values = [];\n  for (const captureGroup of captureGroups) {\n    const parsedNumber = Number(captureGroup);\n    if (parsedNumber || parsedNumber === 0 \u0026\u0026 captureGroup.replace(/\\s/g, \"\") !== \"\") {\n      values.push(parsedNumber);\n    }\n  }\n  return values;\n}\nfunction _toIColor(r, g, b, a) {\n  return {\n    red: r / 255,\n    blue: b / 255,\n    green: g / 255,\n    alpha: a\n  };\n}\nfunction _findRange(model, match) {\n  const index = match.index;\n  const length = match[0].length;\n  if (!index) {\n    return;\n  }\n  const startPosition = model.positionAt(index);\n  const range = {\n    startLineNumber: startPosition.lineNumber,\n    startColumn: startPosition.column,\n    endLineNumber: startPosition.lineNumber,\n    endColumn: startPosition.column + length\n  };\n  return range;\n}\nfunction _findHexColorInformation(range, hexValue) {\n  if (!range) {\n    return;\n  }\n  const parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n  if (!parsedHexColor) {\n    return;\n  }\n  return {\n    range,\n    color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n  };\n}\nfunction _findRGBColorInformation(range, matches, isAlpha) {\n  if (!range || matches.length !== 1) {\n    return;\n  }\n  const match = matches[0];\n  const captureGroups = match.values();\n  const parsedRegex = _parseCaptureGroups(captureGroups);\n  return {\n    range,\n    color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n  };\n}\nfunction _findHSLColorInformation(range, matches, isAlpha) {\n  if (!range || matches.length !== 1) {\n    return;\n  }\n  const match = matches[0];\n  const captureGroups = match.values();\n  const parsedRegex = _parseCaptureGroups(captureGroups);\n  const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\n  return {\n    range,\n    color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n  };\n}\nfunction _findMatches(model, regex) {\n  if (typeof model === \"string\") {\n    return [...model.matchAll(regex)];\n  } else {\n    return model.findMatches(regex);\n  }\n}\nfunction computeColors(model) {\n  const result = [];\n  const initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|(#)([A-Fa-f0-9]{3})\\b|(#)([A-Fa-f0-9]{4})\\b|(#)([A-Fa-f0-9]{6})\\b|(#)([A-Fa-f0-9]{8})\\b/gm;\n  const initialValidationMatches = _findMatches(model, initialValidationRegex);\n  if (initialValidationMatches.length \u003e 0) {\n    for (const initialMatch of initialValidationMatches) {\n      const initialCaptureGroups = initialMatch.filter((captureGroup) =\u003e captureGroup !== void 0);\n      const colorScheme = initialCaptureGroups[1];\n      const colorParameters = initialCaptureGroups[2];\n      if (!colorParameters) {\n        continue;\n      }\n      let colorInformation;\n      if (colorScheme === \"rgb\") {\n        const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n        colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n      } else if (colorScheme === \"rgba\") {\n        const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n        colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n      } else if (colorScheme === \"hsl\") {\n        const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n        colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n      } else if (colorScheme === \"hsla\") {\n        const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n        colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n      } else if (colorScheme === \"#\") {\n        colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n      }\n      if (colorInformation) {\n        result.push(colorInformation);\n      }\n    }\n  }\n  return result;\n}\nfunction computeDefaultDocumentColors(model) {\n  if (!model || typeof model.getValue !== \"function\" || typeof model.positionAt !== \"function\") {\n    return [];\n  }\n  return computeColors(model);\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js\nvar markRegex = new RegExp(\"\\\\bMARK:\\\\s*(.*)$\", \"d\");\nvar trimDashesRegex = /^-+|-+$/g;\nfunction findSectionHeaders(model, options) {\n  let headers = [];\n  if (options.findRegionSectionHeaders \u0026\u0026 options.foldingRules?.markers) {\n    const regionHeaders = collectRegionHeaders(model, options);\n    headers = headers.concat(regionHeaders);\n  }\n  if (options.findMarkSectionHeaders) {\n    const markHeaders = collectMarkHeaders(model);\n    headers = headers.concat(markHeaders);\n  }\n  return headers;\n}\nfunction collectRegionHeaders(model, options) {\n  const regionHeaders = [];\n  const endLineNumber = model.getLineCount();\n  for (let lineNumber = 1; lineNumber \u003c= endLineNumber; lineNumber++) {\n    const lineContent = model.getLineContent(lineNumber);\n    const match = lineContent.match(options.foldingRules.markers.start);\n    if (match) {\n      const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };\n      if (range.endColumn \u003e range.startColumn) {\n        const sectionHeader = {\n          range,\n          ...getHeaderText(lineContent.substring(match[0].length)),\n          shouldBeInComments: false\n        };\n        if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n          regionHeaders.push(sectionHeader);\n        }\n      }\n    }\n  }\n  return regionHeaders;\n}\nfunction collectMarkHeaders(model) {\n  const markHeaders = [];\n  const endLineNumber = model.getLineCount();\n  for (let lineNumber = 1; lineNumber \u003c= endLineNumber; lineNumber++) {\n    const lineContent = model.getLineContent(lineNumber);\n    addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);\n  }\n  return markHeaders;\n}\nfunction addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {\n  markRegex.lastIndex = 0;\n  const match = markRegex.exec(lineContent);\n  if (match) {\n    const column = match.indices[1][0] + 1;\n    const endColumn = match.indices[1][1] + 1;\n    const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn };\n    if (range.endColumn \u003e range.startColumn) {\n      const sectionHeader = {\n        range,\n        ...getHeaderText(match[1]),\n        shouldBeInComments: true\n      };\n      if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n        sectionHeaders.push(sectionHeader);\n      }\n    }\n  }\n}\nfunction getHeaderText(text) {\n  text = text.trim();\n  const hasSeparatorLine = text.startsWith(\"-\");\n  text = text.replace(trimDashesRegex, \"\");\n  return { text, hasSeparatorLine };\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/symbols.js\nvar MicrotaskDelay = Symbol(\"MicrotaskDelay\");\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/base/common/async.js\nvar runWhenGlobalIdle;\nvar _runWhenIdle;\n(function() {\n  if (typeof globalThis.requestIdleCallback !== \"function\" || typeof globalThis.cancelIdleCallback !== \"function\") {\n    _runWhenIdle = (_targetWindow, runner) =\u003e {\n      setTimeout0(() =\u003e {\n        if (disposed) {\n          return;\n        }\n        const end = Date.now() + 15;\n        const deadline = {\n          didTimeout: true,\n          timeRemaining() {\n            return Math.max(0, end - Date.now());\n          }\n        };\n        runner(Object.freeze(deadline));\n      });\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n          disposed = true;\n        }\n      };\n    };\n  } else {\n    _runWhenIdle = (targetWindow, runner, timeout) =\u003e {\n      const handle = targetWindow.requestIdleCallback(runner, typeof timeout === \"number\" ? { timeout } : void 0);\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n          disposed = true;\n          targetWindow.cancelIdleCallback(handle);\n        }\n      };\n    };\n  }\n  runWhenGlobalIdle = (runner) =\u003e _runWhenIdle(globalThis, runner);\n})();\nvar Promises;\n(function(Promises2) {\n  async function settled(promises) {\n    let firstError = void 0;\n    const result = await Promise.all(promises.map((promise) =\u003e promise.then((value) =\u003e value, (error) =\u003e {\n      if (!firstError) {\n        firstError = error;\n      }\n      return void 0;\n    })));\n    if (typeof firstError !== \"undefined\") {\n      throw firstError;\n    }\n    return result;\n  }\n  Promises2.settled = settled;\n  function withAsyncBody(bodyFn) {\n    return new Promise(async (resolve2, reject) =\u003e {\n      try {\n        await bodyFn(resolve2, reject);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  Promises2.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {}));\nvar AsyncIterableObject = class _AsyncIterableObject {\n  static fromArray(items) {\n    return new _AsyncIterableObject((writer) =\u003e {\n      writer.emitMany(items);\n    });\n  }\n  static fromPromise(promise) {\n    return new _AsyncIterableObject(async (emitter) =\u003e {\n      emitter.emitMany(await promise);\n    });\n  }\n  static fromPromises(promises) {\n    return new _AsyncIterableObject(async (emitter) =\u003e {\n      await Promise.all(promises.map(async (p) =\u003e emitter.emitOne(await p)));\n    });\n  }\n  static merge(iterables) {\n    return new _AsyncIterableObject(async (emitter) =\u003e {\n      await Promise.all(iterables.map(async (iterable) =\u003e {\n        for await (const item of iterable) {\n          emitter.emitOne(item);\n        }\n      }));\n    });\n  }\n  static {\n    this.EMPTY = _AsyncIterableObject.fromArray([]);\n  }\n  constructor(executor, onReturn) {\n    this._state = 0;\n    this._results = [];\n    this._error = null;\n    this._onReturn = onReturn;\n    this._onStateChanged = new Emitter();\n    queueMicrotask(async () =\u003e {\n      const writer = {\n        emitOne: (item) =\u003e this.emitOne(item),\n        emitMany: (items) =\u003e this.emitMany(items),\n        reject: (error) =\u003e this.reject(error)\n      };\n      try {\n        await Promise.resolve(executor(writer));\n        this.resolve();\n      } catch (err) {\n        this.reject(err);\n      } finally {\n        writer.emitOne = void 0;\n        writer.emitMany = void 0;\n        writer.reject = void 0;\n      }\n    });\n  }\n  [Symbol.asyncIterator]() {\n    let i = 0;\n    return {\n      next: async () =\u003e {\n        do {\n          if (this._state === 2) {\n            throw this._error;\n          }\n          if (i \u003c this._results.length) {\n            return { done: false, value: this._results[i++] };\n          }\n          if (this._state === 1) {\n            return { done: true, value: void 0 };\n          }\n          await Event.toPromise(this._onStateChanged.event);\n        } while (true);\n      },\n      return: async () =\u003e {\n        this._onReturn?.();\n        return { done: true, value: void 0 };\n      }\n    };\n  }\n  static map(iterable, mapFn) {\n    return new _AsyncIterableObject(async (emitter) =\u003e {\n      for await (const item of iterable) {\n        emitter.emitOne(mapFn(item));\n      }\n    });\n  }\n  map(mapFn) {\n    return _AsyncIterableObject.map(this, mapFn);\n  }\n  static filter(iterable, filterFn) {\n    return new _AsyncIterableObject(async (emitter) =\u003e {\n      for await (const item of iterable) {\n        if (filterFn(item)) {\n          emitter.emitOne(item);\n        }\n      }\n    });\n  }\n  filter(filterFn) {\n    return _AsyncIterableObject.filter(this, filterFn);\n  }\n  static coalesce(iterable) {\n    return _AsyncIterableObject.filter(iterable, (item) =\u003e !!item);\n  }\n  coalesce() {\n    return _AsyncIterableObject.coalesce(this);\n  }\n  static async toPromise(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n      result.push(item);\n    }\n    return result;\n  }\n  toPromise() {\n    return _AsyncIterableObject.toPromise(this);\n  }\n  /**\n   * The value will be appended at the end.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  emitOne(value) {\n    if (this._state !== 0) {\n      return;\n    }\n    this._results.push(value);\n    this._onStateChanged.fire();\n  }\n  /**\n   * The values will be appended at the end.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  emitMany(values) {\n    if (this._state !== 0) {\n      return;\n    }\n    this._results = this._results.concat(values);\n    this._onStateChanged.fire();\n  }\n  /**\n   * Calling `resolve()` will mark the result array as complete.\n   *\n   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  resolve() {\n    if (this._state !== 0) {\n      return;\n    }\n    this._state = 1;\n    this._onStateChanged.fire();\n  }\n  /**\n   * Writing an error will permanently invalidate this iterable.\n   * The current users will receive an error thrown, as will all future users.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  reject(error) {\n    if (this._state !== 0) {\n      return;\n    }\n    this._state = 2;\n    this._error = error;\n    this._onStateChanged.fire();\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js\nvar PrefixSumComputer = class {\n  constructor(values) {\n    this.values = values;\n    this.prefixSum = new Uint32Array(values.length);\n    this.prefixSumValidIndex = new Int32Array(1);\n    this.prefixSumValidIndex[0] = -1;\n  }\n  insertValues(insertIndex, insertValues) {\n    insertIndex = toUint32(insertIndex);\n    const oldValues = this.values;\n    const oldPrefixSum = this.prefixSum;\n    const insertValuesLen = insertValues.length;\n    if (insertValuesLen === 0) {\n      return false;\n    }\n    this.values = new Uint32Array(oldValues.length + insertValuesLen);\n    this.values.set(oldValues.subarray(0, insertIndex), 0);\n    this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n    this.values.set(insertValues, insertIndex);\n    if (insertIndex - 1 \u003c this.prefixSumValidIndex[0]) {\n      this.prefixSumValidIndex[0] = insertIndex - 1;\n    }\n    this.prefixSum = new Uint32Array(this.values.length);\n    if (this.prefixSumValidIndex[0] \u003e= 0) {\n      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n    }\n    return true;\n  }\n  setValue(index, value) {\n    index = toUint32(index);\n    value = toUint32(value);\n    if (this.values[index] === value) {\n      return false;\n    }\n    this.values[index] = value;\n    if (index - 1 \u003c this.prefixSumValidIndex[0]) {\n      this.prefixSumValidIndex[0] = index - 1;\n    }\n    return true;\n  }\n  removeValues(startIndex, count) {\n    startIndex = toUint32(startIndex);\n    count = toUint32(count);\n    const oldValues = this.values;\n    const oldPrefixSum = this.prefixSum;\n    if (startIndex \u003e= oldValues.length) {\n      return false;\n    }\n    const maxCount = oldValues.length - startIndex;\n    if (count \u003e= maxCount) {\n      count = maxCount;\n    }\n    if (count === 0) {\n      return false;\n    }\n    this.values = new Uint32Array(oldValues.length - count);\n    this.values.set(oldValues.subarray(0, startIndex), 0);\n    this.values.set(oldValues.subarray(startIndex + count), startIndex);\n    this.prefixSum = new Uint32Array(this.values.length);\n    if (startIndex - 1 \u003c this.prefixSumValidIndex[0]) {\n      this.prefixSumValidIndex[0] = startIndex - 1;\n    }\n    if (this.prefixSumValidIndex[0] \u003e= 0) {\n      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n    }\n    return true;\n  }\n  getTotalSum() {\n    if (this.values.length === 0) {\n      return 0;\n    }\n    return this._getPrefixSum(this.values.length - 1);\n  }\n  /**\n   * Returns the sum of the first `index + 1` many items.\n   * @returns `SUM(0 \u003c= j \u003c= index, values[j])`.\n   */\n  getPrefixSum(index) {\n    if (index \u003c 0) {\n      return 0;\n    }\n    index = toUint32(index);\n    return this._getPrefixSum(index);\n  }\n  _getPrefixSum(index) {\n    if (index \u003c= this.prefixSumValidIndex[0]) {\n      return this.prefixSum[index];\n    }\n    let startIndex = this.prefixSumValidIndex[0] + 1;\n    if (startIndex === 0) {\n      this.prefixSum[0] = this.values[0];\n      startIndex++;\n    }\n    if (index \u003e= this.values.length) {\n      index = this.values.length - 1;\n    }\n    for (let i = startIndex; i \u003c= index; i++) {\n      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n    }\n    this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n    return this.prefixSum[index];\n  }\n  getIndexOf(sum) {\n    sum = Math.floor(sum);\n    this.getTotalSum();\n    let low = 0;\n    let high = this.values.length - 1;\n    let mid = 0;\n    let midStop = 0;\n    let midStart = 0;\n    while (low \u003c= high) {\n      mid = low + (high - low) / 2 | 0;\n      midStop = this.prefixSum[mid];\n      midStart = midStop - this.values[mid];\n      if (sum \u003c midStart) {\n        high = mid - 1;\n      } else if (sum \u003e= midStop) {\n        low = mid + 1;\n      } else {\n        break;\n      }\n    }\n    return new PrefixSumIndexOfResult(mid, sum - midStart);\n  }\n};\nvar PrefixSumIndexOfResult = class {\n  constructor(index, remainder) {\n    this.index = index;\n    this.remainder = remainder;\n    this._prefixSumIndexOfResultBrand = void 0;\n    this.index = index;\n    this.remainder = remainder;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js\nvar MirrorTextModel = class {\n  constructor(uri, lines, eol, versionId) {\n    this._uri = uri;\n    this._lines = lines;\n    this._eol = eol;\n    this._versionId = versionId;\n    this._lineStarts = null;\n    this._cachedTextValue = null;\n  }\n  dispose() {\n    this._lines.length = 0;\n  }\n  get version() {\n    return this._versionId;\n  }\n  getText() {\n    if (this._cachedTextValue === null) {\n      this._cachedTextValue = this._lines.join(this._eol);\n    }\n    return this._cachedTextValue;\n  }\n  onEvents(e) {\n    if (e.eol \u0026\u0026 e.eol !== this._eol) {\n      this._eol = e.eol;\n      this._lineStarts = null;\n    }\n    const changes = e.changes;\n    for (const change of changes) {\n      this._acceptDeleteRange(change.range);\n      this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n    }\n    this._versionId = e.versionId;\n    this._cachedTextValue = null;\n  }\n  _ensureLineStarts() {\n    if (!this._lineStarts) {\n      const eolLength = this._eol.length;\n      const linesLength = this._lines.length;\n      const lineStartValues = new Uint32Array(linesLength);\n      for (let i = 0; i \u003c linesLength; i++) {\n        lineStartValues[i] = this._lines[i].length + eolLength;\n      }\n      this._lineStarts = new PrefixSumComputer(lineStartValues);\n    }\n  }\n  /**\n   * All changes to a line's text go through this method\n   */\n  _setLineText(lineIndex, newValue) {\n    this._lines[lineIndex] = newValue;\n    if (this._lineStarts) {\n      this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n    }\n  }\n  _acceptDeleteRange(range) {\n    if (range.startLineNumber === range.endLineNumber) {\n      if (range.startColumn === range.endColumn) {\n        return;\n      }\n      this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n      return;\n    }\n    this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n    this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    if (this._lineStarts) {\n      this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n  }\n  _acceptInsertText(position, insertText) {\n    if (insertText.length === 0) {\n      return;\n    }\n    const insertLines = splitLines(insertText);\n    if (insertLines.length === 1) {\n      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));\n      return;\n    }\n    insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n    this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);\n    const newLengths = new Uint32Array(insertLines.length - 1);\n    for (let i = 1; i \u003c insertLines.length; i++) {\n      this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n      newLengths[i - 1] = insertLines[i].length + this._eol.length;\n    }\n    if (this._lineStarts) {\n      this._lineStarts.insertValues(position.lineNumber, newLengths);\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js\nvar STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1e3;\nvar WorkerTextModelSyncServer = class {\n  constructor() {\n    this._models = /* @__PURE__ */ Object.create(null);\n  }\n  getModel(uri) {\n    return this._models[uri];\n  }\n  getModels() {\n    const all = [];\n    Object.keys(this._models).forEach((key) =\u003e all.push(this._models[key]));\n    return all;\n  }\n  $acceptNewModel(data) {\n    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n  }\n  $acceptModelChanged(uri, e) {\n    if (!this._models[uri]) {\n      return;\n    }\n    const model = this._models[uri];\n    model.onEvents(e);\n  }\n  $acceptRemovedModel(uri) {\n    if (!this._models[uri]) {\n      return;\n    }\n    delete this._models[uri];\n  }\n};\nvar MirrorModel = class extends MirrorTextModel {\n  get uri() {\n    return this._uri;\n  }\n  get eol() {\n    return this._eol;\n  }\n  getValue() {\n    return this.getText();\n  }\n  findMatches(regex) {\n    const matches = [];\n    for (let i = 0; i \u003c this._lines.length; i++) {\n      const line = this._lines[i];\n      const offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n      const iteratorOverMatches = line.matchAll(regex);\n      for (const match of iteratorOverMatches) {\n        if (match.index || match.index === 0) {\n          match.index = match.index + offsetToAdd;\n        }\n        matches.push(match);\n      }\n    }\n    return matches;\n  }\n  getLinesContent() {\n    return this._lines.slice(0);\n  }\n  getLineCount() {\n    return this._lines.length;\n  }\n  getLineContent(lineNumber) {\n    return this._lines[lineNumber - 1];\n  }\n  getWordAtPosition(position, wordDefinition) {\n    const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n    if (wordAtText) {\n      return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n    }\n    return null;\n  }\n  words(wordDefinition) {\n    const lines = this._lines;\n    const wordenize = this._wordenize.bind(this);\n    let lineNumber = 0;\n    let lineText = \"\";\n    let wordRangesIdx = 0;\n    let wordRanges = [];\n    return {\n      *[Symbol.iterator]() {\n        while (true) {\n          if (wordRangesIdx \u003c wordRanges.length) {\n            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n            wordRangesIdx += 1;\n            yield value;\n          } else {\n            if (lineNumber \u003c lines.length) {\n              lineText = lines[lineNumber];\n              wordRanges = wordenize(lineText, wordDefinition);\n              wordRangesIdx = 0;\n              lineNumber += 1;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    };\n  }\n  getLineWords(lineNumber, wordDefinition) {\n    const content = this._lines[lineNumber - 1];\n    const ranges = this._wordenize(content, wordDefinition);\n    const words = [];\n    for (const range of ranges) {\n      words.push({\n        word: content.substring(range.start, range.end),\n        startColumn: range.start + 1,\n        endColumn: range.end + 1\n      });\n    }\n    return words;\n  }\n  _wordenize(content, wordDefinition) {\n    const result = [];\n    let match;\n    wordDefinition.lastIndex = 0;\n    while (match = wordDefinition.exec(content)) {\n      if (match[0].length === 0) {\n        break;\n      }\n      result.push({ start: match.index, end: match.index + match[0].length });\n    }\n    return result;\n  }\n  getValueInRange(range) {\n    range = this._validateRange(range);\n    if (range.startLineNumber === range.endLineNumber) {\n      return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n    }\n    const lineEnding = this._eol;\n    const startLineIndex = range.startLineNumber - 1;\n    const endLineIndex = range.endLineNumber - 1;\n    const resultLines = [];\n    resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n    for (let i = startLineIndex + 1; i \u003c endLineIndex; i++) {\n      resultLines.push(this._lines[i]);\n    }\n    resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n    return resultLines.join(lineEnding);\n  }\n  offsetAt(position) {\n    position = this._validatePosition(position);\n    this._ensureLineStarts();\n    return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n  }\n  positionAt(offset) {\n    offset = Math.floor(offset);\n    offset = Math.max(0, offset);\n    this._ensureLineStarts();\n    const out = this._lineStarts.getIndexOf(offset);\n    const lineLength = this._lines[out.index].length;\n    return {\n      lineNumber: 1 + out.index,\n      column: 1 + Math.min(out.remainder, lineLength)\n    };\n  }\n  _validateRange(range) {\n    const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n    const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n    if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {\n      return {\n        startLineNumber: start.lineNumber,\n        startColumn: start.column,\n        endLineNumber: end.lineNumber,\n        endColumn: end.column\n      };\n    }\n    return range;\n  }\n  _validatePosition(position) {\n    if (!Position.isIPosition(position)) {\n      throw new Error(\"bad position\");\n    }\n    let { lineNumber, column } = position;\n    let hasChanged = false;\n    if (lineNumber \u003c 1) {\n      lineNumber = 1;\n      column = 1;\n      hasChanged = true;\n    } else if (lineNumber \u003e this._lines.length) {\n      lineNumber = this._lines.length;\n      column = this._lines[lineNumber - 1].length + 1;\n      hasChanged = true;\n    } else {\n      const maxCharacter = this._lines[lineNumber - 1].length + 1;\n      if (column \u003c 1) {\n        column = 1;\n        hasChanged = true;\n      } else if (column \u003e maxCharacter) {\n        column = maxCharacter;\n        hasChanged = true;\n      }\n    }\n    if (!hasChanged) {\n      return position;\n    } else {\n      return { lineNumber, column };\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js\nvar isESM2 = true;\nvar BaseEditorSimpleWorker = class {\n  constructor() {\n    this._workerTextModelSyncServer = new WorkerTextModelSyncServer();\n  }\n  dispose() {\n  }\n  _getModel(uri) {\n    return this._workerTextModelSyncServer.getModel(uri);\n  }\n  _getModels() {\n    return this._workerTextModelSyncServer.getModels();\n  }\n  $acceptNewModel(data) {\n    this._workerTextModelSyncServer.$acceptNewModel(data);\n  }\n  $acceptModelChanged(uri, e) {\n    this._workerTextModelSyncServer.$acceptModelChanged(uri, e);\n  }\n  $acceptRemovedModel(uri) {\n    this._workerTextModelSyncServer.$acceptRemovedModel(uri);\n  }\n  async $computeUnicodeHighlights(url, options, range) {\n    const model = this._getModel(url);\n    if (!model) {\n      return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n    }\n    return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n  }\n  async $findSectionHeaders(url, options) {\n    const model = this._getModel(url);\n    if (!model) {\n      return [];\n    }\n    return findSectionHeaders(model, options);\n  }\n  // ---- BEGIN diff --------------------------------------------------------------------------\n  async $computeDiff(originalUrl, modifiedUrl, options, algorithm) {\n    const original = this._getModel(originalUrl);\n    const modified = this._getModel(modifiedUrl);\n    if (!original || !modified) {\n      return null;\n    }\n    const result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n    return result;\n  }\n  static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\n    const diffAlgorithm = algorithm === \"advanced\" ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n    const originalLines = originalTextModel.getLinesContent();\n    const modifiedLines = modifiedTextModel.getLinesContent();\n    const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n    const identical = result.changes.length \u003e 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);\n    function getLineChanges(changes) {\n      return changes.map((m) =\u003e [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map((m2) =\u003e [\n        m2.originalRange.startLineNumber,\n        m2.originalRange.startColumn,\n        m2.originalRange.endLineNumber,\n        m2.originalRange.endColumn,\n        m2.modifiedRange.startLineNumber,\n        m2.modifiedRange.startColumn,\n        m2.modifiedRange.endLineNumber,\n        m2.modifiedRange.endColumn\n      ])]);\n    }\n    return {\n      identical,\n      quitEarly: result.hitTimeout,\n      changes: getLineChanges(result.changes),\n      moves: result.moves.map((m) =\u003e [\n        m.lineRangeMapping.original.startLineNumber,\n        m.lineRangeMapping.original.endLineNumberExclusive,\n        m.lineRangeMapping.modified.startLineNumber,\n        m.lineRangeMapping.modified.endLineNumberExclusive,\n        getLineChanges(m.changes)\n      ])\n    };\n  }\n  static _modelsAreIdentical(original, modified) {\n    const originalLineCount = original.getLineCount();\n    const modifiedLineCount = modified.getLineCount();\n    if (originalLineCount !== modifiedLineCount) {\n      return false;\n    }\n    for (let line = 1; line \u003c= originalLineCount; line++) {\n      const originalLine = original.getLineContent(line);\n      const modifiedLine = modified.getLineContent(line);\n      if (originalLine !== modifiedLine) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static {\n    this._diffLimit = 1e5;\n  }\n  async $computeMoreMinimalEdits(modelUrl, edits, pretty) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return edits;\n    }\n    const result = [];\n    let lastEol = void 0;\n    edits = edits.slice(0).sort((a, b) =\u003e {\n      if (a.range \u0026\u0026 b.range) {\n        return Range.compareRangesUsingStarts(a.range, b.range);\n      }\n      const aRng = a.range ? 0 : 1;\n      const bRng = b.range ? 0 : 1;\n      return aRng - bRng;\n    });\n    let writeIndex = 0;\n    for (let readIndex = 1; readIndex \u003c edits.length; readIndex++) {\n      if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n        edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n        edits[writeIndex].text += edits[readIndex].text;\n      } else {\n        writeIndex++;\n        edits[writeIndex] = edits[readIndex];\n      }\n    }\n    edits.length = writeIndex + 1;\n    for (let { range, text, eol } of edits) {\n      if (typeof eol === \"number\") {\n        lastEol = eol;\n      }\n      if (Range.isEmpty(range) \u0026\u0026 !text) {\n        continue;\n      }\n      const original = model.getValueInRange(range);\n      text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n      if (original === text) {\n        continue;\n      }\n      if (Math.max(text.length, original.length) \u003e EditorSimpleWorker._diffLimit) {\n        result.push({ range, text });\n        continue;\n      }\n      const changes = stringDiff(original, text, pretty);\n      const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n      for (const change of changes) {\n        const start = model.positionAt(editOffset + change.originalStart);\n        const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n        const newEdit = {\n          text: text.substr(change.modifiedStart, change.modifiedLength),\n          range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n        };\n        if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n          result.push(newEdit);\n        }\n      }\n    }\n    if (typeof lastEol === \"number\") {\n      result.push({ eol: lastEol, text: \"\", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n    }\n    return result;\n  }\n  // ---- END minimal edits ---------------------------------------------------------------\n  async $computeLinks(modelUrl) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return null;\n    }\n    return computeLinks(model);\n  }\n  // --- BEGIN default document colors -----------------------------------------------------------\n  async $computeDefaultDocumentColors(modelUrl) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return null;\n    }\n    return computeDefaultDocumentColors(model);\n  }\n  static {\n    this._suggestionsLimit = 1e4;\n  }\n  async $textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n    const sw = new StopWatch();\n    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n    const seen = /* @__PURE__ */ new Set();\n    outer:\n      for (const url of modelUrls) {\n        const model = this._getModel(url);\n        if (!model) {\n          continue;\n        }\n        for (const word of model.words(wordDefRegExp)) {\n          if (word === leadingWord || !isNaN(Number(word))) {\n            continue;\n          }\n          seen.add(word);\n          if (seen.size \u003e EditorSimpleWorker._suggestionsLimit) {\n            break outer;\n          }\n        }\n      }\n    return { words: Array.from(seen), duration: sw.elapsed() };\n  }\n  // ---- END suggest --------------------------------------------------------------------------\n  //#region -- word ranges --\n  async $computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return /* @__PURE__ */ Object.create(null);\n    }\n    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n    const result = /* @__PURE__ */ Object.create(null);\n    for (let line = range.startLineNumber; line \u003c range.endLineNumber; line++) {\n      const words = model.getLineWords(line, wordDefRegExp);\n      for (const word of words) {\n        if (!isNaN(Number(word.word))) {\n          continue;\n        }\n        let array = result[word.word];\n        if (!array) {\n          array = [];\n          result[word.word] = array;\n        }\n        array.push({\n          startLineNumber: line,\n          startColumn: word.startColumn,\n          endLineNumber: line,\n          endColumn: word.endColumn\n        });\n      }\n    }\n    return result;\n  }\n  //#endregion\n  async $navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return null;\n    }\n    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n    if (range.startColumn === range.endColumn) {\n      range = {\n        startLineNumber: range.startLineNumber,\n        startColumn: range.startColumn,\n        endLineNumber: range.endLineNumber,\n        endColumn: range.endColumn + 1\n      };\n    }\n    const selectionText = model.getValueInRange(range);\n    const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n    if (!wordRange) {\n      return null;\n    }\n    const word = model.getValueInRange(wordRange);\n    const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n    return result;\n  }\n};\nvar EditorSimpleWorker = class extends BaseEditorSimpleWorker {\n  constructor(_host, _foreignModuleFactory) {\n    super();\n    this._host = _host;\n    this._foreignModuleFactory = _foreignModuleFactory;\n    this._foreignModule = null;\n  }\n  async $ping() {\n    return \"pong\";\n  }\n  // ---- BEGIN foreign module support --------------------------------------------------------------------------\n  $loadForeignModule(moduleId, createData, foreignHostMethods) {\n    const proxyMethodRequest = (method, args) =\u003e {\n      return this._host.$fhr(method, args);\n    };\n    const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n    const ctx = {\n      host: foreignHost,\n      getMirrorModels: () =\u003e {\n        return this._getModels();\n      }\n    };\n    if (this._foreignModuleFactory) {\n      this._foreignModule = this._foreignModuleFactory(ctx, createData);\n      return Promise.resolve(getAllMethodNames(this._foreignModule));\n    }\n    return new Promise((resolve2, reject) =\u003e {\n      const onModuleCallback = (foreignModule) =\u003e {\n        this._foreignModule = foreignModule.create(ctx, createData);\n        resolve2(getAllMethodNames(this._foreignModule));\n      };\n      if (!isESM2) {\n        __require([`${moduleId}`], onModuleCallback, reject);\n      } else {\n        const url = FileAccess.asBrowserUri(`${moduleId}.js`).toString(true);\n        import(`${url}`).then(onModuleCallback).catch(reject);\n      }\n    });\n  }\n  // foreign method request\n  $fmr(method, args) {\n    if (!this._foreignModule || typeof this._foreignModule[method] !== \"function\") {\n      return Promise.reject(new Error(\"Missing requestHandler or method: \" + method));\n    }\n    try {\n      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n};\nif (typeof importScripts === \"function\") {\n  globalThis.monaco = createMonacoBaseAPI();\n}\n\n// ../esmd/npm/monaco-editor@0.52.0/node_modules/.pnpm/monaco-editor@0.52.0/node_modules/monaco-editor/esm/vs/editor/editor.worker.js\nvar initialized = false;\nfunction initialize(foreignModule) {\n  if (initialized) {\n    return;\n  }\n  initialized = true;\n  const simpleWorker = new SimpleWorkerServer((msg) =\u003e {\n    globalThis.postMessage(msg);\n  }, (workerServer) =\u003e new EditorSimpleWorker(EditorWorkerHost.getChannel(workerServer), foreignModule));\n  globalThis.onmessage = (e) =\u003e {\n    simpleWorker.onmessage(e.data);\n  };\n}\nglobalThis.onmessage = (e) =\u003e {\n  if (!initialized) {\n    initialize(null);\n  }\n};\nexport {\n  initialize\n};\n"
, typeof inject === "string" ? "\n// inject\n" + inject : ""], { type: "application/javascript" }); return new Worker(URL.createObjectURL(blob), { type: "module" })}