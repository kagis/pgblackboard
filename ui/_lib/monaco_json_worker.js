export default function workerFactory(inject) { const blob = new Blob(["/* esm.sh - esbuild bundle(monaco-editor@0.45.0/esm/vs/language/json/json.worker) es2022 development */\n(()=\u003e{var a=typeof Reflect==\"object\"?Reflect:null,g=a\u0026\u0026typeof a.apply==\"function\"?a.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)},p;a\u0026\u0026typeof a.ownKeys==\"function\"?p=a.ownKeys:Object.getOwnPropertySymbols?p=function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:p=function(e){return Object.getOwnPropertyNames(e)};function D(n){console\u0026\u0026console.warn\u0026\u0026console.warn(n)}var w=Number.isNaN||function(e){return e!==e};function s(){L.call(this)}s.EventEmitter=s;s.prototype._events=void 0;s.prototype._eventsCount=0;s.prototype._maxListeners=void 0;var y=10;function d(n){if(typeof n!=\"function\")throw new TypeError('The \"listener\" argument must be of type Function. Received type '+typeof n)}Object.defineProperty(s,\"defaultMaxListeners\",{enumerable:!0,get:function(){return y},set:function(n){if(typeof n!=\"number\"||n\u003c0||w(n))throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received '+n+\".\");y=n}});function L(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)\u0026\u0026(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0}s.init=L;s.prototype.setMaxListeners=function(e){if(typeof e!=\"number\"||e\u003c0||w(e))throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received '+e+\".\");return this._maxListeners=e,this};function b(n){return n._maxListeners===void 0?s.defaultMaxListeners:n._maxListeners}s.prototype.getMaxListeners=function(){return b(this)};s.prototype.emit=function(e){for(var t=[],r=1;r\u003carguments.length;r++)t.push(arguments[r]);var i=e===\"error\",u=this._events;if(u!==void 0)i=i\u0026\u0026u.error===void 0;else if(!i)return!1;if(i){var o;if(t.length\u003e0\u0026\u0026(o=t[0]),o instanceof Error)throw o;var c=new Error(\"Unhandled error.\"+(o?\" (\"+o.message+\")\":\"\"));throw c.context=o,c}var l=u[e];if(l===void 0)return!1;if(typeof l==\"function\")g(l,this,t);else for(var m=l.length,M=x(l,m),r=0;r\u003cm;++r)g(M[r],this,t);return!0};function _(n,e,t,r){var i,u,o;if(d(t),u=n._events,u===void 0?(u=n._events=Object.create(null),n._eventsCount=0):(u.newListener!==void 0\u0026\u0026(n.emit(\"newListener\",e,t.listener?t.listener:t),u=n._events),o=u[e]),o===void 0)o=u[e]=t,++n._eventsCount;else if(typeof o==\"function\"?o=u[e]=r?[t,o]:[o,t]:r?o.unshift(t):o.push(t),i=b(n),i\u003e0\u0026\u0026o.length\u003ei\u0026\u0026!o.warned){o.warned=!0;var c=new Error(\"Possible EventEmitter memory leak detected. \"+o.length+\" \"+String(e)+\" listeners added. Use emitter.setMaxListeners() to increase limit\");c.name=\"MaxListenersExceededWarning\",c.emitter=n,c.type=e,c.count=o.length,D(c)}return n}s.prototype.addListener=function(e,t){return _(this,e,t,!1)};s.prototype.on=s.prototype.addListener;s.prototype.prependListener=function(e,t){return _(this,e,t,!0)};function R(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function E(n,e,t){var r={fired:!1,wrapFn:void 0,target:n,type:e,listener:t},i=R.bind(r);return i.listener=t,r.wrapFn=i,i}s.prototype.once=function(e,t){return d(t),this.on(e,E(this,e,t)),this};s.prototype.prependOnceListener=function(e,t){return d(t),this.prependListener(e,E(this,e,t)),this};s.prototype.removeListener=function(e,t){var r,i,u,o,c;if(d(t),i=this._events,i===void 0)return this;if(r=i[e],r===void 0)return this;if(r===t||r.listener===t)--this._eventsCount===0?this._events=Object.create(null):(delete i[e],i.removeListener\u0026\u0026this.emit(\"removeListener\",e,r.listener||t));else if(typeof r!=\"function\"){for(u=-1,o=r.length-1;o\u003e=0;o--)if(r[o]===t||r[o].listener===t){c=r[o].listener,u=o;break}if(u\u003c0)return this;u===0?r.shift():N(r,u),r.length===1\u0026\u0026(i[e]=r[0]),i.removeListener!==void 0\u0026\u0026this.emit(\"removeListener\",e,c||t)}return this};s.prototype.off=s.prototype.removeListener;s.prototype.removeAllListeners=function(e){var t,r,i;if(r=this._events,r===void 0)return this;if(r.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):r[e]!==void 0\u0026\u0026(--this._eventsCount===0?this._events=Object.create(null):delete r[e]),this;if(arguments.length===0){var u=Object.keys(r),o;for(i=0;i\u003cu.length;++i)o=u[i],o!==\"removeListener\"\u0026\u0026this.removeAllListeners(o);return this.removeAllListeners(\"removeListener\"),this._events=Object.create(null),this._eventsCount=0,this}if(t=r[e],typeof t==\"function\")this.removeListener(e,t);else if(t!==void 0)for(i=t.length-1;i\u003e=0;i--)this.removeListener(e,t[i]);return this};function O(n,e,t){var r=n._events;if(r===void 0)return[];var i=r[e];return i===void 0?[]:typeof i==\"function\"?t?[i.listener||i]:[i]:t?P(i):x(i,i.length)}s.prototype.listeners=function(e){return O(this,e,!0)};s.prototype.rawListeners=function(e){return O(this,e,!1)};function C(n,e){return typeof n.listenerCount==\"function\"?n.listenerCount(e):s.prototype.listenerCount.call(n,e)}s.listenerCount=C;s.prototype.listenerCount=function(n){var e=this._events;if(e!==void 0){var t=e[n];if(typeof t==\"function\")return 1;if(t!==void 0)return t.length}return 0};s.prototype.eventNames=function(){return this._eventsCount\u003e0?p(this._events):[]};function x(n,e){for(var t=new Array(e),r=0;r\u003ce;++r)t[r]=n[r];return t}function N(n,e){for(;e+1\u003cn.length;e++)n[e]=n[e+1];n.pop()}function P(n){for(var e=new Array(n.length),t=0;t\u003ce.length;++t)e[t]=n[t].listener||n[t];return e}function v(n){let e=performance.now(),t=Math.floor(e/1e3),r=Math.floor(e*1e6-t*1e9);if(!n)return[t,r];let[i,u]=n;return[t-i,r-u]}v.bigint=function(){let[n,e]=v();return BigInt(n)*1000000000n+BigInt(e)};var h=class extends s{title=\"browser\";browser=!0;env={};argv=[];pid=0;arch=\"unknown\";platform=\"browser\";version=\"\";versions={};emitWarning=()=\u003e{throw new Error(\"process.emitWarning is not supported\")};binding=()=\u003e{throw new Error(\"process.binding is not supported\")};cwd=()=\u003e{throw new Error(\"process.cwd is not supported\")};chdir=e=\u003e{throw new Error(\"process.chdir is not supported\")};umask=()=\u003e18;nextTick=(e,...t)=\u003equeueMicrotask(()=\u003ee(...t));hrtime=v;constructor(){super()}},f=new h;if(typeof Deno\u003c\"u\"){f.name=\"deno\",f.browser=!1,f.pid=Deno.pid,f.cwd=()=\u003eDeno.cwd(),f.chdir=e=\u003eDeno.chdir(e),f.arch=Deno.build.arch,f.platform=Deno.build.os,f.version=\"v18.12.1\",f.versions={node:\"18.12.1\",uv:\"1.43.0\",zlib:\"1.2.11\",brotli:\"1.0.9\",ares:\"1.18.1\",modules:\"108\",nghttp2:\"1.47.0\",napi:\"8\",llhttp:\"6.0.10\",openssl:\"3.0.7+quic\",cldr:\"41.0\",icu:\"71.1\",tz:\"2022b\",unicode:\"14.0\",ngtcp2:\"0.8.1\",nghttp3:\"0.7.0\",...Deno.version},f.env=new Proxy({},{get(e,t){return Deno.env.get(String(t))},ownKeys:()=\u003eReflect.ownKeys(Deno.env.toObject()),getOwnPropertyDescriptor:(e,t)=\u003e{let r=Deno.env.toObject();if(t in Deno.env.toObject()){let i={enumerable:!0,configurable:!0};return typeof t==\"string\"\u0026\u0026(i.value=r[t]),i}},set(e,t,r){return Deno.env.set(String(t),String(r)),r}});let n=[\"\",\"\",...Deno.args];Object.defineProperty(n,\"0\",{get:Deno.execPath}),Object.defineProperty(n,\"1\",{get:()=\u003eDeno.mainModule.startsWith(\"file:\")?new URL(Deno.mainModule).pathname:join(Deno.cwd(),\"$deno$node.js\")}),f.argv=n}else{let n=\"/\";f.cwd=()=\u003en,f.chdir=e=\u003en=e}var j=f;globalThis.__Process$=j;})();\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/errors.js\nvar ErrorHandler = class {\n  constructor() {\n    this.listeners = [];\n    this.unexpectedErrorHandler = function(e) {\n      setTimeout(() =\u003e {\n        if (e.stack) {\n          if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n            throw new ErrorNoTelemetry(e.message + \"\\n\\n\" + e.stack);\n          }\n          throw new Error(e.message + \"\\n\\n\" + e.stack);\n        }\n        throw e;\n      }, 0);\n    };\n  }\n  emit(e) {\n    this.listeners.forEach((listener) =\u003e {\n      listener(e);\n    });\n  }\n  onUnexpectedError(e) {\n    this.unexpectedErrorHandler(e);\n    this.emit(e);\n  }\n  // For external errors, we don't want the listeners to be called\n  onUnexpectedExternalError(e) {\n    this.unexpectedErrorHandler(e);\n  }\n};\nvar errorHandler = new ErrorHandler();\nfunction onUnexpectedError(e) {\n  if (!isCancellationError(e)) {\n    errorHandler.onUnexpectedError(e);\n  }\n  return void 0;\n}\nfunction transformErrorForSerialization(error) {\n  if (error instanceof Error) {\n    const { name, message } = error;\n    const stack = error.stacktrace || error.stack;\n    return {\n      $isError: true,\n      name,\n      message,\n      stack,\n      noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\n    };\n  }\n  return error;\n}\nvar canceledName = \"Canceled\";\nfunction isCancellationError(error) {\n  if (error instanceof CancellationError) {\n    return true;\n  }\n  return error instanceof Error \u0026\u0026 error.name === canceledName \u0026\u0026 error.message === canceledName;\n}\nvar CancellationError = class extends Error {\n  constructor() {\n    super(canceledName);\n    this.name = this.message;\n  }\n};\nvar ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = \"CodeExpectedError\";\n  }\n  static fromError(err) {\n    if (err instanceof _ErrorNoTelemetry) {\n      return err;\n    }\n    const result = new _ErrorNoTelemetry();\n    result.message = err.message;\n    result.stack = err.stack;\n    return result;\n  }\n  static isErrorNoTelemetry(err) {\n    return err.name === \"CodeExpectedError\";\n  }\n};\nvar BugIndicatingError = class _BugIndicatingError extends Error {\n  constructor(message) {\n    super(message || \"An unexpected bug occurred.\");\n    Object.setPrototypeOf(this, _BugIndicatingError.prototype);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/functional.js\nfunction createSingleCallFunction(fn, fnDidRunCallback) {\n  const _this = this;\n  let didCall = false;\n  let result;\n  return function() {\n    if (didCall) {\n      return result;\n    }\n    didCall = true;\n    if (fnDidRunCallback) {\n      try {\n        result = fn.apply(_this, arguments);\n      } finally {\n        fnDidRunCallback();\n      }\n    } else {\n      result = fn.apply(_this, arguments);\n    }\n    return result;\n  };\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js\nvar Iterable;\n(function(Iterable2) {\n  function is(thing) {\n    return thing \u0026\u0026 typeof thing === \"object\" \u0026\u0026 typeof thing[Symbol.iterator] === \"function\";\n  }\n  Iterable2.is = is;\n  const _empty2 = Object.freeze([]);\n  function empty() {\n    return _empty2;\n  }\n  Iterable2.empty = empty;\n  function* single(element) {\n    yield element;\n  }\n  Iterable2.single = single;\n  function wrap(iterableOrElement) {\n    if (is(iterableOrElement)) {\n      return iterableOrElement;\n    } else {\n      return single(iterableOrElement);\n    }\n  }\n  Iterable2.wrap = wrap;\n  function from(iterable) {\n    return iterable || _empty2;\n  }\n  Iterable2.from = from;\n  function* reverse(array) {\n    for (let i = array.length - 1; i \u003e= 0; i--) {\n      yield array[i];\n    }\n  }\n  Iterable2.reverse = reverse;\n  function isEmpty(iterable) {\n    return !iterable || iterable[Symbol.iterator]().next().done === true;\n  }\n  Iterable2.isEmpty = isEmpty;\n  function first(iterable) {\n    return iterable[Symbol.iterator]().next().value;\n  }\n  Iterable2.first = first;\n  function some(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  Iterable2.some = some;\n  function find(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        return element;\n      }\n    }\n    return void 0;\n  }\n  Iterable2.find = find;\n  function* filter(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        yield element;\n      }\n    }\n  }\n  Iterable2.filter = filter;\n  function* map(iterable, fn) {\n    let index = 0;\n    for (const element of iterable) {\n      yield fn(element, index++);\n    }\n  }\n  Iterable2.map = map;\n  function* concat(...iterables) {\n    for (const iterable of iterables) {\n      yield* iterable;\n    }\n  }\n  Iterable2.concat = concat;\n  function reduce(iterable, reducer, initialValue) {\n    let value = initialValue;\n    for (const element of iterable) {\n      value = reducer(value, element);\n    }\n    return value;\n  }\n  Iterable2.reduce = reduce;\n  function* slice(arr, from2, to = arr.length) {\n    if (from2 \u003c 0) {\n      from2 += arr.length;\n    }\n    if (to \u003c 0) {\n      to += arr.length;\n    } else if (to \u003e arr.length) {\n      to = arr.length;\n    }\n    for (; from2 \u003c to; from2++) {\n      yield arr[from2];\n    }\n  }\n  Iterable2.slice = slice;\n  function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n    const consumed = [];\n    if (atMost === 0) {\n      return [consumed, iterable];\n    }\n    const iterator = iterable[Symbol.iterator]();\n    for (let i = 0; i \u003c atMost; i++) {\n      const next = iterator.next();\n      if (next.done) {\n        return [consumed, Iterable2.empty()];\n      }\n      consumed.push(next.value);\n    }\n    return [consumed, { [Symbol.iterator]() {\n      return iterator;\n    } }];\n  }\n  Iterable2.consume = consume;\n})(Iterable || (Iterable = {}));\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\nvar TRACK_DISPOSABLES = false;\nvar disposableTracker = null;\nfunction setDisposableTracker(tracker) {\n  disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n  const __is_disposable_tracked__ = \"__is_disposable_tracked__\";\n  setDisposableTracker(new class {\n    trackDisposable(x) {\n      const stack = new Error(\"Potentially leaked disposable\").stack;\n      setTimeout(() =\u003e {\n        if (!x[__is_disposable_tracked__]) {\n          console.log(stack);\n        }\n      }, 3e3);\n    }\n    setParent(child, parent) {\n      if (child \u0026\u0026 child !== Disposable.None) {\n        try {\n          child[__is_disposable_tracked__] = true;\n        } catch (_a4) {\n        }\n      }\n    }\n    markAsDisposed(disposable) {\n      if (disposable \u0026\u0026 disposable !== Disposable.None) {\n        try {\n          disposable[__is_disposable_tracked__] = true;\n        } catch (_a4) {\n        }\n      }\n    }\n    markAsSingleton(disposable) {\n    }\n  }());\n}\nfunction trackDisposable(x) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\n  return x;\n}\nfunction markAsDisposed(disposable) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n  if (!disposableTracker) {\n    return;\n  }\n  for (const child of children) {\n    disposableTracker.setParent(child, parent);\n  }\n}\nfunction dispose(arg) {\n  if (Iterable.is(arg)) {\n    const errors = [];\n    for (const d of arg) {\n      if (d) {\n        try {\n          d.dispose();\n        } catch (e) {\n          errors.push(e);\n        }\n      }\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length \u003e 1) {\n      throw new AggregateError(errors, \"Encountered errors while disposing of store\");\n    }\n    return Array.isArray(arg) ? [] : arg;\n  } else if (arg) {\n    arg.dispose();\n    return arg;\n  }\n}\nfunction combinedDisposable(...disposables) {\n  const parent = toDisposable(() =\u003e dispose(disposables));\n  setParentOfDisposables(disposables, parent);\n  return parent;\n}\nfunction toDisposable(fn) {\n  const self2 = trackDisposable({\n    dispose: createSingleCallFunction(() =\u003e {\n      markAsDisposed(self2);\n      fn();\n    })\n  });\n  return self2;\n}\nvar DisposableStore = class _DisposableStore {\n  constructor() {\n    this._toDispose = /* @__PURE__ */ new Set();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  /**\n   * Dispose of all registered disposables and mark this object as disposed.\n   *\n   * Any future disposables added to this object will be disposed of on `add`.\n   */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    markAsDisposed(this);\n    this._isDisposed = true;\n    this.clear();\n  }\n  /**\n   * @return `true` if this object has been disposed of.\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Dispose of all registered disposables but do not mark this object as disposed.\n   */\n  clear() {\n    if (this._toDispose.size === 0) {\n      return;\n    }\n    try {\n      dispose(this._toDispose);\n    } finally {\n      this._toDispose.clear();\n    }\n  }\n  /**\n   * Add a new {@link IDisposable disposable} to the collection.\n   */\n  add(o) {\n    if (!o) {\n      return o;\n    }\n    if (o === this) {\n      throw new Error(\"Cannot register a disposable on itself!\");\n    }\n    setParentOfDisposable(o, this);\n    if (this._isDisposed) {\n      if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {\n        console.warn(new Error(\"Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!\").stack);\n      }\n    } else {\n      this._toDispose.add(o);\n    }\n    return o;\n  }\n  /**\n   * Deletes the value from the store, but does not dispose it.\n   */\n  deleteAndLeak(o) {\n    if (!o) {\n      return;\n    }\n    if (this._toDispose.has(o)) {\n      this._toDispose.delete(o);\n      setParentOfDisposable(o, null);\n    }\n  }\n};\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\nvar Disposable = class {\n  constructor() {\n    this._store = new DisposableStore();\n    trackDisposable(this);\n    setParentOfDisposable(this._store, this);\n  }\n  dispose() {\n    markAsDisposed(this);\n    this._store.dispose();\n  }\n  /**\n   * Adds `o` to the collection of disposables managed by this object.\n   */\n  _register(o) {\n    if (o === this) {\n      throw new Error(\"Cannot register a disposable on itself!\");\n    }\n    return this._store.add(o);\n  }\n};\nDisposable.None = Object.freeze({ dispose() {\n} });\nvar DisposableMap = class {\n  constructor() {\n    this._store = /* @__PURE__ */ new Map();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  /**\n   * Disposes of all stored values and mark this object as disposed.\n   *\n   * Trying to use this object after it has been disposed of is an error.\n   */\n  dispose() {\n    markAsDisposed(this);\n    this._isDisposed = true;\n    this.clearAndDisposeAll();\n  }\n  /**\n   * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n   */\n  clearAndDisposeAll() {\n    if (!this._store.size) {\n      return;\n    }\n    try {\n      dispose(this._store.values());\n    } finally {\n      this._store.clear();\n    }\n  }\n  get(key) {\n    return this._store.get(key);\n  }\n  set(key, value, skipDisposeOnOverwrite = false) {\n    var _a4;\n    if (this._isDisposed) {\n      console.warn(new Error(\"Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!\").stack);\n    }\n    if (!skipDisposeOnOverwrite) {\n      (_a4 = this._store.get(key)) === null || _a4 === void 0 ? void 0 : _a4.dispose();\n    }\n    this._store.set(key, value);\n  }\n  /**\n   * Delete the value stored for `key` from this map and also dispose of it.\n   */\n  deleteAndDispose(key) {\n    var _a4;\n    (_a4 = this._store.get(key)) === null || _a4 === void 0 ? void 0 : _a4.dispose();\n    this._store.delete(key);\n  }\n  [Symbol.iterator]() {\n    return this._store[Symbol.iterator]();\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js\nvar Node = class _Node {\n  constructor(element) {\n    this.element = element;\n    this.next = _Node.Undefined;\n    this.prev = _Node.Undefined;\n  }\n};\nNode.Undefined = new Node(void 0);\nvar LinkedList = class {\n  constructor() {\n    this._first = Node.Undefined;\n    this._last = Node.Undefined;\n    this._size = 0;\n  }\n  get size() {\n    return this._size;\n  }\n  isEmpty() {\n    return this._first === Node.Undefined;\n  }\n  clear() {\n    let node = this._first;\n    while (node !== Node.Undefined) {\n      const next = node.next;\n      node.prev = Node.Undefined;\n      node.next = Node.Undefined;\n      node = next;\n    }\n    this._first = Node.Undefined;\n    this._last = Node.Undefined;\n    this._size = 0;\n  }\n  unshift(element) {\n    return this._insert(element, false);\n  }\n  push(element) {\n    return this._insert(element, true);\n  }\n  _insert(element, atTheEnd) {\n    const newNode = new Node(element);\n    if (this._first === Node.Undefined) {\n      this._first = newNode;\n      this._last = newNode;\n    } else if (atTheEnd) {\n      const oldLast = this._last;\n      this._last = newNode;\n      newNode.prev = oldLast;\n      oldLast.next = newNode;\n    } else {\n      const oldFirst = this._first;\n      this._first = newNode;\n      newNode.next = oldFirst;\n      oldFirst.prev = newNode;\n    }\n    this._size += 1;\n    let didRemove = false;\n    return () =\u003e {\n      if (!didRemove) {\n        didRemove = true;\n        this._remove(newNode);\n      }\n    };\n  }\n  shift() {\n    if (this._first === Node.Undefined) {\n      return void 0;\n    } else {\n      const res = this._first.element;\n      this._remove(this._first);\n      return res;\n    }\n  }\n  pop() {\n    if (this._last === Node.Undefined) {\n      return void 0;\n    } else {\n      const res = this._last.element;\n      this._remove(this._last);\n      return res;\n    }\n  }\n  _remove(node) {\n    if (node.prev !== Node.Undefined \u0026\u0026 node.next !== Node.Undefined) {\n      const anchor = node.prev;\n      anchor.next = node.next;\n      node.next.prev = anchor;\n    } else if (node.prev === Node.Undefined \u0026\u0026 node.next === Node.Undefined) {\n      this._first = Node.Undefined;\n      this._last = Node.Undefined;\n    } else if (node.next === Node.Undefined) {\n      this._last = this._last.prev;\n      this._last.next = Node.Undefined;\n    } else if (node.prev === Node.Undefined) {\n      this._first = this._first.next;\n      this._first.prev = Node.Undefined;\n    }\n    this._size -= 1;\n  }\n  *[Symbol.iterator]() {\n    let node = this._first;\n    while (node !== Node.Undefined) {\n      yield node.element;\n      node = node.next;\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js\nvar hasPerformanceNow = globalThis.performance \u0026\u0026 typeof globalThis.performance.now === \"function\";\nvar StopWatch = class _StopWatch {\n  static create(highResolution) {\n    return new _StopWatch(highResolution);\n  }\n  constructor(highResolution) {\n    this._now = hasPerformanceNow \u0026\u0026 highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);\n    this._startTime = this._now();\n    this._stopTime = -1;\n  }\n  stop() {\n    this._stopTime = this._now();\n  }\n  elapsed() {\n    if (this._stopTime !== -1) {\n      return this._stopTime - this._startTime;\n    }\n    return this._now() - this._startTime;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/event.js\nvar _enableDisposeWithListenerWarning = false;\nvar _enableSnapshotPotentialLeakWarning = false;\nvar Event;\n(function(Event2) {\n  Event2.None = () =\u003e Disposable.None;\n  function _addLeakageTraceLogic(options) {\n    if (_enableSnapshotPotentialLeakWarning) {\n      const { onDidAddListener: origListenerDidAdd } = options;\n      const stack = Stacktrace.create();\n      let count = 0;\n      options.onDidAddListener = () =\u003e {\n        if (++count === 2) {\n          console.warn(\"snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here\");\n          stack.print();\n        }\n        origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n      };\n    }\n  }\n  function defer(event, disposable) {\n    return debounce(event, () =\u003e void 0, 0, void 0, true, void 0, disposable);\n  }\n  Event2.defer = defer;\n  function once2(event) {\n    return (listener, thisArgs = null, disposables) =\u003e {\n      let didFire = false;\n      let result = void 0;\n      result = event((e) =\u003e {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n      if (didFire) {\n        result.dispose();\n      }\n      return result;\n    };\n  }\n  Event2.once = once2;\n  function map(event, map2, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) =\u003e event((i) =\u003e listener.call(thisArgs, map2(i)), null, disposables), disposable);\n  }\n  Event2.map = map;\n  function forEach(event, each, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) =\u003e event((i) =\u003e {\n      each(i);\n      listener.call(thisArgs, i);\n    }, null, disposables), disposable);\n  }\n  Event2.forEach = forEach;\n  function filter(event, filter2, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) =\u003e event((e) =\u003e filter2(e) \u0026\u0026 listener.call(thisArgs, e), null, disposables), disposable);\n  }\n  Event2.filter = filter;\n  function signal(event) {\n    return event;\n  }\n  Event2.signal = signal;\n  function any(...events) {\n    return (listener, thisArgs = null, disposables) =\u003e {\n      const disposable = combinedDisposable(...events.map((event) =\u003e event((e) =\u003e listener.call(thisArgs, e))));\n      return addAndReturnDisposable(disposable, disposables);\n    };\n  }\n  Event2.any = any;\n  function reduce(event, merge, initial, disposable) {\n    let output = initial;\n    return map(event, (e) =\u003e {\n      output = merge(output, e);\n      return output;\n    }, disposable);\n  }\n  Event2.reduce = reduce;\n  function snapshot(event, disposable) {\n    let listener;\n    const options = {\n      onWillAddFirstListener() {\n        listener = event(emitter.fire, emitter);\n      },\n      onDidRemoveLastListener() {\n        listener === null || listener === void 0 ? void 0 : listener.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    const emitter = new Emitter(options);\n    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n    return emitter.event;\n  }\n  function addAndReturnDisposable(d, store) {\n    if (store instanceof Array) {\n      store.push(d);\n    } else if (store) {\n      store.add(d);\n    }\n    return d;\n  }\n  function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n    let subscription;\n    let output = void 0;\n    let handle = void 0;\n    let numDebouncedCalls = 0;\n    let doFire;\n    const options = {\n      leakWarningThreshold,\n      onWillAddFirstListener() {\n        subscription = event((cur) =\u003e {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n          if (leading \u0026\u0026 !handle) {\n            emitter.fire(output);\n            output = void 0;\n          }\n          doFire = () =\u003e {\n            const _output = output;\n            output = void 0;\n            handle = void 0;\n            if (!leading || numDebouncedCalls \u003e 1) {\n              emitter.fire(_output);\n            }\n            numDebouncedCalls = 0;\n          };\n          if (typeof delay === \"number\") {\n            clearTimeout(handle);\n            handle = setTimeout(doFire, delay);\n          } else {\n            if (handle === void 0) {\n              handle = 0;\n              queueMicrotask(doFire);\n            }\n          }\n        });\n      },\n      onWillRemoveListener() {\n        if (flushOnListenerRemove \u0026\u0026 numDebouncedCalls \u003e 0) {\n          doFire === null || doFire === void 0 ? void 0 : doFire();\n        }\n      },\n      onDidRemoveLastListener() {\n        doFire = void 0;\n        subscription.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    const emitter = new Emitter(options);\n    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n    return emitter.event;\n  }\n  Event2.debounce = debounce;\n  function accumulate(event, delay = 0, disposable) {\n    return Event2.debounce(event, (last, e) =\u003e {\n      if (!last) {\n        return [e];\n      }\n      last.push(e);\n      return last;\n    }, delay, void 0, true, void 0, disposable);\n  }\n  Event2.accumulate = accumulate;\n  function latch(event, equals4 = (a2, b) =\u003e a2 === b, disposable) {\n    let firstCall = true;\n    let cache;\n    return filter(event, (value) =\u003e {\n      const shouldEmit = firstCall || !equals4(value, cache);\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    }, disposable);\n  }\n  Event2.latch = latch;\n  function split(event, isT, disposable) {\n    return [\n      Event2.filter(event, isT, disposable),\n      Event2.filter(event, (e) =\u003e !isT(e), disposable)\n    ];\n  }\n  Event2.split = split;\n  function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n    let buffer2 = _buffer.slice();\n    let listener = event((e) =\u003e {\n      if (buffer2) {\n        buffer2.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n    if (disposable) {\n      disposable.add(listener);\n    }\n    const flush = () =\u003e {\n      buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.forEach((e) =\u003e emitter.fire(e));\n      buffer2 = null;\n    };\n    const emitter = new Emitter({\n      onWillAddFirstListener() {\n        if (!listener) {\n          listener = event((e) =\u003e emitter.fire(e));\n          if (disposable) {\n            disposable.add(listener);\n          }\n        }\n      },\n      onDidAddFirstListener() {\n        if (buffer2) {\n          if (flushAfterTimeout) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onDidRemoveLastListener() {\n        if (listener) {\n          listener.dispose();\n        }\n        listener = null;\n      }\n    });\n    if (disposable) {\n      disposable.add(emitter);\n    }\n    return emitter.event;\n  }\n  Event2.buffer = buffer;\n  function chain(event, sythensize) {\n    const fn = (listener, thisArgs, disposables) =\u003e {\n      const cs = sythensize(new ChainableSynthesis());\n      return event(function(value) {\n        const result = cs.evaluate(value);\n        if (result !== HaltChainable) {\n          listener.call(thisArgs, result);\n        }\n      }, void 0, disposables);\n    };\n    return fn;\n  }\n  Event2.chain = chain;\n  const HaltChainable = Symbol(\"HaltChainable\");\n  class ChainableSynthesis {\n    constructor() {\n      this.steps = [];\n    }\n    map(fn) {\n      this.steps.push(fn);\n      return this;\n    }\n    forEach(fn) {\n      this.steps.push((v) =\u003e {\n        fn(v);\n        return v;\n      });\n      return this;\n    }\n    filter(fn) {\n      this.steps.push((v) =\u003e fn(v) ? v : HaltChainable);\n      return this;\n    }\n    reduce(merge, initial) {\n      let last = initial;\n      this.steps.push((v) =\u003e {\n        last = merge(last, v);\n        return last;\n      });\n      return this;\n    }\n    latch(equals4 = (a2, b) =\u003e a2 === b) {\n      let firstCall = true;\n      let cache;\n      this.steps.push((value) =\u003e {\n        const shouldEmit = firstCall || !equals4(value, cache);\n        firstCall = false;\n        cache = value;\n        return shouldEmit ? value : HaltChainable;\n      });\n      return this;\n    }\n    evaluate(value) {\n      for (const step of this.steps) {\n        value = step(value);\n        if (value === HaltChainable) {\n          break;\n        }\n      }\n      return value;\n    }\n  }\n  function fromNodeEventEmitter(emitter, eventName, map2 = (id) =\u003e id) {\n    const fn = (...args) =\u003e result.fire(map2(...args));\n    const onFirstListenerAdd = () =\u003e emitter.on(eventName, fn);\n    const onLastListenerRemove = () =\u003e emitter.removeListener(eventName, fn);\n    const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n    return result.event;\n  }\n  Event2.fromNodeEventEmitter = fromNodeEventEmitter;\n  function fromDOMEventEmitter(emitter, eventName, map2 = (id) =\u003e id) {\n    const fn = (...args) =\u003e result.fire(map2(...args));\n    const onFirstListenerAdd = () =\u003e emitter.addEventListener(eventName, fn);\n    const onLastListenerRemove = () =\u003e emitter.removeEventListener(eventName, fn);\n    const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n    return result.event;\n  }\n  Event2.fromDOMEventEmitter = fromDOMEventEmitter;\n  function toPromise(event) {\n    return new Promise((resolve2) =\u003e once2(event)(resolve2));\n  }\n  Event2.toPromise = toPromise;\n  function fromPromise(promise) {\n    const result = new Emitter();\n    promise.then((res) =\u003e {\n      result.fire(res);\n    }, () =\u003e {\n      result.fire(void 0);\n    }).finally(() =\u003e {\n      result.dispose();\n    });\n    return result.event;\n  }\n  Event2.fromPromise = fromPromise;\n  function runAndSubscribe(event, handler, initial) {\n    handler(initial);\n    return event((e) =\u003e handler(e));\n  }\n  Event2.runAndSubscribe = runAndSubscribe;\n  function runAndSubscribeWithStore(event, handler) {\n    let store = null;\n    function run(e) {\n      store === null || store === void 0 ? void 0 : store.dispose();\n      store = new DisposableStore();\n      handler(e, store);\n    }\n    run(void 0);\n    const disposable = event((e) =\u003e run(e));\n    return toDisposable(() =\u003e {\n      disposable.dispose();\n      store === null || store === void 0 ? void 0 : store.dispose();\n    });\n  }\n  Event2.runAndSubscribeWithStore = runAndSubscribeWithStore;\n  class EmitterObserver {\n    constructor(_observable, store) {\n      this._observable = _observable;\n      this._counter = 0;\n      this._hasChanged = false;\n      const options = {\n        onWillAddFirstListener: () =\u003e {\n          _observable.addObserver(this);\n        },\n        onDidRemoveLastListener: () =\u003e {\n          _observable.removeObserver(this);\n        }\n      };\n      if (!store) {\n        _addLeakageTraceLogic(options);\n      }\n      this.emitter = new Emitter(options);\n      if (store) {\n        store.add(this.emitter);\n      }\n    }\n    beginUpdate(_observable) {\n      this._counter++;\n    }\n    handlePossibleChange(_observable) {\n    }\n    handleChange(_observable, _change) {\n      this._hasChanged = true;\n    }\n    endUpdate(_observable) {\n      this._counter--;\n      if (this._counter === 0) {\n        this._observable.reportChanges();\n        if (this._hasChanged) {\n          this._hasChanged = false;\n          this.emitter.fire(this._observable.get());\n        }\n      }\n    }\n  }\n  function fromObservable(obs, store) {\n    const observer = new EmitterObserver(obs, store);\n    return observer.emitter.event;\n  }\n  Event2.fromObservable = fromObservable;\n  function fromObservableLight(observable) {\n    return (listener, thisArgs, disposables) =\u003e {\n      let count = 0;\n      let didChange = false;\n      const observer = {\n        beginUpdate() {\n          count++;\n        },\n        endUpdate() {\n          count--;\n          if (count === 0) {\n            observable.reportChanges();\n            if (didChange) {\n              didChange = false;\n              listener.call(thisArgs);\n            }\n          }\n        },\n        handlePossibleChange() {\n        },\n        handleChange() {\n          didChange = true;\n        }\n      };\n      observable.addObserver(observer);\n      observable.reportChanges();\n      const disposable = {\n        dispose() {\n          observable.removeObserver(observer);\n        }\n      };\n      if (disposables instanceof DisposableStore) {\n        disposables.add(disposable);\n      } else if (Array.isArray(disposables)) {\n        disposables.push(disposable);\n      }\n      return disposable;\n    };\n  }\n  Event2.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nvar EventProfiling = class _EventProfiling {\n  constructor(name) {\n    this.listenerCount = 0;\n    this.invocationCount = 0;\n    this.elapsedOverall = 0;\n    this.durations = [];\n    this.name = `${name}_${_EventProfiling._idPool++}`;\n    _EventProfiling.all.add(this);\n  }\n  start(listenerCount) {\n    this._stopWatch = new StopWatch();\n    this.listenerCount = listenerCount;\n  }\n  stop() {\n    if (this._stopWatch) {\n      const elapsed = this._stopWatch.elapsed();\n      this.durations.push(elapsed);\n      this.elapsedOverall += elapsed;\n      this.invocationCount += 1;\n      this._stopWatch = void 0;\n    }\n  }\n};\nEventProfiling.all = /* @__PURE__ */ new Set();\nEventProfiling._idPool = 0;\nvar _globalLeakWarningThreshold = -1;\nvar LeakageMonitor = class {\n  constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {\n    this.threshold = threshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n  dispose() {\n    var _a4;\n    (_a4 = this._stacks) === null || _a4 === void 0 ? void 0 : _a4.clear();\n  }\n  check(stack, listenerCount) {\n    const threshold = this.threshold;\n    if (threshold \u003c= 0 || listenerCount \u003c threshold) {\n      return void 0;\n    }\n    if (!this._stacks) {\n      this._stacks = /* @__PURE__ */ new Map();\n    }\n    const count = this._stacks.get(stack.value) || 0;\n    this._stacks.set(stack.value, count + 1);\n    this._warnCountdown -= 1;\n    if (this._warnCountdown \u003c= 0) {\n      this._warnCountdown = threshold * 0.5;\n      let topStack;\n      let topCount = 0;\n      for (const [stack2, count2] of this._stacks) {\n        if (!topStack || topCount \u003c count2) {\n          topStack = stack2;\n          topCount = count2;\n        }\n      }\n      console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n      console.warn(topStack);\n    }\n    return () =\u003e {\n      const count2 = this._stacks.get(stack.value) || 0;\n      this._stacks.set(stack.value, count2 - 1);\n    };\n  }\n};\nvar Stacktrace = class _Stacktrace {\n  static create() {\n    var _a4;\n    return new _Stacktrace((_a4 = new Error().stack) !== null \u0026\u0026 _a4 !== void 0 ? _a4 : \"\");\n  }\n  constructor(value) {\n    this.value = value;\n  }\n  print() {\n    console.warn(this.value.split(\"\\n\").slice(2).join(\"\\n\"));\n  }\n};\nvar UniqueContainer = class {\n  constructor(value) {\n    this.value = value;\n  }\n};\nvar compactionThreshold = 2;\nvar forEachListener = (listeners, fn) =\u003e {\n  if (listeners instanceof UniqueContainer) {\n    fn(listeners);\n  } else {\n    for (let i = 0; i \u003c listeners.length; i++) {\n      const l = listeners[i];\n      if (l) {\n        fn(l);\n      }\n    }\n  }\n};\nvar Emitter = class {\n  constructor(options) {\n    var _a4, _b2, _c, _d, _e;\n    this._size = 0;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold \u003e 0 || ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.leakWarningThreshold) ? new LeakageMonitor((_c = (_b2 = this._options) === null || _b2 === void 0 ? void 0 : _b2.leakWarningThreshold) !== null \u0026\u0026 _c !== void 0 ? _c : _globalLeakWarningThreshold) : void 0;\n    this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : void 0;\n    this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;\n  }\n  dispose() {\n    var _a4, _b2, _c, _d;\n    if (!this._disposed) {\n      this._disposed = true;\n      if (((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) === this) {\n        this._deliveryQueue.reset();\n      }\n      if (this._listeners) {\n        if (_enableDisposeWithListenerWarning) {\n          const listeners = this._listeners;\n          queueMicrotask(() =\u003e {\n            forEachListener(listeners, (l) =\u003e {\n              var _a5;\n              return (_a5 = l.stack) === null || _a5 === void 0 ? void 0 : _a5.print();\n            });\n          });\n        }\n        this._listeners = void 0;\n        this._size = 0;\n      }\n      (_c = (_b2 = this._options) === null || _b2 === void 0 ? void 0 : _b2.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b2);\n      (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n    }\n  }\n  /**\n   * For the public to allow to subscribe\n   * to events from this Emitter\n   */\n  get event() {\n    var _a4;\n    (_a4 = this._event) !== null \u0026\u0026 _a4 !== void 0 ? _a4 : this._event = (callback, thisArgs, disposables) =\u003e {\n      var _a5, _b2, _c, _d, _e;\n      if (this._leakageMon \u0026\u0026 this._size \u003e this._leakageMon.threshold * 3) {\n        console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);\n        return Disposable.None;\n      }\n      if (this._disposed) {\n        return Disposable.None;\n      }\n      if (thisArgs) {\n        callback = callback.bind(thisArgs);\n      }\n      const contained = new UniqueContainer(callback);\n      let removeMonitor;\n      let stack;\n      if (this._leakageMon \u0026\u0026 this._size \u003e= Math.ceil(this._leakageMon.threshold * 0.2)) {\n        contained.stack = Stacktrace.create();\n        removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n      }\n      if (_enableDisposeWithListenerWarning) {\n        contained.stack = stack !== null \u0026\u0026 stack !== void 0 ? stack : Stacktrace.create();\n      }\n      if (!this._listeners) {\n        (_b2 = (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.onWillAddFirstListener) === null || _b2 === void 0 ? void 0 : _b2.call(_a5, this);\n        this._listeners = contained;\n        (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n      } else if (this._listeners instanceof UniqueContainer) {\n        (_e = this._deliveryQueue) !== null \u0026\u0026 _e !== void 0 ? _e : this._deliveryQueue = new EventDeliveryQueuePrivate();\n        this._listeners = [this._listeners, contained];\n      } else {\n        this._listeners.push(contained);\n      }\n      this._size++;\n      const result = toDisposable(() =\u003e {\n        removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n        this._removeListener(contained);\n      });\n      if (disposables instanceof DisposableStore) {\n        disposables.add(result);\n      } else if (Array.isArray(disposables)) {\n        disposables.push(result);\n      }\n      return result;\n    };\n    return this._event;\n  }\n  _removeListener(listener) {\n    var _a4, _b2, _c, _d;\n    (_b2 = (_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onWillRemoveListener) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, this);\n    if (!this._listeners) {\n      return;\n    }\n    if (this._size === 1) {\n      this._listeners = void 0;\n      (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n      this._size = 0;\n      return;\n    }\n    const listeners = this._listeners;\n    const index = listeners.indexOf(listener);\n    if (index === -1) {\n      console.log(\"disposed?\", this._disposed);\n      console.log(\"size?\", this._size);\n      console.log(\"arr?\", JSON.stringify(this._listeners));\n      throw new Error(\"Attempted to dispose unknown listener\");\n    }\n    this._size--;\n    listeners[index] = void 0;\n    const adjustDeliveryQueue = this._deliveryQueue.current === this;\n    if (this._size * compactionThreshold \u003c= listeners.length) {\n      let n = 0;\n      for (let i = 0; i \u003c listeners.length; i++) {\n        if (listeners[i]) {\n          listeners[n++] = listeners[i];\n        } else if (adjustDeliveryQueue) {\n          this._deliveryQueue.end--;\n          if (n \u003c this._deliveryQueue.i) {\n            this._deliveryQueue.i--;\n          }\n        }\n      }\n      listeners.length = n;\n    }\n  }\n  _deliver(listener, value) {\n    var _a4;\n    if (!listener) {\n      return;\n    }\n    const errorHandler2 = ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onListenerError) || onUnexpectedError;\n    if (!errorHandler2) {\n      listener.value(value);\n      return;\n    }\n    try {\n      listener.value(value);\n    } catch (e) {\n      errorHandler2(e);\n    }\n  }\n  /** Delivers items in the queue. Assumes the queue is ready to go. */\n  _deliverQueue(dq) {\n    const listeners = dq.current._listeners;\n    while (dq.i \u003c dq.end) {\n      this._deliver(listeners[dq.i++], dq.value);\n    }\n    dq.reset();\n  }\n  /**\n   * To be kept private to fire an event to\n   * subscribers\n   */\n  fire(event) {\n    var _a4, _b2, _c, _d;\n    if ((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) {\n      this._deliverQueue(this._deliveryQueue);\n      (_b2 = this._perfMon) === null || _b2 === void 0 ? void 0 : _b2.stop();\n    }\n    (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);\n    if (!this._listeners) {\n    } else if (this._listeners instanceof UniqueContainer) {\n      this._deliver(this._listeners, event);\n    } else {\n      const dq = this._deliveryQueue;\n      dq.enqueue(this, event, this._listeners.length);\n      this._deliverQueue(dq);\n    }\n    (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();\n  }\n  hasListeners() {\n    return this._size \u003e 0;\n  }\n};\nvar EventDeliveryQueuePrivate = class {\n  constructor() {\n    this.i = -1;\n    this.end = 0;\n  }\n  enqueue(emitter, value, end) {\n    this.i = 0;\n    this.end = end;\n    this.current = emitter;\n    this.value = value;\n  }\n  reset() {\n    this.i = this.end;\n    this.current = void 0;\n    this.value = void 0;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/types.js\nfunction isString(str) {\n  return typeof str === \"string\";\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/objects.js\nfunction getAllPropertyNames(obj) {\n  let res = [];\n  while (Object.prototype !== obj) {\n    res = res.concat(Object.getOwnPropertyNames(obj));\n    obj = Object.getPrototypeOf(obj);\n  }\n  return res;\n}\nfunction getAllMethodNames(obj) {\n  const methods = [];\n  for (const prop of getAllPropertyNames(obj)) {\n    if (typeof obj[prop] === \"function\") {\n      methods.push(prop);\n    }\n  }\n  return methods;\n}\nfunction createProxyObject(methodNames, invoke) {\n  const createProxyMethod = (method) =\u003e {\n    return function() {\n      const args = Array.prototype.slice.call(arguments, 0);\n      return invoke(method, args);\n    };\n  };\n  const result = {};\n  for (const methodName of methodNames) {\n    result[methodName] = createProxyMethod(methodName);\n  }\n  return result;\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/nls.js\nvar isPseudo = typeof document !== \"undefined\" \u0026\u0026 document.location \u0026\u0026 document.location.hash.indexOf(\"pseudo=true\") \u003e= 0;\nfunction _format(message, args) {\n  let result;\n  if (args.length === 0) {\n    result = message;\n  } else {\n    result = message.replace(/\\{(\\d+)\\}/g, (match, rest) =\u003e {\n      const index = rest[0];\n      const arg = args[index];\n      let result2 = match;\n      if (typeof arg === \"string\") {\n        result2 = arg;\n      } else if (typeof arg === \"number\" || typeof arg === \"boolean\" || arg === void 0 || arg === null) {\n        result2 = String(arg);\n      }\n      return result2;\n    });\n  }\n  if (isPseudo) {\n    result = \"\\uFF3B\" + result.replace(/[aouei]/g, \"$\u0026$\u0026\") + \"\\uFF3D\";\n  }\n  return result;\n}\nfunction localize(data, message, ...args) {\n  return _format(message, args);\n}\nfunction getConfiguredDefaultLocale(_) {\n  return void 0;\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/platform.js\nvar _a;\nvar LANGUAGE_DEFAULT = \"en\";\nvar _isWindows = false;\nvar _isMacintosh = false;\nvar _isLinux = false;\nvar _isLinuxSnap = false;\nvar _isNative = false;\nvar _isWeb = false;\nvar _isElectron = false;\nvar _isIOS = false;\nvar _isCI = false;\nvar _isMobile = false;\nvar _locale = void 0;\nvar _language = LANGUAGE_DEFAULT;\nvar _platformLocale = LANGUAGE_DEFAULT;\nvar _translationsConfigFile = void 0;\nvar _userAgent = void 0;\nvar $globalThis = globalThis;\nvar nodeProcess = void 0;\nif (typeof $globalThis.vscode !== \"undefined\" \u0026\u0026 typeof $globalThis.vscode.process !== \"undefined\") {\n  nodeProcess = $globalThis.vscode.process;\n} else if (typeof __Process$ !== \"undefined\") {\n  nodeProcess = __Process$;\n}\nvar isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === \"string\";\nvar isElectronRenderer = isElectronProcess \u0026\u0026 (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === \"renderer\";\nif (typeof navigator === \"object\" \u0026\u0026 !isElectronRenderer) {\n  _userAgent = navigator.userAgent;\n  _isWindows = _userAgent.indexOf(\"Windows\") \u003e= 0;\n  _isMacintosh = _userAgent.indexOf(\"Macintosh\") \u003e= 0;\n  _isIOS = (_userAgent.indexOf(\"Macintosh\") \u003e= 0 || _userAgent.indexOf(\"iPad\") \u003e= 0 || _userAgent.indexOf(\"iPhone\") \u003e= 0) \u0026\u0026 !!navigator.maxTouchPoints \u0026\u0026 navigator.maxTouchPoints \u003e 0;\n  _isLinux = _userAgent.indexOf(\"Linux\") \u003e= 0;\n  _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf(\"Mobi\")) \u003e= 0;\n  _isWeb = true;\n  const configuredLocale = getConfiguredDefaultLocale(\n    // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`\n    // to ensure that the NLS AMD Loader plugin has been loaded and configured.\n    // This is because the loader plugin decides what the default locale is based on\n    // how it's able to resolve the strings.\n    localize({ key: \"ensureLoaderPluginIsLoaded\", comment: [\"{Locked}\"] }, \"_\")\n  );\n  _locale = configuredLocale || LANGUAGE_DEFAULT;\n  _language = _locale;\n  _platformLocale = navigator.language;\n} else if (typeof nodeProcess === \"object\") {\n  _isWindows = nodeProcess.platform === \"win32\";\n  _isMacintosh = nodeProcess.platform === \"darwin\";\n  _isLinux = nodeProcess.platform === \"linux\";\n  _isLinuxSnap = _isLinux \u0026\u0026 !!nodeProcess.env[\"SNAP\"] \u0026\u0026 !!nodeProcess.env[\"SNAP_REVISION\"];\n  _isElectron = isElectronProcess;\n  _isCI = !!nodeProcess.env[\"CI\"] || !!nodeProcess.env[\"BUILD_ARTIFACTSTAGINGDIRECTORY\"];\n  _locale = LANGUAGE_DEFAULT;\n  _language = LANGUAGE_DEFAULT;\n  const rawNlsConfig = nodeProcess.env[\"VSCODE_NLS_CONFIG\"];\n  if (rawNlsConfig) {\n    try {\n      const nlsConfig = JSON.parse(rawNlsConfig);\n      const resolved = nlsConfig.availableLanguages[\"*\"];\n      _locale = nlsConfig.locale;\n      _platformLocale = nlsConfig.osLocale;\n      _language = resolved ? resolved : LANGUAGE_DEFAULT;\n      _translationsConfigFile = nlsConfig._translationsConfigFile;\n    } catch (e) {\n    }\n  }\n  _isNative = true;\n} else {\n  console.error(\"Unable to resolve platform.\");\n}\nvar _platform = 0;\nif (_isMacintosh) {\n  _platform = 1;\n} else if (_isWindows) {\n  _platform = 3;\n} else if (_isLinux) {\n  _platform = 2;\n}\nvar isWindows = _isWindows;\nvar isMacintosh = _isMacintosh;\nvar isWebWorker = _isWeb \u0026\u0026 typeof $globalThis.importScripts === \"function\";\nvar webWorkerOrigin = isWebWorker ? $globalThis.origin : void 0;\nvar userAgent = _userAgent;\nvar setTimeout0IsFaster = typeof $globalThis.postMessage === \"function\" \u0026\u0026 !$globalThis.importScripts;\nvar setTimeout0 = (() =\u003e {\n  if (setTimeout0IsFaster) {\n    const pending = [];\n    $globalThis.addEventListener(\"message\", (e) =\u003e {\n      if (e.data \u0026\u0026 e.data.vscodeScheduleAsyncWork) {\n        for (let i = 0, len = pending.length; i \u003c len; i++) {\n          const candidate = pending[i];\n          if (candidate.id === e.data.vscodeScheduleAsyncWork) {\n            pending.splice(i, 1);\n            candidate.callback();\n            return;\n          }\n        }\n      }\n    });\n    let lastId = 0;\n    return (callback) =\u003e {\n      const myId = ++lastId;\n      pending.push({\n        id: myId,\n        callback\n      });\n      $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, \"*\");\n    };\n  }\n  return (callback) =\u003e setTimeout(callback);\n})();\nvar isChrome = !!(userAgent \u0026\u0026 userAgent.indexOf(\"Chrome\") \u003e= 0);\nvar isFirefox = !!(userAgent \u0026\u0026 userAgent.indexOf(\"Firefox\") \u003e= 0);\nvar isSafari = !!(!isChrome \u0026\u0026 (userAgent \u0026\u0026 userAgent.indexOf(\"Safari\") \u003e= 0));\nvar isEdge = !!(userAgent \u0026\u0026 userAgent.indexOf(\"Edg/\") \u003e= 0);\nvar isAndroid = !!(userAgent \u0026\u0026 userAgent.indexOf(\"Android\") \u003e= 0);\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/cache.js\nvar LRUCachedFunction = class {\n  constructor(fn) {\n    this.fn = fn;\n    this.lastCache = void 0;\n    this.lastArgKey = void 0;\n  }\n  get(arg) {\n    const key = JSON.stringify(arg);\n    if (this.lastArgKey !== key) {\n      this.lastArgKey = key;\n      this.lastCache = this.fn(arg);\n    }\n    return this.lastCache;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js\nvar Lazy = class {\n  constructor(executor) {\n    this.executor = executor;\n    this._didRun = false;\n  }\n  /**\n   * Get the wrapped value.\n   *\n   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n   */\n  get value() {\n    if (!this._didRun) {\n      try {\n        this._value = this.executor();\n      } catch (err) {\n        this._error = err;\n      } finally {\n        this._didRun = true;\n      }\n    }\n    if (this._error) {\n      throw this._error;\n    }\n    return this._value;\n  }\n  /**\n   * Get the wrapped value without forcing evaluation.\n   */\n  get rawValue() {\n    return this._value;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/strings.js\nvar _a2;\nfunction escapeRegExpCharacters(value) {\n  return value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, \"\\\\$\u0026\");\n}\nfunction splitLines(str) {\n  return str.split(/\\r\\n|\\r|\\n/);\n}\nfunction firstNonWhitespaceIndex(str) {\n  for (let i = 0, len = str.length; i \u003c len; i++) {\n    const chCode = str.charCodeAt(i);\n    if (chCode !== 32 \u0026\u0026 chCode !== 9) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction lastNonWhitespaceIndex(str, startIndex = str.length - 1) {\n  for (let i = startIndex; i \u003e= 0; i--) {\n    const chCode = str.charCodeAt(i);\n    if (chCode !== 32 \u0026\u0026 chCode !== 9) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction isUpperAsciiLetter(code) {\n  return code \u003e= 65 \u0026\u0026 code \u003c= 90;\n}\nfunction isHighSurrogate(charCode) {\n  return 55296 \u003c= charCode \u0026\u0026 charCode \u003c= 56319;\n}\nfunction isLowSurrogate(charCode) {\n  return 56320 \u003c= charCode \u0026\u0026 charCode \u003c= 57343;\n}\nfunction computeCodePoint(highSurrogate, lowSurrogate) {\n  return (highSurrogate - 55296 \u003c\u003c 10) + (lowSurrogate - 56320) + 65536;\n}\nfunction getNextCodePoint(str, len, offset) {\n  const charCode = str.charCodeAt(offset);\n  if (isHighSurrogate(charCode) \u0026\u0026 offset + 1 \u003c len) {\n    const nextCharCode = str.charCodeAt(offset + 1);\n    if (isLowSurrogate(nextCharCode)) {\n      return computeCodePoint(charCode, nextCharCode);\n    }\n  }\n  return charCode;\n}\nvar IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\nfunction isBasicASCII(str) {\n  return IS_BASIC_ASCII.test(str);\n}\nvar UTF8_BOM_CHARACTER = String.fromCharCode(\n  65279\n  /* CharCode.UTF8_BOM */\n);\nvar GraphemeBreakTree = class _GraphemeBreakTree {\n  static getInstance() {\n    if (!_GraphemeBreakTree._INSTANCE) {\n      _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();\n    }\n    return _GraphemeBreakTree._INSTANCE;\n  }\n  constructor() {\n    this._data = getGraphemeBreakRawData();\n  }\n  getGraphemeBreakType(codePoint) {\n    if (codePoint \u003c 32) {\n      if (codePoint === 10) {\n        return 3;\n      }\n      if (codePoint === 13) {\n        return 2;\n      }\n      return 4;\n    }\n    if (codePoint \u003c 127) {\n      return 0;\n    }\n    const data = this._data;\n    const nodeCount = data.length / 3;\n    let nodeIndex = 1;\n    while (nodeIndex \u003c= nodeCount) {\n      if (codePoint \u003c data[3 * nodeIndex]) {\n        nodeIndex = 2 * nodeIndex;\n      } else if (codePoint \u003e data[3 * nodeIndex + 1]) {\n        nodeIndex = 2 * nodeIndex + 1;\n      } else {\n        return data[3 * nodeIndex + 2];\n      }\n    }\n    return 0;\n  }\n};\nGraphemeBreakTree._INSTANCE = null;\nfunction getGraphemeBreakRawData() {\n  return JSON.parse(\"[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]\");\n}\nvar AmbiguousCharacters = class {\n  static getInstance(locales) {\n    return _a2.cache.get(Array.from(locales));\n  }\n  static getLocales() {\n    return _a2._locales.value;\n  }\n  constructor(confusableDictionary) {\n    this.confusableDictionary = confusableDictionary;\n  }\n  isAmbiguous(codePoint) {\n    return this.confusableDictionary.has(codePoint);\n  }\n  /**\n   * Returns the non basic ASCII code point that the given code point can be confused,\n   * or undefined if such code point does note exist.\n   */\n  getPrimaryConfusable(codePoint) {\n    return this.confusableDictionary.get(codePoint);\n  }\n  getConfusableCodePoints() {\n    return new Set(this.confusableDictionary.keys());\n  }\n};\n_a2 = AmbiguousCharacters;\nAmbiguousCharacters.ambiguousCharacterData = new Lazy(() =\u003e {\n  return JSON.parse('{\"_common\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],\"_default\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"cs\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"de\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"es\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"fr\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"it\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ja\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\"ko\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pl\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pt-BR\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"qps-ploc\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ru\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"tr\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"zh-hans\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\"zh-hant\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');\n});\nAmbiguousCharacters.cache = new LRUCachedFunction((locales) =\u003e {\n  function arrayToMap(arr) {\n    const result = /* @__PURE__ */ new Map();\n    for (let i = 0; i \u003c arr.length; i += 2) {\n      result.set(arr[i], arr[i + 1]);\n    }\n    return result;\n  }\n  function mergeMaps(map1, map2) {\n    const result = new Map(map1);\n    for (const [key, value] of map2) {\n      result.set(key, value);\n    }\n    return result;\n  }\n  function intersectMaps(map1, map2) {\n    if (!map1) {\n      return map2;\n    }\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of map1) {\n      if (map2.has(key)) {\n        result.set(key, value);\n      }\n    }\n    return result;\n  }\n  const data = _a2.ambiguousCharacterData.value;\n  let filteredLocales = locales.filter((l) =\u003e !l.startsWith(\"_\") \u0026\u0026 l in data);\n  if (filteredLocales.length === 0) {\n    filteredLocales = [\"_default\"];\n  }\n  let languageSpecificMap = void 0;\n  for (const locale of filteredLocales) {\n    const map2 = arrayToMap(data[locale]);\n    languageSpecificMap = intersectMaps(languageSpecificMap, map2);\n  }\n  const commonMap = arrayToMap(data[\"_common\"]);\n  const map = mergeMaps(commonMap, languageSpecificMap);\n  return new _a2(map);\n});\nAmbiguousCharacters._locales = new Lazy(() =\u003e Object.keys(_a2.ambiguousCharacterData.value).filter((k) =\u003e !k.startsWith(\"_\")));\nvar InvisibleCharacters = class _InvisibleCharacters {\n  static getRawData() {\n    return JSON.parse(\"[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]\");\n  }\n  static getData() {\n    if (!this._data) {\n      this._data = new Set(_InvisibleCharacters.getRawData());\n    }\n    return this._data;\n  }\n  static isInvisibleCharacter(codePoint) {\n    return _InvisibleCharacters.getData().has(codePoint);\n  }\n  static get codePoints() {\n    return _InvisibleCharacters.getData();\n  }\n};\nInvisibleCharacters._data = void 0;\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js\nvar INITIALIZE = \"$initialize\";\nvar RequestMessage = class {\n  constructor(vsWorker, req, method, args) {\n    this.vsWorker = vsWorker;\n    this.req = req;\n    this.method = method;\n    this.args = args;\n    this.type = 0;\n  }\n};\nvar ReplyMessage = class {\n  constructor(vsWorker, seq, res, err) {\n    this.vsWorker = vsWorker;\n    this.seq = seq;\n    this.res = res;\n    this.err = err;\n    this.type = 1;\n  }\n};\nvar SubscribeEventMessage = class {\n  constructor(vsWorker, req, eventName, arg) {\n    this.vsWorker = vsWorker;\n    this.req = req;\n    this.eventName = eventName;\n    this.arg = arg;\n    this.type = 2;\n  }\n};\nvar EventMessage = class {\n  constructor(vsWorker, req, event) {\n    this.vsWorker = vsWorker;\n    this.req = req;\n    this.event = event;\n    this.type = 3;\n  }\n};\nvar UnsubscribeEventMessage = class {\n  constructor(vsWorker, req) {\n    this.vsWorker = vsWorker;\n    this.req = req;\n    this.type = 4;\n  }\n};\nvar SimpleWorkerProtocol = class {\n  constructor(handler) {\n    this._workerId = -1;\n    this._handler = handler;\n    this._lastSentReq = 0;\n    this._pendingReplies = /* @__PURE__ */ Object.create(null);\n    this._pendingEmitters = /* @__PURE__ */ new Map();\n    this._pendingEvents = /* @__PURE__ */ new Map();\n  }\n  setWorkerId(workerId) {\n    this._workerId = workerId;\n  }\n  sendMessage(method, args) {\n    const req = String(++this._lastSentReq);\n    return new Promise((resolve2, reject) =\u003e {\n      this._pendingReplies[req] = {\n        resolve: resolve2,\n        reject\n      };\n      this._send(new RequestMessage(this._workerId, req, method, args));\n    });\n  }\n  listen(eventName, arg) {\n    let req = null;\n    const emitter = new Emitter({\n      onWillAddFirstListener: () =\u003e {\n        req = String(++this._lastSentReq);\n        this._pendingEmitters.set(req, emitter);\n        this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));\n      },\n      onDidRemoveLastListener: () =\u003e {\n        this._pendingEmitters.delete(req);\n        this._send(new UnsubscribeEventMessage(this._workerId, req));\n        req = null;\n      }\n    });\n    return emitter.event;\n  }\n  handleMessage(message) {\n    if (!message || !message.vsWorker) {\n      return;\n    }\n    if (this._workerId !== -1 \u0026\u0026 message.vsWorker !== this._workerId) {\n      return;\n    }\n    this._handleMessage(message);\n  }\n  _handleMessage(msg) {\n    switch (msg.type) {\n      case 1:\n        return this._handleReplyMessage(msg);\n      case 0:\n        return this._handleRequestMessage(msg);\n      case 2:\n        return this._handleSubscribeEventMessage(msg);\n      case 3:\n        return this._handleEventMessage(msg);\n      case 4:\n        return this._handleUnsubscribeEventMessage(msg);\n    }\n  }\n  _handleReplyMessage(replyMessage) {\n    if (!this._pendingReplies[replyMessage.seq]) {\n      console.warn(\"Got reply to unknown seq\");\n      return;\n    }\n    const reply = this._pendingReplies[replyMessage.seq];\n    delete this._pendingReplies[replyMessage.seq];\n    if (replyMessage.err) {\n      let err = replyMessage.err;\n      if (replyMessage.err.$isError) {\n        err = new Error();\n        err.name = replyMessage.err.name;\n        err.message = replyMessage.err.message;\n        err.stack = replyMessage.err.stack;\n      }\n      reply.reject(err);\n      return;\n    }\n    reply.resolve(replyMessage.res);\n  }\n  _handleRequestMessage(requestMessage) {\n    const req = requestMessage.req;\n    const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);\n    result.then((r) =\u003e {\n      this._send(new ReplyMessage(this._workerId, req, r, void 0));\n    }, (e) =\u003e {\n      if (e.detail instanceof Error) {\n        e.detail = transformErrorForSerialization(e.detail);\n      }\n      this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));\n    });\n  }\n  _handleSubscribeEventMessage(msg) {\n    const req = msg.req;\n    const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) =\u003e {\n      this._send(new EventMessage(this._workerId, req, event));\n    });\n    this._pendingEvents.set(req, disposable);\n  }\n  _handleEventMessage(msg) {\n    if (!this._pendingEmitters.has(msg.req)) {\n      console.warn(\"Got event for unknown req\");\n      return;\n    }\n    this._pendingEmitters.get(msg.req).fire(msg.event);\n  }\n  _handleUnsubscribeEventMessage(msg) {\n    if (!this._pendingEvents.has(msg.req)) {\n      console.warn(\"Got unsubscribe for unknown req\");\n      return;\n    }\n    this._pendingEvents.get(msg.req).dispose();\n    this._pendingEvents.delete(msg.req);\n  }\n  _send(msg) {\n    const transfer = [];\n    if (msg.type === 0) {\n      for (let i = 0; i \u003c msg.args.length; i++) {\n        if (msg.args[i] instanceof ArrayBuffer) {\n          transfer.push(msg.args[i]);\n        }\n      }\n    } else if (msg.type === 1) {\n      if (msg.res instanceof ArrayBuffer) {\n        transfer.push(msg.res);\n      }\n    }\n    this._handler.sendMessage(msg, transfer);\n  }\n};\nfunction propertyIsEvent(name) {\n  return name[0] === \"o\" \u0026\u0026 name[1] === \"n\" \u0026\u0026 isUpperAsciiLetter(name.charCodeAt(2));\n}\nfunction propertyIsDynamicEvent(name) {\n  return /^onDynamic/.test(name) \u0026\u0026 isUpperAsciiLetter(name.charCodeAt(9));\n}\nfunction createProxyObject2(methodNames, invoke, proxyListen) {\n  const createProxyMethod = (method) =\u003e {\n    return function() {\n      const args = Array.prototype.slice.call(arguments, 0);\n      return invoke(method, args);\n    };\n  };\n  const createProxyDynamicEvent = (eventName) =\u003e {\n    return function(arg) {\n      return proxyListen(eventName, arg);\n    };\n  };\n  const result = {};\n  for (const methodName of methodNames) {\n    if (propertyIsDynamicEvent(methodName)) {\n      result[methodName] = createProxyDynamicEvent(methodName);\n      continue;\n    }\n    if (propertyIsEvent(methodName)) {\n      result[methodName] = proxyListen(methodName, void 0);\n      continue;\n    }\n    result[methodName] = createProxyMethod(methodName);\n  }\n  return result;\n}\nvar SimpleWorkerServer = class {\n  constructor(postMessage, requestHandlerFactory) {\n    this._requestHandlerFactory = requestHandlerFactory;\n    this._requestHandler = null;\n    this._protocol = new SimpleWorkerProtocol({\n      sendMessage: (msg, transfer) =\u003e {\n        postMessage(msg, transfer);\n      },\n      handleMessage: (method, args) =\u003e this._handleMessage(method, args),\n      handleEvent: (eventName, arg) =\u003e this._handleEvent(eventName, arg)\n    });\n  }\n  onmessage(msg) {\n    this._protocol.handleMessage(msg);\n  }\n  _handleMessage(method, args) {\n    if (method === INITIALIZE) {\n      return this.initialize(args[0], args[1], args[2], args[3]);\n    }\n    if (!this._requestHandler || typeof this._requestHandler[method] !== \"function\") {\n      return Promise.reject(new Error(\"Missing requestHandler or method: \" + method));\n    }\n    try {\n      return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  _handleEvent(eventName, arg) {\n    if (!this._requestHandler) {\n      throw new Error(`Missing requestHandler`);\n    }\n    if (propertyIsDynamicEvent(eventName)) {\n      const event = this._requestHandler[eventName].call(this._requestHandler, arg);\n      if (typeof event !== \"function\") {\n        throw new Error(`Missing dynamic event ${eventName} on request handler.`);\n      }\n      return event;\n    }\n    if (propertyIsEvent(eventName)) {\n      const event = this._requestHandler[eventName];\n      if (typeof event !== \"function\") {\n        throw new Error(`Missing event ${eventName} on request handler.`);\n      }\n      return event;\n    }\n    throw new Error(`Malformed event name ${eventName}`);\n  }\n  initialize(workerId, loaderConfig, moduleId, hostMethods) {\n    this._protocol.setWorkerId(workerId);\n    const proxyMethodRequest = (method, args) =\u003e {\n      return this._protocol.sendMessage(method, args);\n    };\n    const proxyListen = (eventName, arg) =\u003e {\n      return this._protocol.listen(eventName, arg);\n    };\n    const hostProxy = createProxyObject2(hostMethods, proxyMethodRequest, proxyListen);\n    if (this._requestHandlerFactory) {\n      this._requestHandler = this._requestHandlerFactory(hostProxy);\n      return Promise.resolve(getAllMethodNames(this._requestHandler));\n    }\n    if (loaderConfig) {\n      if (typeof loaderConfig.baseUrl !== \"undefined\") {\n        delete loaderConfig[\"baseUrl\"];\n      }\n      if (typeof loaderConfig.paths !== \"undefined\") {\n        if (typeof loaderConfig.paths.vs !== \"undefined\") {\n          delete loaderConfig.paths[\"vs\"];\n        }\n      }\n      if (typeof loaderConfig.trustedTypesPolicy !== void 0) {\n        delete loaderConfig[\"trustedTypesPolicy\"];\n      }\n      loaderConfig.catchError = true;\n      globalThis.require.config(loaderConfig);\n    }\n    return new Promise((resolve2, reject) =\u003e {\n      const req = globalThis.require;\n      req([moduleId], (module) =\u003e {\n        this._requestHandler = module.create(hostProxy);\n        if (!this._requestHandler) {\n          reject(new Error(`No RequestHandler!`));\n          return;\n        }\n        resolve2(getAllMethodNames(this._requestHandler));\n      }, reject);\n    });\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js\nvar DiffChange = class {\n  /**\n   * Constructs a new DiffChange with the given sequence information\n   * and content.\n   */\n  constructor(originalStart, originalLength, modifiedStart, modifiedLength) {\n    this.originalStart = originalStart;\n    this.originalLength = originalLength;\n    this.modifiedStart = modifiedStart;\n    this.modifiedLength = modifiedLength;\n  }\n  /**\n   * The end point (exclusive) of the change in the original sequence.\n   */\n  getOriginalEnd() {\n    return this.originalStart + this.originalLength;\n  }\n  /**\n   * The end point (exclusive) of the change in the modified sequence.\n   */\n  getModifiedEnd() {\n    return this.modifiedStart + this.modifiedLength;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/hash.js\nfunction numberHash(val, initialHashVal) {\n  return (initialHashVal \u003c\u003c 5) - initialHashVal + val | 0;\n}\nfunction stringHash(s, hashVal) {\n  hashVal = numberHash(149417, hashVal);\n  for (let i = 0, length = s.length; i \u003c length; i++) {\n    hashVal = numberHash(s.charCodeAt(i), hashVal);\n  }\n  return hashVal;\n}\nfunction leftRotate(value, bits, totalBits = 32) {\n  const delta = totalBits - bits;\n  const mask = ~((1 \u003c\u003c delta) - 1);\n  return (value \u003c\u003c bits | (mask \u0026 value) \u003e\u003e\u003e delta) \u003e\u003e\u003e 0;\n}\nfunction fill(dest, index = 0, count = dest.byteLength, value = 0) {\n  for (let i = 0; i \u003c count; i++) {\n    dest[index + i] = value;\n  }\n}\nfunction leftPad(value, length, char = \"0\") {\n  while (value.length \u003c length) {\n    value = char + value;\n  }\n  return value;\n}\nfunction toHexString(bufferOrValue, bitsize = 32) {\n  if (bufferOrValue instanceof ArrayBuffer) {\n    return Array.from(new Uint8Array(bufferOrValue)).map((b) =\u003e b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n  return leftPad((bufferOrValue \u003e\u003e\u003e 0).toString(16), bitsize / 4);\n}\nvar StringSHA1 = class _StringSHA1 {\n  constructor() {\n    this._h0 = 1732584193;\n    this._h1 = 4023233417;\n    this._h2 = 2562383102;\n    this._h3 = 271733878;\n    this._h4 = 3285377520;\n    this._buff = new Uint8Array(\n      64 + 3\n      /* to fit any utf-8 */\n    );\n    this._buffDV = new DataView(this._buff.buffer);\n    this._buffLen = 0;\n    this._totalLen = 0;\n    this._leftoverHighSurrogate = 0;\n    this._finished = false;\n  }\n  update(str) {\n    const strLen = str.length;\n    if (strLen === 0) {\n      return;\n    }\n    const buff = this._buff;\n    let buffLen = this._buffLen;\n    let leftoverHighSurrogate = this._leftoverHighSurrogate;\n    let charCode;\n    let offset;\n    if (leftoverHighSurrogate !== 0) {\n      charCode = leftoverHighSurrogate;\n      offset = -1;\n      leftoverHighSurrogate = 0;\n    } else {\n      charCode = str.charCodeAt(0);\n      offset = 0;\n    }\n    while (true) {\n      let codePoint = charCode;\n      if (isHighSurrogate(charCode)) {\n        if (offset + 1 \u003c strLen) {\n          const nextCharCode = str.charCodeAt(offset + 1);\n          if (isLowSurrogate(nextCharCode)) {\n            offset++;\n            codePoint = computeCodePoint(charCode, nextCharCode);\n          } else {\n            codePoint = 65533;\n          }\n        } else {\n          leftoverHighSurrogate = charCode;\n          break;\n        }\n      } else if (isLowSurrogate(charCode)) {\n        codePoint = 65533;\n      }\n      buffLen = this._push(buff, buffLen, codePoint);\n      offset++;\n      if (offset \u003c strLen) {\n        charCode = str.charCodeAt(offset);\n      } else {\n        break;\n      }\n    }\n    this._buffLen = buffLen;\n    this._leftoverHighSurrogate = leftoverHighSurrogate;\n  }\n  _push(buff, buffLen, codePoint) {\n    if (codePoint \u003c 128) {\n      buff[buffLen++] = codePoint;\n    } else if (codePoint \u003c 2048) {\n      buff[buffLen++] = 192 | (codePoint \u0026 1984) \u003e\u003e\u003e 6;\n      buff[buffLen++] = 128 | (codePoint \u0026 63) \u003e\u003e\u003e 0;\n    } else if (codePoint \u003c 65536) {\n      buff[buffLen++] = 224 | (codePoint \u0026 61440) \u003e\u003e\u003e 12;\n      buff[buffLen++] = 128 | (codePoint \u0026 4032) \u003e\u003e\u003e 6;\n      buff[buffLen++] = 128 | (codePoint \u0026 63) \u003e\u003e\u003e 0;\n    } else {\n      buff[buffLen++] = 240 | (codePoint \u0026 1835008) \u003e\u003e\u003e 18;\n      buff[buffLen++] = 128 | (codePoint \u0026 258048) \u003e\u003e\u003e 12;\n      buff[buffLen++] = 128 | (codePoint \u0026 4032) \u003e\u003e\u003e 6;\n      buff[buffLen++] = 128 | (codePoint \u0026 63) \u003e\u003e\u003e 0;\n    }\n    if (buffLen \u003e= 64) {\n      this._step();\n      buffLen -= 64;\n      this._totalLen += 64;\n      buff[0] = buff[64 + 0];\n      buff[1] = buff[64 + 1];\n      buff[2] = buff[64 + 2];\n    }\n    return buffLen;\n  }\n  digest() {\n    if (!this._finished) {\n      this._finished = true;\n      if (this._leftoverHighSurrogate) {\n        this._leftoverHighSurrogate = 0;\n        this._buffLen = this._push(\n          this._buff,\n          this._buffLen,\n          65533\n          /* SHA1Constant.UNICODE_REPLACEMENT */\n        );\n      }\n      this._totalLen += this._buffLen;\n      this._wrapUp();\n    }\n    return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n  }\n  _wrapUp() {\n    this._buff[this._buffLen++] = 128;\n    fill(this._buff, this._buffLen);\n    if (this._buffLen \u003e 56) {\n      this._step();\n      fill(this._buff);\n    }\n    const ml = 8 * this._totalLen;\n    this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n    this._buffDV.setUint32(60, ml % 4294967296, false);\n    this._step();\n  }\n  _step() {\n    const bigBlock32 = _StringSHA1._bigBlock32;\n    const data = this._buffDV;\n    for (let j = 0; j \u003c 64; j += 4) {\n      bigBlock32.setUint32(j, data.getUint32(j, false), false);\n    }\n    for (let j = 64; j \u003c 320; j += 4) {\n      bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);\n    }\n    let a2 = this._h0;\n    let b = this._h1;\n    let c = this._h2;\n    let d = this._h3;\n    let e = this._h4;\n    let f2, k;\n    let temp;\n    for (let j = 0; j \u003c 80; j++) {\n      if (j \u003c 20) {\n        f2 = b \u0026 c | ~b \u0026 d;\n        k = 1518500249;\n      } else if (j \u003c 40) {\n        f2 = b ^ c ^ d;\n        k = 1859775393;\n      } else if (j \u003c 60) {\n        f2 = b \u0026 c | b \u0026 d | c \u0026 d;\n        k = 2400959708;\n      } else {\n        f2 = b ^ c ^ d;\n        k = 3395469782;\n      }\n      temp = leftRotate(a2, 5) + f2 + e + k + bigBlock32.getUint32(j * 4, false) \u0026 4294967295;\n      e = d;\n      d = c;\n      c = leftRotate(b, 30);\n      b = a2;\n      a2 = temp;\n    }\n    this._h0 = this._h0 + a2 \u0026 4294967295;\n    this._h1 = this._h1 + b \u0026 4294967295;\n    this._h2 = this._h2 + c \u0026 4294967295;\n    this._h3 = this._h3 + d \u0026 4294967295;\n    this._h4 = this._h4 + e \u0026 4294967295;\n  }\n};\nStringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js\nvar StringDiffSequence = class {\n  constructor(source) {\n    this.source = source;\n  }\n  getElements() {\n    const source = this.source;\n    const characters = new Int32Array(source.length);\n    for (let i = 0, len = source.length; i \u003c len; i++) {\n      characters[i] = source.charCodeAt(i);\n    }\n    return characters;\n  }\n};\nfunction stringDiff(original, modified, pretty) {\n  return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\nvar Debug = class {\n  static Assert(condition, message) {\n    if (!condition) {\n      throw new Error(message);\n    }\n  }\n};\nvar MyArray = class {\n  /**\n   * Copies a range of elements from an Array starting at the specified source index and pastes\n   * them to another Array starting at the specified destination index. The length and the indexes\n   * are specified as 64-bit integers.\n   * sourceArray:\n   *\t\tThe Array that contains the data to copy.\n   * sourceIndex:\n   *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n   * destinationArray:\n   *\t\tThe Array that receives the data.\n   * destinationIndex:\n   *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n   * length:\n   *\t\tA 64-bit integer that represents the number of elements to copy.\n   */\n  static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n    for (let i = 0; i \u003c length; i++) {\n      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n    }\n  }\n  static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n    for (let i = 0; i \u003c length; i++) {\n      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n    }\n  }\n};\nvar DiffChangeHelper = class {\n  /**\n   * Constructs a new DiffChangeHelper for the given DiffSequences.\n   */\n  constructor() {\n    this.m_changes = [];\n    this.m_originalStart = 1073741824;\n    this.m_modifiedStart = 1073741824;\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n  }\n  /**\n   * Marks the beginning of the next change in the set of differences.\n   */\n  MarkNextChange() {\n    if (this.m_originalCount \u003e 0 || this.m_modifiedCount \u003e 0) {\n      this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n    }\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n    this.m_originalStart = 1073741824;\n    this.m_modifiedStart = 1073741824;\n  }\n  /**\n   * Adds the original element at the given position to the elements\n   * affected by the current change. The modified index gives context\n   * to the change position with respect to the original sequence.\n   * @param originalIndex The index of the original element to add.\n   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n   */\n  AddOriginalElement(originalIndex, modifiedIndex) {\n    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n    this.m_originalCount++;\n  }\n  /**\n   * Adds the modified element at the given position to the elements\n   * affected by the current change. The original index gives context\n   * to the change position with respect to the modified sequence.\n   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n   * @param modifiedIndex The index of the modified element to add.\n   */\n  AddModifiedElement(originalIndex, modifiedIndex) {\n    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n    this.m_modifiedCount++;\n  }\n  /**\n   * Retrieves all of the changes marked by the class.\n   */\n  getChanges() {\n    if (this.m_originalCount \u003e 0 || this.m_modifiedCount \u003e 0) {\n      this.MarkNextChange();\n    }\n    return this.m_changes;\n  }\n  /**\n   * Retrieves all of the changes marked by the class in the reverse order\n   */\n  getReverseChanges() {\n    if (this.m_originalCount \u003e 0 || this.m_modifiedCount \u003e 0) {\n      this.MarkNextChange();\n    }\n    this.m_changes.reverse();\n    return this.m_changes;\n  }\n};\nvar LcsDiff = class _LcsDiff {\n  /**\n   * Constructs the DiffFinder\n   */\n  constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n    this.ContinueProcessingPredicate = continueProcessingPredicate;\n    this._originalSequence = originalSequence;\n    this._modifiedSequence = modifiedSequence;\n    const [originalStringElements, originalElementsOrHash, originalHasStrings] = _LcsDiff._getElements(originalSequence);\n    const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = _LcsDiff._getElements(modifiedSequence);\n    this._hasStrings = originalHasStrings \u0026\u0026 modifiedHasStrings;\n    this._originalStringElements = originalStringElements;\n    this._originalElementsOrHash = originalElementsOrHash;\n    this._modifiedStringElements = modifiedStringElements;\n    this._modifiedElementsOrHash = modifiedElementsOrHash;\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = [];\n  }\n  static _isStringArray(arr) {\n    return arr.length \u003e 0 \u0026\u0026 typeof arr[0] === \"string\";\n  }\n  static _getElements(sequence) {\n    const elements = sequence.getElements();\n    if (_LcsDiff._isStringArray(elements)) {\n      const hashes = new Int32Array(elements.length);\n      for (let i = 0, len = elements.length; i \u003c len; i++) {\n        hashes[i] = stringHash(elements[i], 0);\n      }\n      return [elements, hashes, true];\n    }\n    if (elements instanceof Int32Array) {\n      return [[], elements, false];\n    }\n    return [[], new Int32Array(elements), false];\n  }\n  ElementsAreEqual(originalIndex, newIndex) {\n    if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n      return false;\n    }\n    return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;\n  }\n  ElementsAreStrictEqual(originalIndex, newIndex) {\n    if (!this.ElementsAreEqual(originalIndex, newIndex)) {\n      return false;\n    }\n    const originalElement = _LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n    const modifiedElement = _LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n    return originalElement === modifiedElement;\n  }\n  static _getStrictElement(sequence, index) {\n    if (typeof sequence.getStrictElement === \"function\") {\n      return sequence.getStrictElement(index);\n    }\n    return null;\n  }\n  OriginalElementsAreEqual(index1, index2) {\n    if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n      return false;\n    }\n    return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;\n  }\n  ModifiedElementsAreEqual(index1, index2) {\n    if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n      return false;\n    }\n    return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;\n  }\n  ComputeDiff(pretty) {\n    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n  }\n  /**\n   * Computes the differences between the original and modified input\n   * sequences on the bounded range.\n   * @returns An array of the differences between the two input sequences.\n   */\n  _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n    const quitEarlyArr = [false];\n    let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n    if (pretty) {\n      changes = this.PrettifyChanges(changes);\n    }\n    return {\n      quitEarly: quitEarlyArr[0],\n      changes\n    };\n  }\n  /**\n   * Private helper method which computes the differences on the bounded range\n   * recursively.\n   * @returns An array of the differences between the two input sequences.\n   */\n  ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n    quitEarlyArr[0] = false;\n    while (originalStart \u003c= originalEnd \u0026\u0026 modifiedStart \u003c= modifiedEnd \u0026\u0026 this.ElementsAreEqual(originalStart, modifiedStart)) {\n      originalStart++;\n      modifiedStart++;\n    }\n    while (originalEnd \u003e= originalStart \u0026\u0026 modifiedEnd \u003e= modifiedStart \u0026\u0026 this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n      originalEnd--;\n      modifiedEnd--;\n    }\n    if (originalStart \u003e originalEnd || modifiedStart \u003e modifiedEnd) {\n      let changes;\n      if (modifiedStart \u003c= modifiedEnd) {\n        Debug.Assert(originalStart === originalEnd + 1, \"originalStart should only be one more than originalEnd\");\n        changes = [\n          new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n      } else if (originalStart \u003c= originalEnd) {\n        Debug.Assert(modifiedStart === modifiedEnd + 1, \"modifiedStart should only be one more than modifiedEnd\");\n        changes = [\n          new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n        ];\n      } else {\n        Debug.Assert(originalStart === originalEnd + 1, \"originalStart should only be one more than originalEnd\");\n        Debug.Assert(modifiedStart === modifiedEnd + 1, \"modifiedStart should only be one more than modifiedEnd\");\n        changes = [];\n      }\n      return changes;\n    }\n    const midOriginalArr = [0];\n    const midModifiedArr = [0];\n    const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n    const midOriginal = midOriginalArr[0];\n    const midModified = midModifiedArr[0];\n    if (result !== null) {\n      return result;\n    } else if (!quitEarlyArr[0]) {\n      const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n      let rightChanges = [];\n      if (!quitEarlyArr[0]) {\n        rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n      } else {\n        rightChanges = [\n          new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n        ];\n      }\n      return this.ConcatenateChanges(leftChanges, rightChanges);\n    }\n    return [\n      new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n    ];\n  }\n  WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n    let forwardChanges = null;\n    let reverseChanges = null;\n    let changeHelper = new DiffChangeHelper();\n    let diagonalMin = diagonalForwardStart;\n    let diagonalMax = diagonalForwardEnd;\n    let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;\n    let lastOriginalIndex = -1073741824;\n    let historyIndex = this.m_forwardHistory.length - 1;\n    do {\n      const diagonal = diagonalRelative + diagonalForwardBase;\n      if (diagonal === diagonalMin || diagonal \u003c diagonalMax \u0026\u0026 forwardPoints[diagonal - 1] \u003c forwardPoints[diagonal + 1]) {\n        originalIndex = forwardPoints[diagonal + 1];\n        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n        if (originalIndex \u003c lastOriginalIndex) {\n          changeHelper.MarkNextChange();\n        }\n        lastOriginalIndex = originalIndex;\n        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n        diagonalRelative = diagonal + 1 - diagonalForwardBase;\n      } else {\n        originalIndex = forwardPoints[diagonal - 1] + 1;\n        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n        if (originalIndex \u003c lastOriginalIndex) {\n          changeHelper.MarkNextChange();\n        }\n        lastOriginalIndex = originalIndex - 1;\n        changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n        diagonalRelative = diagonal - 1 - diagonalForwardBase;\n      }\n      if (historyIndex \u003e= 0) {\n        forwardPoints = this.m_forwardHistory[historyIndex];\n        diagonalForwardBase = forwardPoints[0];\n        diagonalMin = 1;\n        diagonalMax = forwardPoints.length - 1;\n      }\n    } while (--historyIndex \u003e= -1);\n    forwardChanges = changeHelper.getReverseChanges();\n    if (quitEarlyArr[0]) {\n      let originalStartPoint = midOriginalArr[0] + 1;\n      let modifiedStartPoint = midModifiedArr[0] + 1;\n      if (forwardChanges !== null \u0026\u0026 forwardChanges.length \u003e 0) {\n        const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n        originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n        modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n      }\n      reverseChanges = [\n        new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n      ];\n    } else {\n      changeHelper = new DiffChangeHelper();\n      diagonalMin = diagonalReverseStart;\n      diagonalMax = diagonalReverseEnd;\n      diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;\n      lastOriginalIndex = 1073741824;\n      historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n      do {\n        const diagonal = diagonalRelative + diagonalReverseBase;\n        if (diagonal === diagonalMin || diagonal \u003c diagonalMax \u0026\u0026 reversePoints[diagonal - 1] \u003e= reversePoints[diagonal + 1]) {\n          originalIndex = reversePoints[diagonal + 1] - 1;\n          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n          if (originalIndex \u003e lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n          lastOriginalIndex = originalIndex + 1;\n          changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n          diagonalRelative = diagonal + 1 - diagonalReverseBase;\n        } else {\n          originalIndex = reversePoints[diagonal - 1];\n          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n          if (originalIndex \u003e lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n          lastOriginalIndex = originalIndex;\n          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n          diagonalRelative = diagonal - 1 - diagonalReverseBase;\n        }\n        if (historyIndex \u003e= 0) {\n          reversePoints = this.m_reverseHistory[historyIndex];\n          diagonalReverseBase = reversePoints[0];\n          diagonalMin = 1;\n          diagonalMax = reversePoints.length - 1;\n        }\n      } while (--historyIndex \u003e= -1);\n      reverseChanges = changeHelper.getChanges();\n    }\n    return this.ConcatenateChanges(forwardChanges, reverseChanges);\n  }\n  /**\n   * Given the range to compute the diff on, this method finds the point:\n   * (midOriginal, midModified)\n   * that exists in the middle of the LCS of the two sequences and\n   * is the point at which the LCS problem may be broken down recursively.\n   * This method will try to keep the LCS trace in memory. If the LCS recursion\n   * point is calculated and the full trace is available in memory, then this method\n   * will return the change list.\n   * @param originalStart The start bound of the original sequence range\n   * @param originalEnd The end bound of the original sequence range\n   * @param modifiedStart The start bound of the modified sequence range\n   * @param modifiedEnd The end bound of the modified sequence range\n   * @param midOriginal The middle point of the original sequence range\n   * @param midModified The middle point of the modified sequence range\n   * @returns The diff changes, if available, otherwise null\n   */\n  ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n    let originalIndex = 0, modifiedIndex = 0;\n    let diagonalForwardStart = 0, diagonalForwardEnd = 0;\n    let diagonalReverseStart = 0, diagonalReverseEnd = 0;\n    originalStart--;\n    modifiedStart--;\n    midOriginalArr[0] = 0;\n    midModifiedArr[0] = 0;\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = [];\n    const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);\n    const numDiagonals = maxDifferences + 1;\n    const forwardPoints = new Int32Array(numDiagonals);\n    const reversePoints = new Int32Array(numDiagonals);\n    const diagonalForwardBase = modifiedEnd - modifiedStart;\n    const diagonalReverseBase = originalEnd - originalStart;\n    const diagonalForwardOffset = originalStart - modifiedStart;\n    const diagonalReverseOffset = originalEnd - modifiedEnd;\n    const delta = diagonalReverseBase - diagonalForwardBase;\n    const deltaIsEven = delta % 2 === 0;\n    forwardPoints[diagonalForwardBase] = originalStart;\n    reversePoints[diagonalReverseBase] = originalEnd;\n    quitEarlyArr[0] = false;\n    for (let numDifferences = 1; numDifferences \u003c= maxDifferences / 2 + 1; numDifferences++) {\n      let furthestOriginalIndex = 0;\n      let furthestModifiedIndex = 0;\n      diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n      diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n      for (let diagonal = diagonalForwardStart; diagonal \u003c= diagonalForwardEnd; diagonal += 2) {\n        if (diagonal === diagonalForwardStart || diagonal \u003c diagonalForwardEnd \u0026\u0026 forwardPoints[diagonal - 1] \u003c forwardPoints[diagonal + 1]) {\n          originalIndex = forwardPoints[diagonal + 1];\n        } else {\n          originalIndex = forwardPoints[diagonal - 1] + 1;\n        }\n        modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n        const tempOriginalIndex = originalIndex;\n        while (originalIndex \u003c originalEnd \u0026\u0026 modifiedIndex \u003c modifiedEnd \u0026\u0026 this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n          originalIndex++;\n          modifiedIndex++;\n        }\n        forwardPoints[diagonal] = originalIndex;\n        if (originalIndex + modifiedIndex \u003e furthestOriginalIndex + furthestModifiedIndex) {\n          furthestOriginalIndex = originalIndex;\n          furthestModifiedIndex = modifiedIndex;\n        }\n        if (!deltaIsEven \u0026\u0026 Math.abs(diagonal - diagonalReverseBase) \u003c= numDifferences - 1) {\n          if (originalIndex \u003e= reversePoints[diagonal]) {\n            midOriginalArr[0] = originalIndex;\n            midModifiedArr[0] = modifiedIndex;\n            if (tempOriginalIndex \u003c= reversePoints[diagonal] \u0026\u0026 1447 \u003e 0 \u0026\u0026 numDifferences \u003c= 1447 + 1) {\n              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n            } else {\n              return null;\n            }\n          }\n        }\n      }\n      const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n      if (this.ContinueProcessingPredicate !== null \u0026\u0026 !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n        quitEarlyArr[0] = true;\n        midOriginalArr[0] = furthestOriginalIndex;\n        midModifiedArr[0] = furthestModifiedIndex;\n        if (matchLengthOfLongest \u003e 0 \u0026\u0026 1447 \u003e 0 \u0026\u0026 numDifferences \u003c= 1447 + 1) {\n          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n        } else {\n          originalStart++;\n          modifiedStart++;\n          return [\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n          ];\n        }\n      }\n      diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n      diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n      for (let diagonal = diagonalReverseStart; diagonal \u003c= diagonalReverseEnd; diagonal += 2) {\n        if (diagonal === diagonalReverseStart || diagonal \u003c diagonalReverseEnd \u0026\u0026 reversePoints[diagonal - 1] \u003e= reversePoints[diagonal + 1]) {\n          originalIndex = reversePoints[diagonal + 1] - 1;\n        } else {\n          originalIndex = reversePoints[diagonal - 1];\n        }\n        modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n        const tempOriginalIndex = originalIndex;\n        while (originalIndex \u003e originalStart \u0026\u0026 modifiedIndex \u003e modifiedStart \u0026\u0026 this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n          originalIndex--;\n          modifiedIndex--;\n        }\n        reversePoints[diagonal] = originalIndex;\n        if (deltaIsEven \u0026\u0026 Math.abs(diagonal - diagonalForwardBase) \u003c= numDifferences) {\n          if (originalIndex \u003c= forwardPoints[diagonal]) {\n            midOriginalArr[0] = originalIndex;\n            midModifiedArr[0] = modifiedIndex;\n            if (tempOriginalIndex \u003e= forwardPoints[diagonal] \u0026\u0026 1447 \u003e 0 \u0026\u0026 numDifferences \u003c= 1447 + 1) {\n              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n            } else {\n              return null;\n            }\n          }\n        }\n      }\n      if (numDifferences \u003c= 1447) {\n        let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n        temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n        MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n        this.m_forwardHistory.push(temp);\n        temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n        temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n        MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n        this.m_reverseHistory.push(temp);\n      }\n    }\n    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n  }\n  /**\n   * Shifts the given changes to provide a more intuitive diff.\n   * While the first element in a diff matches the first element after the diff,\n   * we shift the diff down.\n   *\n   * @param changes The list of changes to shift\n   * @returns The shifted changes\n   */\n  PrettifyChanges(changes) {\n    for (let i = 0; i \u003c changes.length; i++) {\n      const change = changes[i];\n      const originalStop = i \u003c changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n      const modifiedStop = i \u003c changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n      const checkOriginal = change.originalLength \u003e 0;\n      const checkModified = change.modifiedLength \u003e 0;\n      while (change.originalStart + change.originalLength \u003c originalStop \u0026\u0026 change.modifiedStart + change.modifiedLength \u003c modifiedStop \u0026\u0026 (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) \u0026\u0026 (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n        const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n        const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n        if (endStrictEqual \u0026\u0026 !startStrictEqual) {\n          break;\n        }\n        change.originalStart++;\n        change.modifiedStart++;\n      }\n      const mergedChangeArr = [null];\n      if (i \u003c changes.length - 1 \u0026\u0026 this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n        changes[i] = mergedChangeArr[0];\n        changes.splice(i + 1, 1);\n        i--;\n        continue;\n      }\n    }\n    for (let i = changes.length - 1; i \u003e= 0; i--) {\n      const change = changes[i];\n      let originalStop = 0;\n      let modifiedStop = 0;\n      if (i \u003e 0) {\n        const prevChange = changes[i - 1];\n        originalStop = prevChange.originalStart + prevChange.originalLength;\n        modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n      }\n      const checkOriginal = change.originalLength \u003e 0;\n      const checkModified = change.modifiedLength \u003e 0;\n      let bestDelta = 0;\n      let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n      for (let delta = 1; ; delta++) {\n        const originalStart = change.originalStart - delta;\n        const modifiedStart = change.modifiedStart - delta;\n        if (originalStart \u003c originalStop || modifiedStart \u003c modifiedStop) {\n          break;\n        }\n        if (checkOriginal \u0026\u0026 !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n          break;\n        }\n        if (checkModified \u0026\u0026 !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n          break;\n        }\n        const touchingPreviousChange = originalStart === originalStop \u0026\u0026 modifiedStart === modifiedStop;\n        const score2 = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\n        if (score2 \u003e bestScore) {\n          bestScore = score2;\n          bestDelta = delta;\n        }\n      }\n      change.originalStart -= bestDelta;\n      change.modifiedStart -= bestDelta;\n      const mergedChangeArr = [null];\n      if (i \u003e 0 \u0026\u0026 this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n        changes[i - 1] = mergedChangeArr[0];\n        changes.splice(i, 1);\n        i++;\n        continue;\n      }\n    }\n    if (this._hasStrings) {\n      for (let i = 1, len = changes.length; i \u003c len; i++) {\n        const aChange = changes[i - 1];\n        const bChange = changes[i];\n        const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n        const aOriginalStart = aChange.originalStart;\n        const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n        const abOriginalLength = bOriginalEnd - aOriginalStart;\n        const aModifiedStart = aChange.modifiedStart;\n        const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n        const abModifiedLength = bModifiedEnd - aModifiedStart;\n        if (matchedLength \u003c 5 \u0026\u0026 abOriginalLength \u003c 20 \u0026\u0026 abModifiedLength \u003c 20) {\n          const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n          if (t) {\n            const [originalMatchStart, modifiedMatchStart] = t;\n            if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n              aChange.originalLength = originalMatchStart - aChange.originalStart;\n              aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n              bChange.originalStart = originalMatchStart + matchedLength;\n              bChange.modifiedStart = modifiedMatchStart + matchedLength;\n              bChange.originalLength = bOriginalEnd - bChange.originalStart;\n              bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n            }\n          }\n        }\n      }\n    }\n    return changes;\n  }\n  _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n    if (originalLength \u003c desiredLength || modifiedLength \u003c desiredLength) {\n      return null;\n    }\n    const originalMax = originalStart + originalLength - desiredLength + 1;\n    const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n    let bestScore = 0;\n    let bestOriginalStart = 0;\n    let bestModifiedStart = 0;\n    for (let i = originalStart; i \u003c originalMax; i++) {\n      for (let j = modifiedStart; j \u003c modifiedMax; j++) {\n        const score2 = this._contiguousSequenceScore(i, j, desiredLength);\n        if (score2 \u003e 0 \u0026\u0026 score2 \u003e bestScore) {\n          bestScore = score2;\n          bestOriginalStart = i;\n          bestModifiedStart = j;\n        }\n      }\n    }\n    if (bestScore \u003e 0) {\n      return [bestOriginalStart, bestModifiedStart];\n    }\n    return null;\n  }\n  _contiguousSequenceScore(originalStart, modifiedStart, length) {\n    let score2 = 0;\n    for (let l = 0; l \u003c length; l++) {\n      if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n        return 0;\n      }\n      score2 += this._originalStringElements[originalStart + l].length;\n    }\n    return score2;\n  }\n  _OriginalIsBoundary(index) {\n    if (index \u003c= 0 || index \u003e= this._originalElementsOrHash.length - 1) {\n      return true;\n    }\n    return this._hasStrings \u0026\u0026 /^\\s*$/.test(this._originalStringElements[index]);\n  }\n  _OriginalRegionIsBoundary(originalStart, originalLength) {\n    if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n      return true;\n    }\n    if (originalLength \u003e 0) {\n      const originalEnd = originalStart + originalLength;\n      if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _ModifiedIsBoundary(index) {\n    if (index \u003c= 0 || index \u003e= this._modifiedElementsOrHash.length - 1) {\n      return true;\n    }\n    return this._hasStrings \u0026\u0026 /^\\s*$/.test(this._modifiedStringElements[index]);\n  }\n  _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n    if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n      return true;\n    }\n    if (modifiedLength \u003e 0) {\n      const modifiedEnd = modifiedStart + modifiedLength;\n      if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n    const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;\n    const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;\n    return originalScore + modifiedScore;\n  }\n  /**\n   * Concatenates the two input DiffChange lists and returns the resulting\n   * list.\n   * @param The left changes\n   * @param The right changes\n   * @returns The concatenated list\n   */\n  ConcatenateChanges(left, right) {\n    const mergedChangeArr = [];\n    if (left.length === 0 || right.length === 0) {\n      return right.length \u003e 0 ? right : left;\n    } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n      const result = new Array(left.length + right.length - 1);\n      MyArray.Copy(left, 0, result, 0, left.length - 1);\n      result[left.length - 1] = mergedChangeArr[0];\n      MyArray.Copy(right, 1, result, left.length, right.length - 1);\n      return result;\n    } else {\n      const result = new Array(left.length + right.length);\n      MyArray.Copy(left, 0, result, 0, left.length);\n      MyArray.Copy(right, 0, result, left.length, right.length);\n      return result;\n    }\n  }\n  /**\n   * Returns true if the two changes overlap and can be merged into a single\n   * change\n   * @param left The left change\n   * @param right The right change\n   * @param mergedChange The merged change if the two overlap, null otherwise\n   * @returns True if the two changes overlap\n   */\n  ChangesOverlap(left, right, mergedChangeArr) {\n    Debug.Assert(left.originalStart \u003c= right.originalStart, \"Left change is not less than or equal to right change\");\n    Debug.Assert(left.modifiedStart \u003c= right.modifiedStart, \"Left change is not less than or equal to right change\");\n    if (left.originalStart + left.originalLength \u003e= right.originalStart || left.modifiedStart + left.modifiedLength \u003e= right.modifiedStart) {\n      const originalStart = left.originalStart;\n      let originalLength = left.originalLength;\n      const modifiedStart = left.modifiedStart;\n      let modifiedLength = left.modifiedLength;\n      if (left.originalStart + left.originalLength \u003e= right.originalStart) {\n        originalLength = right.originalStart + right.originalLength - left.originalStart;\n      }\n      if (left.modifiedStart + left.modifiedLength \u003e= right.modifiedStart) {\n        modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n      }\n      mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n      return true;\n    } else {\n      mergedChangeArr[0] = null;\n      return false;\n    }\n  }\n  /**\n   * Helper method used to clip a diagonal index to the range of valid\n   * diagonals. This also decides whether or not the diagonal index,\n   * if it exceeds the boundary, should be clipped to the boundary or clipped\n   * one inside the boundary depending on the Even/Odd status of the boundary\n   * and numDifferences.\n   * @param diagonal The index of the diagonal to clip.\n   * @param numDifferences The current number of differences being iterated upon.\n   * @param diagonalBaseIndex The base reference diagonal.\n   * @param numDiagonals The total number of diagonals.\n   * @returns The clipped diagonal index.\n   */\n  ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n    if (diagonal \u003e= 0 \u0026\u0026 diagonal \u003c numDiagonals) {\n      return diagonal;\n    }\n    const diagonalsBelow = diagonalBaseIndex;\n    const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n    const diffEven = numDifferences % 2 === 0;\n    if (diagonal \u003c 0) {\n      const lowerBoundEven = diagonalsBelow % 2 === 0;\n      return diffEven === lowerBoundEven ? 0 : 1;\n    } else {\n      const upperBoundEven = diagonalsAbove % 2 === 0;\n      return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/process.js\nvar safeProcess;\nvar vscodeGlobal = globalThis.vscode;\nif (typeof vscodeGlobal !== \"undefined\" \u0026\u0026 typeof vscodeGlobal.process !== \"undefined\") {\n  const sandboxProcess = vscodeGlobal.process;\n  safeProcess = {\n    get platform() {\n      return sandboxProcess.platform;\n    },\n    get arch() {\n      return sandboxProcess.arch;\n    },\n    get env() {\n      return sandboxProcess.env;\n    },\n    cwd() {\n      return sandboxProcess.cwd();\n    }\n  };\n} else if (typeof __Process$ !== \"undefined\") {\n  safeProcess = {\n    get platform() {\n      return __Process$.platform;\n    },\n    get arch() {\n      return __Process$.arch;\n    },\n    get env() {\n      return __Process$.env;\n    },\n    cwd() {\n      return __Process$.env[\"VSCODE_CWD\"] || __Process$.cwd();\n    }\n  };\n} else {\n  safeProcess = {\n    // Supported\n    get platform() {\n      return isWindows ? \"win32\" : isMacintosh ? \"darwin\" : \"linux\";\n    },\n    get arch() {\n      return void 0;\n    },\n    // Unsupported\n    get env() {\n      return {};\n    },\n    cwd() {\n      return \"/\";\n    }\n  };\n}\nvar cwd = safeProcess.cwd;\nvar env = safeProcess.env;\nvar platform = safeProcess.platform;\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/path.js\nvar CHAR_UPPERCASE_A = 65;\nvar CHAR_LOWERCASE_A = 97;\nvar CHAR_UPPERCASE_Z = 90;\nvar CHAR_LOWERCASE_Z = 122;\nvar CHAR_DOT = 46;\nvar CHAR_FORWARD_SLASH = 47;\nvar CHAR_BACKWARD_SLASH = 92;\nvar CHAR_COLON = 58;\nvar CHAR_QUESTION_MARK = 63;\nvar ErrorInvalidArgType = class extends Error {\n  constructor(name, expected, actual) {\n    let determiner;\n    if (typeof expected === \"string\" \u0026\u0026 expected.indexOf(\"not \") === 0) {\n      determiner = \"must not be\";\n      expected = expected.replace(/^not /, \"\");\n    } else {\n      determiner = \"must be\";\n    }\n    const type = name.indexOf(\".\") !== -1 ? \"property\" : \"argument\";\n    let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n    msg += `. Received type ${typeof actual}`;\n    super(msg);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n};\nfunction validateObject(pathObject, name) {\n  if (pathObject === null || typeof pathObject !== \"object\") {\n    throw new ErrorInvalidArgType(name, \"Object\", pathObject);\n  }\n}\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") {\n    throw new ErrorInvalidArgType(name, \"string\", value);\n  }\n}\nvar platformIsWin32 = platform === \"win32\";\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n  return code \u003e= CHAR_UPPERCASE_A \u0026\u0026 code \u003c= CHAR_UPPERCASE_Z || code \u003e= CHAR_LOWERCASE_A \u0026\u0026 code \u003c= CHAR_LOWERCASE_Z;\n}\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i \u003c= path.length; ++i) {\n    if (i \u003c path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator2(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n    if (isPathSeparator2(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (dots === 2) {\n        if (res.length \u003c 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length \u003e 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length \u003e 0 ? `${separator}..` : \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length \u003e 0) {\n          res += `${separator}${path.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT \u0026\u0026 dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nfunction _format2(sep2, pathObject) {\n  validateObject(pathObject, \"pathObject\");\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || `${pathObject.name || \"\"}${pathObject.ext || \"\"}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;\n}\nvar win32 = {\n  // path.resolve([from ...], to)\n  resolve(...pathSegments) {\n    let resolvedDevice = \"\";\n    let resolvedTail = \"\";\n    let resolvedAbsolute = false;\n    for (let i = pathSegments.length - 1; i \u003e= -1; i--) {\n      let path;\n      if (i \u003e= 0) {\n        path = pathSegments[i];\n        validateString(path, \"path\");\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = cwd();\n      } else {\n        path = env[`=${resolvedDevice}`] || cwd();\n        if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() \u0026\u0026 path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n      const len = path.length;\n      let rootEnd = 0;\n      let device = \"\";\n      let isAbsolute = false;\n      const code = path.charCodeAt(0);\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        isAbsolute = true;\n        if (isPathSeparator(path.charCodeAt(1))) {\n          let j = 2;\n          let last = j;\n          while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j \u003c len \u0026\u0026 j !== last) {\n            const firstPart = path.slice(last, j);\n            last = j;\n            while (j \u003c len \u0026\u0026 isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j \u003c len \u0026\u0026 j !== last) {\n              last = j;\n              while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON) {\n        device = path.slice(0, 2);\n        rootEnd = 2;\n        if (len \u003e 2 \u0026\u0026 isPathSeparator(path.charCodeAt(2))) {\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n      if (device.length \u003e 0) {\n        if (resolvedDevice.length \u003e 0) {\n          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n            continue;\n          }\n        } else {\n          resolvedDevice = device;\n        }\n      }\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length \u003e 0) {\n          break;\n        }\n      } else {\n        resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute \u0026\u0026 resolvedDevice.length \u003e 0) {\n          break;\n        }\n      }\n    }\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, \"\\\\\", isPathSeparator);\n    return resolvedAbsolute ? `${resolvedDevice}\\\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || \".\";\n  },\n  normalize(path) {\n    validateString(path, \"path\");\n    const len = path.length;\n    if (len === 0) {\n      return \".\";\n    }\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = path.charCodeAt(0);\n    if (len === 1) {\n      return isPosixPathSeparator(code) ? \"\\\\\" : path;\n    }\n    if (isPathSeparator(code)) {\n      isAbsolute = true;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        let j = 2;\n        let last = j;\n        while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j \u003c len \u0026\u0026 j !== last) {\n          const firstPart = path.slice(last, j);\n          last = j;\n          while (j \u003c len \u0026\u0026 isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j \u003c len \u0026\u0026 j !== last) {\n            last = j;\n            while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n            }\n            if (j !== last) {\n              device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON) {\n      device = path.slice(0, 2);\n      rootEnd = 2;\n      if (len \u003e 2 \u0026\u0026 isPathSeparator(path.charCodeAt(2))) {\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n    let tail = rootEnd \u003c len ? normalizeString(path.slice(rootEnd), !isAbsolute, \"\\\\\", isPathSeparator) : \"\";\n    if (tail.length === 0 \u0026\u0026 !isAbsolute) {\n      tail = \".\";\n    }\n    if (tail.length \u003e 0 \u0026\u0026 isPathSeparator(path.charCodeAt(len - 1))) {\n      tail += \"\\\\\";\n    }\n    if (device === void 0) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  },\n  isAbsolute(path) {\n    validateString(path, \"path\");\n    const len = path.length;\n    if (len === 0) {\n      return false;\n    }\n    const code = path.charCodeAt(0);\n    return isPathSeparator(code) || // Possible device root\n    len \u003e 2 \u0026\u0026 isWindowsDeviceRoot(code) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON \u0026\u0026 isPathSeparator(path.charCodeAt(2));\n  },\n  join(...paths) {\n    if (paths.length === 0) {\n      return \".\";\n    }\n    let joined;\n    let firstPart;\n    for (let i = 0; i \u003c paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, \"path\");\n      if (arg.length \u003e 0) {\n        if (joined === void 0) {\n          joined = firstPart = arg;\n        } else {\n          joined += `\\\\${arg}`;\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    let needsReplace = true;\n    let slashCount = 0;\n    if (typeof firstPart === \"string\" \u0026\u0026 isPathSeparator(firstPart.charCodeAt(0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen \u003e 1 \u0026\u0026 isPathSeparator(firstPart.charCodeAt(1))) {\n        ++slashCount;\n        if (firstLen \u003e 2) {\n          if (isPathSeparator(firstPart.charCodeAt(2))) {\n            ++slashCount;\n          } else {\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      while (slashCount \u003c joined.length \u0026\u0026 isPathSeparator(joined.charCodeAt(slashCount))) {\n        slashCount++;\n      }\n      if (slashCount \u003e= 2) {\n        joined = `\\\\${joined.slice(slashCount)}`;\n      }\n    }\n    return win32.normalize(joined);\n  },\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative(from, to) {\n    validateString(from, \"from\");\n    validateString(to, \"to\");\n    if (from === to) {\n      return \"\";\n    }\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n    if (fromOrig === toOrig) {\n      return \"\";\n    }\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n    if (from === to) {\n      return \"\";\n    }\n    let fromStart = 0;\n    while (fromStart \u003c from.length \u0026\u0026 from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    let fromEnd = from.length;\n    while (fromEnd - 1 \u003e fromStart \u0026\u0026 from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n    let toStart = 0;\n    while (toStart \u003c to.length \u0026\u0026 to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    let toEnd = to.length;\n    while (toEnd - 1 \u003e toStart \u0026\u0026 to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n    const length = fromLen \u003c toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i \u003c length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_BACKWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i !== length) {\n      if (lastCommonSep === -1) {\n        return toOrig;\n      }\n    } else {\n      if (toLen \u003e length) {\n        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n          return toOrig.slice(toStart + i + 1);\n        }\n        if (i === 2) {\n          return toOrig.slice(toStart + i);\n        }\n      }\n      if (fromLen \u003e length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n          lastCommonSep = i;\n        } else if (i === 2) {\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1) {\n        lastCommonSep = 0;\n      }\n    }\n    let out = \"\";\n    for (i = fromStart + lastCommonSep + 1; i \u003c= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? \"..\" : \"\\\\..\";\n      }\n    }\n    toStart += lastCommonSep;\n    if (out.length \u003e 0) {\n      return `${out}${toOrig.slice(toStart, toEnd)}`;\n    }\n    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      ++toStart;\n    }\n    return toOrig.slice(toStart, toEnd);\n  },\n  toNamespacedPath(path) {\n    if (typeof path !== \"string\" || path.length === 0) {\n      return path;\n    }\n    const resolvedPath = win32.resolve(path);\n    if (resolvedPath.length \u003c= 2) {\n      return path;\n    }\n    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n        const code = resolvedPath.charCodeAt(2);\n        if (code !== CHAR_QUESTION_MARK \u0026\u0026 code !== CHAR_DOT) {\n          return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n        }\n      }\n    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) \u0026\u0026 resolvedPath.charCodeAt(1) === CHAR_COLON \u0026\u0026 resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n    return path;\n  },\n  dirname(path) {\n    validateString(path, \"path\");\n    const len = path.length;\n    if (len === 0) {\n      return \".\";\n    }\n    let rootEnd = -1;\n    let offset = 0;\n    const code = path.charCodeAt(0);\n    if (len === 1) {\n      return isPathSeparator(code) ? path : \".\";\n    }\n    if (isPathSeparator(code)) {\n      rootEnd = offset = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        let j = 2;\n        let last = j;\n        while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j \u003c len \u0026\u0026 j !== last) {\n          last = j;\n          while (j \u003c len \u0026\u0026 isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j \u003c len \u0026\u0026 j !== last) {\n            last = j;\n            while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              return path;\n            }\n            if (j !== last) {\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON) {\n      rootEnd = len \u003e 2 \u0026\u0026 isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i \u003e= offset; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      if (rootEnd === -1) {\n        return \".\";\n      }\n      end = rootEnd;\n    }\n    return path.slice(0, end);\n  },\n  basename(path, ext) {\n    if (ext !== void 0) {\n      validateString(ext, \"ext\");\n    }\n    validateString(path, \"path\");\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (path.length \u003e= 2 \u0026\u0026 isWindowsDeviceRoot(path.charCodeAt(0)) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON) {\n      start = 2;\n    }\n    if (ext !== void 0 \u0026\u0026 ext.length \u003e 0 \u0026\u0026 ext.length \u003c= path.length) {\n      if (ext === path) {\n        return \"\";\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i \u003e= start; --i) {\n        const code = path.charCodeAt(i);\n        if (isPathSeparator(code)) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx \u003e= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i \u003e= start; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1) {\n      return \"\";\n    }\n    return path.slice(start, end);\n  },\n  extname(path) {\n    validateString(path, \"path\");\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    if (path.length \u003e= 2 \u0026\u0026 path.charCodeAt(1) === CHAR_COLON \u0026\u0026 isWindowsDeviceRoot(path.charCodeAt(0))) {\n      start = startPart = 2;\n    }\n    for (let i = path.length - 1; i \u003e= start; --i) {\n      const code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 \u0026\u0026 startDot === end - 1 \u0026\u0026 startDot === startPart + 1) {\n      return \"\";\n    }\n    return path.slice(startDot, end);\n  },\n  format: _format2.bind(null, \"\\\\\"),\n  parse(path) {\n    validateString(path, \"path\");\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path.length === 0) {\n      return ret;\n    }\n    const len = path.length;\n    let rootEnd = 0;\n    let code = path.charCodeAt(0);\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    if (isPathSeparator(code)) {\n      rootEnd = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        let j = 2;\n        let last = j;\n        while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j \u003c len \u0026\u0026 j !== last) {\n          last = j;\n          while (j \u003c len \u0026\u0026 isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j \u003c len \u0026\u0026 j !== last) {\n            last = j;\n            while (j \u003c len \u0026\u0026 !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              rootEnd = j;\n            } else if (j !== last) {\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) \u0026\u0026 path.charCodeAt(1) === CHAR_COLON) {\n      if (len \u003c= 2) {\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(path.charCodeAt(2))) {\n        if (len === 3) {\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd \u003e 0) {\n      ret.root = path.slice(0, rootEnd);\n    }\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    let preDotState = 0;\n    for (; i \u003e= rootEnd; --i) {\n      code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (end !== -1) {\n      if (startDot === -1 || // We saw a non-dot character immediately before the dot\n      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 \u0026\u0026 startDot === end - 1 \u0026\u0026 startDot === startPart + 1) {\n        ret.base = ret.name = path.slice(startPart, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n    if (startPart \u003e 0 \u0026\u0026 startPart !== rootEnd) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else {\n      ret.dir = ret.root;\n    }\n    return ret;\n  },\n  sep: \"\\\\\",\n  delimiter: \";\",\n  win32: null,\n  posix: null\n};\nvar posixCwd = (() =\u003e {\n  if (platformIsWin32) {\n    const regexp = /\\\\/g;\n    return () =\u003e {\n      const cwd2 = cwd().replace(regexp, \"/\");\n      return cwd2.slice(cwd2.indexOf(\"/\"));\n    };\n  }\n  return () =\u003e cwd();\n})();\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve(...pathSegments) {\n    let resolvedPath = \"\";\n    let resolvedAbsolute = false;\n    for (let i = pathSegments.length - 1; i \u003e= -1 \u0026\u0026 !resolvedAbsolute; i--) {\n      const path = i \u003e= 0 ? pathSegments[i] : posixCwd();\n      validateString(path, \"path\");\n      if (path.length === 0) {\n        continue;\n      }\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, \"/\", isPosixPathSeparator);\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length \u003e 0 ? resolvedPath : \".\";\n  },\n  normalize(path) {\n    validateString(path, \"path\");\n    if (path.length === 0) {\n      return \".\";\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n    path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n    if (path.length === 0) {\n      if (isAbsolute) {\n        return \"/\";\n      }\n      return trailingSeparator ? \"./\" : \".\";\n    }\n    if (trailingSeparator) {\n      path += \"/\";\n    }\n    return isAbsolute ? `/${path}` : path;\n  },\n  isAbsolute(path) {\n    validateString(path, \"path\");\n    return path.length \u003e 0 \u0026\u0026 path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n  join(...paths) {\n    if (paths.length === 0) {\n      return \".\";\n    }\n    let joined;\n    for (let i = 0; i \u003c paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, \"path\");\n      if (arg.length \u003e 0) {\n        if (joined === void 0) {\n          joined = arg;\n        } else {\n          joined += `/${arg}`;\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    return posix.normalize(joined);\n  },\n  relative(from, to) {\n    validateString(from, \"from\");\n    validateString(to, \"to\");\n    if (from === to) {\n      return \"\";\n    }\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n    if (from === to) {\n      return \"\";\n    }\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n    const length = fromLen \u003c toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i \u003c length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i === length) {\n      if (toLen \u003e length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          return to.slice(toStart + i + 1);\n        }\n        if (i === 0) {\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen \u003e length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          lastCommonSep = i;\n        } else if (i === 0) {\n          lastCommonSep = 0;\n        }\n      }\n    }\n    let out = \"\";\n    for (i = fromStart + lastCommonSep + 1; i \u003c= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? \"..\" : \"/..\";\n      }\n    }\n    return `${out}${to.slice(toStart + lastCommonSep)}`;\n  },\n  toNamespacedPath(path) {\n    return path;\n  },\n  dirname(path) {\n    validateString(path, \"path\");\n    if (path.length === 0) {\n      return \".\";\n    }\n    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i \u003e= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      return hasRoot ? \"/\" : \".\";\n    }\n    if (hasRoot \u0026\u0026 end === 1) {\n      return \"//\";\n    }\n    return path.slice(0, end);\n  },\n  basename(path, ext) {\n    if (ext !== void 0) {\n      validateString(ext, \"ext\");\n    }\n    validateString(path, \"path\");\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 \u0026\u0026 ext.length \u003e 0 \u0026\u0026 ext.length \u003c= path.length) {\n      if (ext === path) {\n        return \"\";\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i \u003e= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx \u003e= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i \u003e= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1) {\n      return \"\";\n    }\n    return path.slice(start, end);\n  },\n  extname(path) {\n    validateString(path, \"path\");\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path.length - 1; i \u003e= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 \u0026\u0026 startDot === end - 1 \u0026\u0026 startDot === startPart + 1) {\n      return \"\";\n    }\n    return path.slice(startDot, end);\n  },\n  format: _format2.bind(null, \"/\"),\n  parse(path) {\n    validateString(path, \"path\");\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path.length === 0) {\n      return ret;\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = \"/\";\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    let preDotState = 0;\n    for (; i \u003e= start; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (end !== -1) {\n      const start2 = startPart === 0 \u0026\u0026 isAbsolute ? 1 : startPart;\n      if (startDot === -1 || // We saw a non-dot character immediately before the dot\n      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 \u0026\u0026 startDot === end - 1 \u0026\u0026 startDot === startPart + 1) {\n        ret.base = ret.name = path.slice(start2, end);\n      } else {\n        ret.name = path.slice(start2, startDot);\n        ret.base = path.slice(start2, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n    if (startPart \u003e 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = \"/\";\n    }\n    return ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  win32: null,\n  posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nvar normalize = platformIsWin32 ? win32.normalize : posix.normalize;\nvar resolve = platformIsWin32 ? win32.resolve : posix.resolve;\nvar relative = platformIsWin32 ? win32.relative : posix.relative;\nvar dirname = platformIsWin32 ? win32.dirname : posix.dirname;\nvar basename = platformIsWin32 ? win32.basename : posix.basename;\nvar extname = platformIsWin32 ? win32.extname : posix.extname;\nvar sep = platformIsWin32 ? win32.sep : posix.sep;\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/uri.js\nvar _schemePattern = /^\\w[\\w\\d+.-]*$/;\nvar _singleSlashStart = /^\\//;\nvar _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n  if (!ret.scheme \u0026\u0026 _strict) {\n    throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n  }\n  if (ret.scheme \u0026\u0026 !_schemePattern.test(ret.scheme)) {\n    throw new Error(\"[UriError]: Scheme contains illegal characters.\");\n  }\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n      }\n    }\n  }\n}\nfunction _schemeFix(scheme, _strict) {\n  if (!scheme \u0026\u0026 !_strict) {\n    return \"file\";\n  }\n  return scheme;\n}\nfunction _referenceResolution(scheme, path) {\n  switch (scheme) {\n    case \"https\":\n    case \"http\":\n    case \"file\":\n      if (!path) {\n        path = _slash;\n      } else if (path[0] !== _slash) {\n        path = _slash + path;\n      }\n      break;\n  }\n  return path;\n}\nvar _empty = \"\";\nvar _slash = \"/\";\nvar _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\nvar URI = class _URI {\n  static isUri(thing) {\n    if (thing instanceof _URI) {\n      return true;\n    }\n    if (!thing) {\n      return false;\n    }\n    return typeof thing.authority === \"string\" \u0026\u0026 typeof thing.fragment === \"string\" \u0026\u0026 typeof thing.path === \"string\" \u0026\u0026 typeof thing.query === \"string\" \u0026\u0026 typeof thing.scheme === \"string\" \u0026\u0026 typeof thing.fsPath === \"string\" \u0026\u0026 typeof thing.with === \"function\" \u0026\u0026 typeof thing.toString === \"function\";\n  }\n  /**\n   * @internal\n   */\n  constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n    if (typeof schemeOrData === \"object\") {\n      this.scheme = schemeOrData.scheme || _empty;\n      this.authority = schemeOrData.authority || _empty;\n      this.path = schemeOrData.path || _empty;\n      this.query = schemeOrData.query || _empty;\n      this.fragment = schemeOrData.fragment || _empty;\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict);\n      this.authority = authority || _empty;\n      this.path = _referenceResolution(this.scheme, path || _empty);\n      this.query = query || _empty;\n      this.fragment = fragment || _empty;\n      _validateUri(this, _strict);\n    }\n  }\n  // ---- filesystem path -----------------------\n  /**\n   * Returns a string representing the corresponding file system path of this URI.\n   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n   * platform specific path separator.\n   *\n   * * Will *not* validate the path for invalid characters and semantics.\n   * * Will *not* look at the scheme of this URI.\n   * * The result shall *not* be used for display purposes but for accessing a file on disk.\n   *\n   *\n   * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n   *\n   * ```ts\n      const u = URI.parse('file://server/c$/folder/file.txt')\n      u.authority === 'server'\n      u.path === '/shares/c$/file.txt'\n      u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n  ```\n   *\n   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n   * with URIs that represent files on disk (`file` scheme).\n   */\n  get fsPath() {\n    return uriToFsPath(this, false);\n  }\n  // ---- modify to new -------------------------\n  with(change) {\n    if (!change) {\n      return this;\n    }\n    let { scheme, authority, path, query, fragment } = change;\n    if (scheme === void 0) {\n      scheme = this.scheme;\n    } else if (scheme === null) {\n      scheme = _empty;\n    }\n    if (authority === void 0) {\n      authority = this.authority;\n    } else if (authority === null) {\n      authority = _empty;\n    }\n    if (path === void 0) {\n      path = this.path;\n    } else if (path === null) {\n      path = _empty;\n    }\n    if (query === void 0) {\n      query = this.query;\n    } else if (query === null) {\n      query = _empty;\n    }\n    if (fragment === void 0) {\n      fragment = this.fragment;\n    } else if (fragment === null) {\n      fragment = _empty;\n    }\n    if (scheme === this.scheme \u0026\u0026 authority === this.authority \u0026\u0026 path === this.path \u0026\u0026 query === this.query \u0026\u0026 fragment === this.fragment) {\n      return this;\n    }\n    return new Uri(scheme, authority, path, query, fragment);\n  }\n  // ---- parse \u0026 validate ------------------------\n  /**\n   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n   * `file:///usr/home`, or `scheme:with/path`.\n   *\n   * @param value A string which represents an URI (see `URI#toString`).\n   */\n  static parse(value, _strict = false) {\n    const match = _regexp.exec(value);\n    if (!match) {\n      return new Uri(_empty, _empty, _empty, _empty, _empty);\n    }\n    return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n  }\n  /**\n   * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n   * `/usr/home`, or `\\\\server\\share\\some\\path`.\n   *\n   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n   * `URI.parse('file://' + path)` because the path might contain characters that are\n   * interpreted (# and ?). See the following sample:\n   * ```ts\n  const good = URI.file('/coding/c#/project1');\n  good.scheme === 'file';\n  good.path === '/coding/c#/project1';\n  good.fragment === '';\n  const bad = URI.parse('file://' + '/coding/c#/project1');\n  bad.scheme === 'file';\n  bad.path === '/coding/c'; // path is now broken\n  bad.fragment === '/project1';\n  ```\n   *\n   * @param path A file system path (see `URI#fsPath`)\n   */\n  static file(path) {\n    let authority = _empty;\n    if (isWindows) {\n      path = path.replace(/\\\\/g, _slash);\n    }\n    if (path[0] === _slash \u0026\u0026 path[1] === _slash) {\n      const idx = path.indexOf(_slash, 2);\n      if (idx === -1) {\n        authority = path.substring(2);\n        path = _slash;\n      } else {\n        authority = path.substring(2, idx);\n        path = path.substring(idx) || _slash;\n      }\n    }\n    return new Uri(\"file\", authority, path, _empty, _empty);\n  }\n  /**\n   * Creates new URI from uri components.\n   *\n   * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\n   * validation and should be used for untrusted uri components retrieved from storage,\n   * user input, command arguments etc\n   */\n  static from(components, strict) {\n    const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);\n    return result;\n  }\n  /**\n   * Join a URI path with path fragments and normalizes the resulting path.\n   *\n   * @param uri The input URI.\n   * @param pathFragment The path fragment to add to the URI path.\n   * @returns The resulting URI.\n   */\n  static joinPath(uri, ...pathFragment) {\n    if (!uri.path) {\n      throw new Error(`[UriError]: cannot call joinPath on URI without path`);\n    }\n    let newPath;\n    if (isWindows \u0026\u0026 uri.scheme === \"file\") {\n      newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n    } else {\n      newPath = posix.join(uri.path, ...pathFragment);\n    }\n    return uri.with({ path: newPath });\n  }\n  // ---- printing/externalize ---------------------------\n  /**\n   * Creates a string representation for this URI. It's guaranteed that calling\n   * `URI.parse` with the result of this function creates an URI which is equal\n   * to this URI.\n   *\n   * * The result shall *not* be used for display purposes but for externalization or transport.\n   * * The result will be encoded using the percentage encoding and encoding happens mostly\n   * ignore the scheme-specific encoding rules.\n   *\n   * @param skipEncoding Do not encode the result, default is `false`\n   */\n  toString(skipEncoding = false) {\n    return _asFormatted(this, skipEncoding);\n  }\n  toJSON() {\n    return this;\n  }\n  static revive(data) {\n    var _a4, _b2;\n    if (!data) {\n      return data;\n    } else if (data instanceof _URI) {\n      return data;\n    } else {\n      const result = new Uri(data);\n      result._formatted = (_a4 = data.external) !== null \u0026\u0026 _a4 !== void 0 ? _a4 : null;\n      result._fsPath = data._sep === _pathSepMarker ? (_b2 = data.fsPath) !== null \u0026\u0026 _b2 !== void 0 ? _b2 : null : null;\n      return result;\n    }\n  }\n};\nvar _pathSepMarker = isWindows ? 1 : void 0;\nvar Uri = class extends URI {\n  constructor() {\n    super(...arguments);\n    this._formatted = null;\n    this._fsPath = null;\n  }\n  get fsPath() {\n    if (!this._fsPath) {\n      this._fsPath = uriToFsPath(this, false);\n    }\n    return this._fsPath;\n  }\n  toString(skipEncoding = false) {\n    if (!skipEncoding) {\n      if (!this._formatted) {\n        this._formatted = _asFormatted(this, false);\n      }\n      return this._formatted;\n    } else {\n      return _asFormatted(this, true);\n    }\n  }\n  toJSON() {\n    const res = {\n      $mid: 1\n      /* MarshalledId.Uri */\n    };\n    if (this._fsPath) {\n      res.fsPath = this._fsPath;\n      res._sep = _pathSepMarker;\n    }\n    if (this._formatted) {\n      res.external = this._formatted;\n    }\n    if (this.path) {\n      res.path = this.path;\n    }\n    if (this.scheme) {\n      res.scheme = this.scheme;\n    }\n    if (this.authority) {\n      res.authority = this.authority;\n    }\n    if (this.query) {\n      res.query = this.query;\n    }\n    if (this.fragment) {\n      res.fragment = this.fragment;\n    }\n    return res;\n  }\n};\nvar encodeTable = {\n  [\n    58\n    /* CharCode.Colon */\n  ]: \"%3A\",\n  // gen-delims\n  [\n    47\n    /* CharCode.Slash */\n  ]: \"%2F\",\n  [\n    63\n    /* CharCode.QuestionMark */\n  ]: \"%3F\",\n  [\n    35\n    /* CharCode.Hash */\n  ]: \"%23\",\n  [\n    91\n    /* CharCode.OpenSquareBracket */\n  ]: \"%5B\",\n  [\n    93\n    /* CharCode.CloseSquareBracket */\n  ]: \"%5D\",\n  [\n    64\n    /* CharCode.AtSign */\n  ]: \"%40\",\n  [\n    33\n    /* CharCode.ExclamationMark */\n  ]: \"%21\",\n  // sub-delims\n  [\n    36\n    /* CharCode.DollarSign */\n  ]: \"%24\",\n  [\n    38\n    /* CharCode.Ampersand */\n  ]: \"%26\",\n  [\n    39\n    /* CharCode.SingleQuote */\n  ]: \"%27\",\n  [\n    40\n    /* CharCode.OpenParen */\n  ]: \"%28\",\n  [\n    41\n    /* CharCode.CloseParen */\n  ]: \"%29\",\n  [\n    42\n    /* CharCode.Asterisk */\n  ]: \"%2A\",\n  [\n    43\n    /* CharCode.Plus */\n  ]: \"%2B\",\n  [\n    44\n    /* CharCode.Comma */\n  ]: \"%2C\",\n  [\n    59\n    /* CharCode.Semicolon */\n  ]: \"%3B\",\n  [\n    61\n    /* CharCode.Equals */\n  ]: \"%3D\",\n  [\n    32\n    /* CharCode.Space */\n  ]: \"%20\"\n};\nfunction encodeURIComponentFast(uriComponent, isPath, isAuthority) {\n  let res = void 0;\n  let nativeEncodePos = -1;\n  for (let pos = 0; pos \u003c uriComponent.length; pos++) {\n    const code = uriComponent.charCodeAt(pos);\n    if (code \u003e= 97 \u0026\u0026 code \u003c= 122 || code \u003e= 65 \u0026\u0026 code \u003c= 90 || code \u003e= 48 \u0026\u0026 code \u003c= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath \u0026\u0026 code === 47 || isAuthority \u0026\u0026 code === 91 || isAuthority \u0026\u0026 code === 93 || isAuthority \u0026\u0026 code === 58) {\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n        nativeEncodePos = -1;\n      }\n      if (res !== void 0) {\n        res += uriComponent.charAt(pos);\n      }\n    } else {\n      if (res === void 0) {\n        res = uriComponent.substr(0, pos);\n      }\n      const escaped = encodeTable[code];\n      if (escaped !== void 0) {\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n          nativeEncodePos = -1;\n        }\n        res += escaped;\n      } else if (nativeEncodePos === -1) {\n        nativeEncodePos = pos;\n      }\n    }\n  }\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n  }\n  return res !== void 0 ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n  let res = void 0;\n  for (let pos = 0; pos \u003c path.length; pos++) {\n    const code = path.charCodeAt(pos);\n    if (code === 35 || code === 63) {\n      if (res === void 0) {\n        res = path.substr(0, pos);\n      }\n      res += encodeTable[code];\n    } else {\n      if (res !== void 0) {\n        res += path[pos];\n      }\n    }\n  }\n  return res !== void 0 ? res : path;\n}\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\n  let value;\n  if (uri.authority \u0026\u0026 uri.path.length \u003e 1 \u0026\u0026 uri.scheme === \"file\") {\n    value = `//${uri.authority}${uri.path}`;\n  } else if (uri.path.charCodeAt(0) === 47 \u0026\u0026 (uri.path.charCodeAt(1) \u003e= 65 \u0026\u0026 uri.path.charCodeAt(1) \u003c= 90 || uri.path.charCodeAt(1) \u003e= 97 \u0026\u0026 uri.path.charCodeAt(1) \u003c= 122) \u0026\u0026 uri.path.charCodeAt(2) === 58) {\n    if (!keepDriveLetterCasing) {\n      value = uri.path[1].toLowerCase() + uri.path.substr(2);\n    } else {\n      value = uri.path.substr(1);\n    }\n  } else {\n    value = uri.path;\n  }\n  if (isWindows) {\n    value = value.replace(/\\//g, \"\\\\\");\n  }\n  return value;\n}\nfunction _asFormatted(uri, skipEncoding) {\n  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n  let res = \"\";\n  let { scheme, authority, path, query, fragment } = uri;\n  if (scheme) {\n    res += scheme;\n    res += \":\";\n  }\n  if (authority || scheme === \"file\") {\n    res += _slash;\n    res += _slash;\n  }\n  if (authority) {\n    let idx = authority.indexOf(\"@\");\n    if (idx !== -1) {\n      const userinfo = authority.substr(0, idx);\n      authority = authority.substr(idx + 1);\n      idx = userinfo.lastIndexOf(\":\");\n      if (idx === -1) {\n        res += encoder(userinfo, false, false);\n      } else {\n        res += encoder(userinfo.substr(0, idx), false, false);\n        res += \":\";\n        res += encoder(userinfo.substr(idx + 1), false, true);\n      }\n      res += \"@\";\n    }\n    authority = authority.toLowerCase();\n    idx = authority.lastIndexOf(\":\");\n    if (idx === -1) {\n      res += encoder(authority, false, true);\n    } else {\n      res += encoder(authority.substr(0, idx), false, true);\n      res += authority.substr(idx);\n    }\n  }\n  if (path) {\n    if (path.length \u003e= 3 \u0026\u0026 path.charCodeAt(0) === 47 \u0026\u0026 path.charCodeAt(2) === 58) {\n      const code = path.charCodeAt(1);\n      if (code \u003e= 65 \u0026\u0026 code \u003c= 90) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;\n      }\n    } else if (path.length \u003e= 2 \u0026\u0026 path.charCodeAt(1) === 58) {\n      const code = path.charCodeAt(0);\n      if (code \u003e= 65 \u0026\u0026 code \u003c= 90) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;\n      }\n    }\n    res += encoder(path, true, false);\n  }\n  if (query) {\n    res += \"?\";\n    res += encoder(query, false, false);\n  }\n  if (fragment) {\n    res += \"#\";\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n  }\n  return res;\n}\nfunction decodeURIComponentGraceful(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (_a4) {\n    if (str.length \u003e 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n    } else {\n      return str;\n    }\n  }\n}\nvar _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n  if (!str.match(_rEncodedAsHex)) {\n    return str;\n  }\n  return str.replace(_rEncodedAsHex, (match) =\u003e decodeURIComponentGraceful(match));\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js\nvar Position = class _Position {\n  constructor(lineNumber, column) {\n    this.lineNumber = lineNumber;\n    this.column = column;\n  }\n  /**\n   * Create a new position from this position.\n   *\n   * @param newLineNumber new line number\n   * @param newColumn new column\n   */\n  with(newLineNumber = this.lineNumber, newColumn = this.column) {\n    if (newLineNumber === this.lineNumber \u0026\u0026 newColumn === this.column) {\n      return this;\n    } else {\n      return new _Position(newLineNumber, newColumn);\n    }\n  }\n  /**\n   * Derive a new position from this position.\n   *\n   * @param deltaLineNumber line number delta\n   * @param deltaColumn column delta\n   */\n  delta(deltaLineNumber = 0, deltaColumn = 0) {\n    return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n  }\n  /**\n   * Test if this position equals other position\n   */\n  equals(other) {\n    return _Position.equals(this, other);\n  }\n  /**\n   * Test if position `a` equals position `b`\n   */\n  static equals(a2, b) {\n    if (!a2 \u0026\u0026 !b) {\n      return true;\n    }\n    return !!a2 \u0026\u0026 !!b \u0026\u0026 a2.lineNumber === b.lineNumber \u0026\u0026 a2.column === b.column;\n  }\n  /**\n   * Test if this position is before other position.\n   * If the two positions are equal, the result will be false.\n   */\n  isBefore(other) {\n    return _Position.isBefore(this, other);\n  }\n  /**\n   * Test if position `a` is before position `b`.\n   * If the two positions are equal, the result will be false.\n   */\n  static isBefore(a2, b) {\n    if (a2.lineNumber \u003c b.lineNumber) {\n      return true;\n    }\n    if (b.lineNumber \u003c a2.lineNumber) {\n      return false;\n    }\n    return a2.column \u003c b.column;\n  }\n  /**\n   * Test if this position is before other position.\n   * If the two positions are equal, the result will be true.\n   */\n  isBeforeOrEqual(other) {\n    return _Position.isBeforeOrEqual(this, other);\n  }\n  /**\n   * Test if position `a` is before position `b`.\n   * If the two positions are equal, the result will be true.\n   */\n  static isBeforeOrEqual(a2, b) {\n    if (a2.lineNumber \u003c b.lineNumber) {\n      return true;\n    }\n    if (b.lineNumber \u003c a2.lineNumber) {\n      return false;\n    }\n    return a2.column \u003c= b.column;\n  }\n  /**\n   * A function that compares positions, useful for sorting\n   */\n  static compare(a2, b) {\n    const aLineNumber = a2.lineNumber | 0;\n    const bLineNumber = b.lineNumber | 0;\n    if (aLineNumber === bLineNumber) {\n      const aColumn = a2.column | 0;\n      const bColumn = b.column | 0;\n      return aColumn - bColumn;\n    }\n    return aLineNumber - bLineNumber;\n  }\n  /**\n   * Clone this position.\n   */\n  clone() {\n    return new _Position(this.lineNumber, this.column);\n  }\n  /**\n   * Convert to a human-readable representation.\n   */\n  toString() {\n    return \"(\" + this.lineNumber + \",\" + this.column + \")\";\n  }\n  // ---\n  /**\n   * Create a `Position` from an `IPosition`.\n   */\n  static lift(pos) {\n    return new _Position(pos.lineNumber, pos.column);\n  }\n  /**\n   * Test if `obj` is an `IPosition`.\n   */\n  static isIPosition(obj) {\n    return obj \u0026\u0026 typeof obj.lineNumber === \"number\" \u0026\u0026 typeof obj.column === \"number\";\n  }\n  toJSON() {\n    return {\n      lineNumber: this.lineNumber,\n      column: this.column\n    };\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js\nvar Range = class _Range {\n  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n    if (startLineNumber \u003e endLineNumber || startLineNumber === endLineNumber \u0026\u0026 startColumn \u003e endColumn) {\n      this.startLineNumber = endLineNumber;\n      this.startColumn = endColumn;\n      this.endLineNumber = startLineNumber;\n      this.endColumn = startColumn;\n    } else {\n      this.startLineNumber = startLineNumber;\n      this.startColumn = startColumn;\n      this.endLineNumber = endLineNumber;\n      this.endColumn = endColumn;\n    }\n  }\n  /**\n   * Test if this range is empty.\n   */\n  isEmpty() {\n    return _Range.isEmpty(this);\n  }\n  /**\n   * Test if `range` is empty.\n   */\n  static isEmpty(range) {\n    return range.startLineNumber === range.endLineNumber \u0026\u0026 range.startColumn === range.endColumn;\n  }\n  /**\n   * Test if position is in this range. If the position is at the edges, will return true.\n   */\n  containsPosition(position) {\n    return _Range.containsPosition(this, position);\n  }\n  /**\n   * Test if `position` is in `range`. If the position is at the edges, will return true.\n   */\n  static containsPosition(range, position) {\n    if (position.lineNumber \u003c range.startLineNumber || position.lineNumber \u003e range.endLineNumber) {\n      return false;\n    }\n    if (position.lineNumber === range.startLineNumber \u0026\u0026 position.column \u003c range.startColumn) {\n      return false;\n    }\n    if (position.lineNumber === range.endLineNumber \u0026\u0026 position.column \u003e range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if `position` is in `range`. If the position is at the edges, will return false.\n   * @internal\n   */\n  static strictContainsPosition(range, position) {\n    if (position.lineNumber \u003c range.startLineNumber || position.lineNumber \u003e range.endLineNumber) {\n      return false;\n    }\n    if (position.lineNumber === range.startLineNumber \u0026\u0026 position.column \u003c= range.startColumn) {\n      return false;\n    }\n    if (position.lineNumber === range.endLineNumber \u0026\u0026 position.column \u003e= range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if range is in this range. If the range is equal to this range, will return true.\n   */\n  containsRange(range) {\n    return _Range.containsRange(this, range);\n  }\n  /**\n   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n   */\n  static containsRange(range, otherRange) {\n    if (otherRange.startLineNumber \u003c range.startLineNumber || otherRange.endLineNumber \u003c range.startLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber \u003e range.endLineNumber || otherRange.endLineNumber \u003e range.endLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber === range.startLineNumber \u0026\u0026 otherRange.startColumn \u003c range.startColumn) {\n      return false;\n    }\n    if (otherRange.endLineNumber === range.endLineNumber \u0026\u0026 otherRange.endColumn \u003e range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n   */\n  strictContainsRange(range) {\n    return _Range.strictContainsRange(this, range);\n  }\n  /**\n   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n   */\n  static strictContainsRange(range, otherRange) {\n    if (otherRange.startLineNumber \u003c range.startLineNumber || otherRange.endLineNumber \u003c range.startLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber \u003e range.endLineNumber || otherRange.endLineNumber \u003e range.endLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber === range.startLineNumber \u0026\u0026 otherRange.startColumn \u003c= range.startColumn) {\n      return false;\n    }\n    if (otherRange.endLineNumber === range.endLineNumber \u0026\u0026 otherRange.endColumn \u003e= range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * A reunion of the two ranges.\n   * The smallest position will be used as the start point, and the largest one as the end point.\n   */\n  plusRange(range) {\n    return _Range.plusRange(this, range);\n  }\n  /**\n   * A reunion of the two ranges.\n   * The smallest position will be used as the start point, and the largest one as the end point.\n   */\n  static plusRange(a2, b) {\n    let startLineNumber;\n    let startColumn;\n    let endLineNumber;\n    let endColumn;\n    if (b.startLineNumber \u003c a2.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = b.startColumn;\n    } else if (b.startLineNumber === a2.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = Math.min(b.startColumn, a2.startColumn);\n    } else {\n      startLineNumber = a2.startLineNumber;\n      startColumn = a2.startColumn;\n    }\n    if (b.endLineNumber \u003e a2.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = b.endColumn;\n    } else if (b.endLineNumber === a2.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = Math.max(b.endColumn, a2.endColumn);\n    } else {\n      endLineNumber = a2.endLineNumber;\n      endColumn = a2.endColumn;\n    }\n    return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  /**\n   * A intersection of the two ranges.\n   */\n  intersectRanges(range) {\n    return _Range.intersectRanges(this, range);\n  }\n  /**\n   * A intersection of the two ranges.\n   */\n  static intersectRanges(a2, b) {\n    let resultStartLineNumber = a2.startLineNumber;\n    let resultStartColumn = a2.startColumn;\n    let resultEndLineNumber = a2.endLineNumber;\n    let resultEndColumn = a2.endColumn;\n    const otherStartLineNumber = b.startLineNumber;\n    const otherStartColumn = b.startColumn;\n    const otherEndLineNumber = b.endLineNumber;\n    const otherEndColumn = b.endColumn;\n    if (resultStartLineNumber \u003c otherStartLineNumber) {\n      resultStartLineNumber = otherStartLineNumber;\n      resultStartColumn = otherStartColumn;\n    } else if (resultStartLineNumber === otherStartLineNumber) {\n      resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n    }\n    if (resultEndLineNumber \u003e otherEndLineNumber) {\n      resultEndLineNumber = otherEndLineNumber;\n      resultEndColumn = otherEndColumn;\n    } else if (resultEndLineNumber === otherEndLineNumber) {\n      resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n    }\n    if (resultStartLineNumber \u003e resultEndLineNumber) {\n      return null;\n    }\n    if (resultStartLineNumber === resultEndLineNumber \u0026\u0026 resultStartColumn \u003e resultEndColumn) {\n      return null;\n    }\n    return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n  }\n  /**\n   * Test if this range equals other.\n   */\n  equalsRange(other) {\n    return _Range.equalsRange(this, other);\n  }\n  /**\n   * Test if range `a` equals `b`.\n   */\n  static equalsRange(a2, b) {\n    if (!a2 \u0026\u0026 !b) {\n      return true;\n    }\n    return !!a2 \u0026\u0026 !!b \u0026\u0026 a2.startLineNumber === b.startLineNumber \u0026\u0026 a2.startColumn === b.startColumn \u0026\u0026 a2.endLineNumber === b.endLineNumber \u0026\u0026 a2.endColumn === b.endColumn;\n  }\n  /**\n   * Return the end position (which will be after or equal to the start position)\n   */\n  getEndPosition() {\n    return _Range.getEndPosition(this);\n  }\n  /**\n   * Return the end position (which will be after or equal to the start position)\n   */\n  static getEndPosition(range) {\n    return new Position(range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Return the start position (which will be before or equal to the end position)\n   */\n  getStartPosition() {\n    return _Range.getStartPosition(this);\n  }\n  /**\n   * Return the start position (which will be before or equal to the end position)\n   */\n  static getStartPosition(range) {\n    return new Position(range.startLineNumber, range.startColumn);\n  }\n  /**\n   * Transform to a user presentable string representation.\n   */\n  toString() {\n    return \"[\" + this.startLineNumber + \",\" + this.startColumn + \" -\u003e \" + this.endLineNumber + \",\" + this.endColumn + \"]\";\n  }\n  /**\n   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n   */\n  setEndPosition(endLineNumber, endColumn) {\n    return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n  }\n  /**\n   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n   */\n  setStartPosition(startLineNumber, startColumn) {\n    return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n  }\n  /**\n   * Create a new empty range using this range's start position.\n   */\n  collapseToStart() {\n    return _Range.collapseToStart(this);\n  }\n  /**\n   * Create a new empty range using this range's start position.\n   */\n  static collapseToStart(range) {\n    return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n  }\n  /**\n   * Create a new empty range using this range's end position.\n   */\n  collapseToEnd() {\n    return _Range.collapseToEnd(this);\n  }\n  /**\n   * Create a new empty range using this range's end position.\n   */\n  static collapseToEnd(range) {\n    return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Moves the range by the given amount of lines.\n   */\n  delta(lineCount) {\n    return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n  }\n  // ---\n  static fromPositions(start, end = start) {\n    return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n  static lift(range) {\n    if (!range) {\n      return null;\n    }\n    return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Test if `obj` is an `IRange`.\n   */\n  static isIRange(obj) {\n    return obj \u0026\u0026 typeof obj.startLineNumber === \"number\" \u0026\u0026 typeof obj.startColumn === \"number\" \u0026\u0026 typeof obj.endLineNumber === \"number\" \u0026\u0026 typeof obj.endColumn === \"number\";\n  }\n  /**\n   * Test if the two ranges are touching in any way.\n   */\n  static areIntersectingOrTouching(a2, b) {\n    if (a2.endLineNumber \u003c b.startLineNumber || a2.endLineNumber === b.startLineNumber \u0026\u0026 a2.endColumn \u003c b.startColumn) {\n      return false;\n    }\n    if (b.endLineNumber \u003c a2.startLineNumber || b.endLineNumber === a2.startLineNumber \u0026\u0026 b.endColumn \u003c a2.startColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n   */\n  static areIntersecting(a2, b) {\n    if (a2.endLineNumber \u003c b.startLineNumber || a2.endLineNumber === b.startLineNumber \u0026\u0026 a2.endColumn \u003c= b.startColumn) {\n      return false;\n    }\n    if (b.endLineNumber \u003c a2.startLineNumber || b.endLineNumber === a2.startLineNumber \u0026\u0026 b.endColumn \u003c= a2.startColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * A function that compares ranges, useful for sorting ranges\n   * It will first compare ranges on the startPosition and then on the endPosition\n   */\n  static compareRangesUsingStarts(a2, b) {\n    if (a2 \u0026\u0026 b) {\n      const aStartLineNumber = a2.startLineNumber | 0;\n      const bStartLineNumber = b.startLineNumber | 0;\n      if (aStartLineNumber === bStartLineNumber) {\n        const aStartColumn = a2.startColumn | 0;\n        const bStartColumn = b.startColumn | 0;\n        if (aStartColumn === bStartColumn) {\n          const aEndLineNumber = a2.endLineNumber | 0;\n          const bEndLineNumber = b.endLineNumber | 0;\n          if (aEndLineNumber === bEndLineNumber) {\n            const aEndColumn = a2.endColumn | 0;\n            const bEndColumn = b.endColumn | 0;\n            return aEndColumn - bEndColumn;\n          }\n          return aEndLineNumber - bEndLineNumber;\n        }\n        return aStartColumn - bStartColumn;\n      }\n      return aStartLineNumber - bStartLineNumber;\n    }\n    const aExists = a2 ? 1 : 0;\n    const bExists = b ? 1 : 0;\n    return aExists - bExists;\n  }\n  /**\n   * A function that compares ranges, useful for sorting ranges\n   * It will first compare ranges on the endPosition and then on the startPosition\n   */\n  static compareRangesUsingEnds(a2, b) {\n    if (a2.endLineNumber === b.endLineNumber) {\n      if (a2.endColumn === b.endColumn) {\n        if (a2.startLineNumber === b.startLineNumber) {\n          return a2.startColumn - b.startColumn;\n        }\n        return a2.startLineNumber - b.startLineNumber;\n      }\n      return a2.endColumn - b.endColumn;\n    }\n    return a2.endLineNumber - b.endLineNumber;\n  }\n  /**\n   * Test if the range spans multiple lines.\n   */\n  static spansMultipleLines(range) {\n    return range.endLineNumber \u003e range.startLineNumber;\n  }\n  toJSON() {\n    return this;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js\nfunction equals(one, other, itemEquals = (a2, b) =\u003e a2 === b) {\n  if (one === other) {\n    return true;\n  }\n  if (!one || !other) {\n    return false;\n  }\n  if (one.length !== other.length) {\n    return false;\n  }\n  for (let i = 0, len = one.length; i \u003c len; i++) {\n    if (!itemEquals(one[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction* groupAdjacentBy(items, shouldBeGrouped) {\n  let currentGroup;\n  let last;\n  for (const item of items) {\n    if (last !== void 0 \u0026\u0026 shouldBeGrouped(last, item)) {\n      currentGroup.push(item);\n    } else {\n      if (currentGroup) {\n        yield currentGroup;\n      }\n      currentGroup = [item];\n    }\n    last = item;\n  }\n  if (currentGroup) {\n    yield currentGroup;\n  }\n}\nfunction forEachAdjacent(arr, f2) {\n  for (let i = 0; i \u003c= arr.length; i++) {\n    f2(i === 0 ? void 0 : arr[i - 1], i === arr.length ? void 0 : arr[i]);\n  }\n}\nfunction forEachWithNeighbors(arr, f2) {\n  for (let i = 0; i \u003c arr.length; i++) {\n    f2(i === 0 ? void 0 : arr[i - 1], arr[i], i + 1 === arr.length ? void 0 : arr[i + 1]);\n  }\n}\nfunction pushMany(arr, items) {\n  for (const item of items) {\n    arr.push(item);\n  }\n}\nvar CompareResult;\n(function(CompareResult2) {\n  function isLessThan(result) {\n    return result \u003c 0;\n  }\n  CompareResult2.isLessThan = isLessThan;\n  function isLessThanOrEqual(result) {\n    return result \u003c= 0;\n  }\n  CompareResult2.isLessThanOrEqual = isLessThanOrEqual;\n  function isGreaterThan(result) {\n    return result \u003e 0;\n  }\n  CompareResult2.isGreaterThan = isGreaterThan;\n  function isNeitherLessOrGreaterThan(result) {\n    return result === 0;\n  }\n  CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;\n  CompareResult2.greaterThan = 1;\n  CompareResult2.lessThan = -1;\n  CompareResult2.neitherLessOrGreaterThan = 0;\n})(CompareResult || (CompareResult = {}));\nfunction compareBy(selector, comparator) {\n  return (a2, b) =\u003e comparator(selector(a2), selector(b));\n}\nvar numberComparator = (a2, b) =\u003e a2 - b;\nfunction reverseOrder(comparator) {\n  return (a2, b) =\u003e -comparator(a2, b);\n}\nvar CallbackIterable = class _CallbackIterable {\n  constructor(iterate) {\n    this.iterate = iterate;\n  }\n  toArray() {\n    const result = [];\n    this.iterate((item) =\u003e {\n      result.push(item);\n      return true;\n    });\n    return result;\n  }\n  filter(predicate) {\n    return new _CallbackIterable((cb) =\u003e this.iterate((item) =\u003e predicate(item) ? cb(item) : true));\n  }\n  map(mapFn) {\n    return new _CallbackIterable((cb) =\u003e this.iterate((item) =\u003e cb(mapFn(item))));\n  }\n  findLast(predicate) {\n    let result;\n    this.iterate((item) =\u003e {\n      if (predicate(item)) {\n        result = item;\n      }\n      return true;\n    });\n    return result;\n  }\n  findLastMaxBy(comparator) {\n    let result;\n    let first = true;\n    this.iterate((item) =\u003e {\n      if (first || CompareResult.isGreaterThan(comparator(item, result))) {\n        first = false;\n        result = item;\n      }\n      return true;\n    });\n    return result;\n  }\n};\nCallbackIterable.empty = new CallbackIterable((_callback) =\u003e {\n});\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/uint.js\nfunction toUint8(v) {\n  if (v \u003c 0) {\n    return 0;\n  }\n  if (v \u003e 255) {\n    return 255;\n  }\n  return v | 0;\n}\nfunction toUint32(v) {\n  if (v \u003c 0) {\n    return 0;\n  }\n  if (v \u003e 4294967295) {\n    return 4294967295;\n  }\n  return v | 0;\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js\nvar PrefixSumComputer = class {\n  constructor(values) {\n    this.values = values;\n    this.prefixSum = new Uint32Array(values.length);\n    this.prefixSumValidIndex = new Int32Array(1);\n    this.prefixSumValidIndex[0] = -1;\n  }\n  insertValues(insertIndex, insertValues) {\n    insertIndex = toUint32(insertIndex);\n    const oldValues = this.values;\n    const oldPrefixSum = this.prefixSum;\n    const insertValuesLen = insertValues.length;\n    if (insertValuesLen === 0) {\n      return false;\n    }\n    this.values = new Uint32Array(oldValues.length + insertValuesLen);\n    this.values.set(oldValues.subarray(0, insertIndex), 0);\n    this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n    this.values.set(insertValues, insertIndex);\n    if (insertIndex - 1 \u003c this.prefixSumValidIndex[0]) {\n      this.prefixSumValidIndex[0] = insertIndex - 1;\n    }\n    this.prefixSum = new Uint32Array(this.values.length);\n    if (this.prefixSumValidIndex[0] \u003e= 0) {\n      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n    }\n    return true;\n  }\n  setValue(index, value) {\n    index = toUint32(index);\n    value = toUint32(value);\n    if (this.values[index] === value) {\n      return false;\n    }\n    this.values[index] = value;\n    if (index - 1 \u003c this.prefixSumValidIndex[0]) {\n      this.prefixSumValidIndex[0] = index - 1;\n    }\n    return true;\n  }\n  removeValues(startIndex, count) {\n    startIndex = toUint32(startIndex);\n    count = toUint32(count);\n    const oldValues = this.values;\n    const oldPrefixSum = this.prefixSum;\n    if (startIndex \u003e= oldValues.length) {\n      return false;\n    }\n    const maxCount = oldValues.length - startIndex;\n    if (count \u003e= maxCount) {\n      count = maxCount;\n    }\n    if (count === 0) {\n      return false;\n    }\n    this.values = new Uint32Array(oldValues.length - count);\n    this.values.set(oldValues.subarray(0, startIndex), 0);\n    this.values.set(oldValues.subarray(startIndex + count), startIndex);\n    this.prefixSum = new Uint32Array(this.values.length);\n    if (startIndex - 1 \u003c this.prefixSumValidIndex[0]) {\n      this.prefixSumValidIndex[0] = startIndex - 1;\n    }\n    if (this.prefixSumValidIndex[0] \u003e= 0) {\n      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n    }\n    return true;\n  }\n  getTotalSum() {\n    if (this.values.length === 0) {\n      return 0;\n    }\n    return this._getPrefixSum(this.values.length - 1);\n  }\n  /**\n   * Returns the sum of the first `index + 1` many items.\n   * @returns `SUM(0 \u003c= j \u003c= index, values[j])`.\n   */\n  getPrefixSum(index) {\n    if (index \u003c 0) {\n      return 0;\n    }\n    index = toUint32(index);\n    return this._getPrefixSum(index);\n  }\n  _getPrefixSum(index) {\n    if (index \u003c= this.prefixSumValidIndex[0]) {\n      return this.prefixSum[index];\n    }\n    let startIndex = this.prefixSumValidIndex[0] + 1;\n    if (startIndex === 0) {\n      this.prefixSum[0] = this.values[0];\n      startIndex++;\n    }\n    if (index \u003e= this.values.length) {\n      index = this.values.length - 1;\n    }\n    for (let i = startIndex; i \u003c= index; i++) {\n      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n    }\n    this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n    return this.prefixSum[index];\n  }\n  getIndexOf(sum) {\n    sum = Math.floor(sum);\n    this.getTotalSum();\n    let low = 0;\n    let high = this.values.length - 1;\n    let mid = 0;\n    let midStop = 0;\n    let midStart = 0;\n    while (low \u003c= high) {\n      mid = low + (high - low) / 2 | 0;\n      midStop = this.prefixSum[mid];\n      midStart = midStop - this.values[mid];\n      if (sum \u003c midStart) {\n        high = mid - 1;\n      } else if (sum \u003e= midStop) {\n        low = mid + 1;\n      } else {\n        break;\n      }\n    }\n    return new PrefixSumIndexOfResult(mid, sum - midStart);\n  }\n};\nvar PrefixSumIndexOfResult = class {\n  constructor(index, remainder) {\n    this.index = index;\n    this.remainder = remainder;\n    this._prefixSumIndexOfResultBrand = void 0;\n    this.index = index;\n    this.remainder = remainder;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js\nvar MirrorTextModel = class {\n  constructor(uri, lines, eol, versionId) {\n    this._uri = uri;\n    this._lines = lines;\n    this._eol = eol;\n    this._versionId = versionId;\n    this._lineStarts = null;\n    this._cachedTextValue = null;\n  }\n  dispose() {\n    this._lines.length = 0;\n  }\n  get version() {\n    return this._versionId;\n  }\n  getText() {\n    if (this._cachedTextValue === null) {\n      this._cachedTextValue = this._lines.join(this._eol);\n    }\n    return this._cachedTextValue;\n  }\n  onEvents(e) {\n    if (e.eol \u0026\u0026 e.eol !== this._eol) {\n      this._eol = e.eol;\n      this._lineStarts = null;\n    }\n    const changes = e.changes;\n    for (const change of changes) {\n      this._acceptDeleteRange(change.range);\n      this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n    }\n    this._versionId = e.versionId;\n    this._cachedTextValue = null;\n  }\n  _ensureLineStarts() {\n    if (!this._lineStarts) {\n      const eolLength = this._eol.length;\n      const linesLength = this._lines.length;\n      const lineStartValues = new Uint32Array(linesLength);\n      for (let i = 0; i \u003c linesLength; i++) {\n        lineStartValues[i] = this._lines[i].length + eolLength;\n      }\n      this._lineStarts = new PrefixSumComputer(lineStartValues);\n    }\n  }\n  /**\n   * All changes to a line's text go through this method\n   */\n  _setLineText(lineIndex, newValue) {\n    this._lines[lineIndex] = newValue;\n    if (this._lineStarts) {\n      this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n    }\n  }\n  _acceptDeleteRange(range) {\n    if (range.startLineNumber === range.endLineNumber) {\n      if (range.startColumn === range.endColumn) {\n        return;\n      }\n      this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n      return;\n    }\n    this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n    this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    if (this._lineStarts) {\n      this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n  }\n  _acceptInsertText(position, insertText) {\n    if (insertText.length === 0) {\n      return;\n    }\n    const insertLines = splitLines(insertText);\n    if (insertLines.length === 1) {\n      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));\n      return;\n    }\n    insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n    this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);\n    const newLengths = new Uint32Array(insertLines.length - 1);\n    for (let i = 1; i \u003c insertLines.length; i++) {\n      this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n      newLengths[i - 1] = insertLines[i].length + this._eol.length;\n    }\n    if (this._lineStarts) {\n      this._lineStarts.insertValues(position.lineNumber, newLengths);\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js\nvar USUAL_WORD_SEPARATORS = \"`~!@#$%^\u0026*()-=+[{]}\\\\|;:'\\\",.\u003c\u003e/?\";\nfunction createWordRegExp(allowInWords = \"\") {\n  let source = \"(-?\\\\d*\\\\.\\\\d\\\\w*)|([^\";\n  for (const sep2 of USUAL_WORD_SEPARATORS) {\n    if (allowInWords.indexOf(sep2) \u003e= 0) {\n      continue;\n    }\n    source += \"\\\\\" + sep2;\n  }\n  source += \"\\\\s]+)\";\n  return new RegExp(source, \"g\");\n}\nvar DEFAULT_WORD_REGEXP = createWordRegExp();\nfunction ensureValidWordDefinition(wordDefinition) {\n  let result = DEFAULT_WORD_REGEXP;\n  if (wordDefinition \u0026\u0026 wordDefinition instanceof RegExp) {\n    if (!wordDefinition.global) {\n      let flags = \"g\";\n      if (wordDefinition.ignoreCase) {\n        flags += \"i\";\n      }\n      if (wordDefinition.multiline) {\n        flags += \"m\";\n      }\n      if (wordDefinition.unicode) {\n        flags += \"u\";\n      }\n      result = new RegExp(wordDefinition.source, flags);\n    } else {\n      result = wordDefinition;\n    }\n  }\n  result.lastIndex = 0;\n  return result;\n}\nvar _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n  maxLen: 1e3,\n  windowSize: 15,\n  timeBudget: 150\n});\nfunction getWordAtText(column, wordDefinition, text, textOffset, config) {\n  wordDefinition = ensureValidWordDefinition(wordDefinition);\n  if (!config) {\n    config = Iterable.first(_defaultConfig);\n  }\n  if (text.length \u003e config.maxLen) {\n    let start = column - config.maxLen / 2;\n    if (start \u003c 0) {\n      start = 0;\n    } else {\n      textOffset += start;\n    }\n    text = text.substring(start, column + config.maxLen / 2);\n    return getWordAtText(column, wordDefinition, text, textOffset, config);\n  }\n  const t1 = Date.now();\n  const pos = column - 1 - textOffset;\n  let prevRegexIndex = -1;\n  let match = null;\n  for (let i = 1; ; i++) {\n    if (Date.now() - t1 \u003e= config.timeBudget) {\n      break;\n    }\n    const regexIndex = pos - config.windowSize * i;\n    wordDefinition.lastIndex = Math.max(0, regexIndex);\n    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n    if (!thisMatch \u0026\u0026 match) {\n      break;\n    }\n    match = thisMatch;\n    if (regexIndex \u003c= 0) {\n      break;\n    }\n    prevRegexIndex = regexIndex;\n  }\n  if (match) {\n    const result = {\n      word: match[0],\n      startColumn: textOffset + 1 + match.index,\n      endColumn: textOffset + 1 + match.index + match[0].length\n    };\n    wordDefinition.lastIndex = 0;\n    return result;\n  }\n  return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n  let match;\n  while (match = wordDefinition.exec(text)) {\n    const matchIndex = match.index || 0;\n    if (matchIndex \u003c= pos \u0026\u0026 wordDefinition.lastIndex \u003e= pos) {\n      return match;\n    } else if (stopPos \u003e 0 \u0026\u0026 matchIndex \u003e stopPos) {\n      return null;\n    }\n  }\n  return null;\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js\nvar CharacterClassifier = class _CharacterClassifier {\n  constructor(_defaultValue) {\n    const defaultValue = toUint8(_defaultValue);\n    this._defaultValue = defaultValue;\n    this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);\n    this._map = /* @__PURE__ */ new Map();\n  }\n  static _createAsciiMap(defaultValue) {\n    const asciiMap = new Uint8Array(256);\n    asciiMap.fill(defaultValue);\n    return asciiMap;\n  }\n  set(charCode, _value) {\n    const value = toUint8(_value);\n    if (charCode \u003e= 0 \u0026\u0026 charCode \u003c 256) {\n      this._asciiMap[charCode] = value;\n    } else {\n      this._map.set(charCode, value);\n    }\n  }\n  get(charCode) {\n    if (charCode \u003e= 0 \u0026\u0026 charCode \u003c 256) {\n      return this._asciiMap[charCode];\n    } else {\n      return this._map.get(charCode) || this._defaultValue;\n    }\n  }\n  clear() {\n    this._asciiMap.fill(this._defaultValue);\n    this._map.clear();\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js\nvar Uint8Matrix = class {\n  constructor(rows, cols, defaultValue) {\n    const data = new Uint8Array(rows * cols);\n    for (let i = 0, len = rows * cols; i \u003c len; i++) {\n      data[i] = defaultValue;\n    }\n    this._data = data;\n    this.rows = rows;\n    this.cols = cols;\n  }\n  get(row, col) {\n    return this._data[row * this.cols + col];\n  }\n  set(row, col, value) {\n    this._data[row * this.cols + col] = value;\n  }\n};\nvar StateMachine = class {\n  constructor(edges) {\n    let maxCharCode = 0;\n    let maxState = 0;\n    for (let i = 0, len = edges.length; i \u003c len; i++) {\n      const [from, chCode, to] = edges[i];\n      if (chCode \u003e maxCharCode) {\n        maxCharCode = chCode;\n      }\n      if (from \u003e maxState) {\n        maxState = from;\n      }\n      if (to \u003e maxState) {\n        maxState = to;\n      }\n    }\n    maxCharCode++;\n    maxState++;\n    const states = new Uint8Matrix(\n      maxState,\n      maxCharCode,\n      0\n      /* State.Invalid */\n    );\n    for (let i = 0, len = edges.length; i \u003c len; i++) {\n      const [from, chCode, to] = edges[i];\n      states.set(from, chCode, to);\n    }\n    this._states = states;\n    this._maxCharCode = maxCharCode;\n  }\n  nextState(currentState, chCode) {\n    if (chCode \u003c 0 || chCode \u003e= this._maxCharCode) {\n      return 0;\n    }\n    return this._states.get(currentState, chCode);\n  }\n};\nvar _stateMachine = null;\nfunction getStateMachine() {\n  if (_stateMachine === null) {\n    _stateMachine = new StateMachine([\n      [\n        1,\n        104,\n        2\n        /* State.H */\n      ],\n      [\n        1,\n        72,\n        2\n        /* State.H */\n      ],\n      [\n        1,\n        102,\n        6\n        /* State.F */\n      ],\n      [\n        1,\n        70,\n        6\n        /* State.F */\n      ],\n      [\n        2,\n        116,\n        3\n        /* State.HT */\n      ],\n      [\n        2,\n        84,\n        3\n        /* State.HT */\n      ],\n      [\n        3,\n        116,\n        4\n        /* State.HTT */\n      ],\n      [\n        3,\n        84,\n        4\n        /* State.HTT */\n      ],\n      [\n        4,\n        112,\n        5\n        /* State.HTTP */\n      ],\n      [\n        4,\n        80,\n        5\n        /* State.HTTP */\n      ],\n      [\n        5,\n        115,\n        9\n        /* State.BeforeColon */\n      ],\n      [\n        5,\n        83,\n        9\n        /* State.BeforeColon */\n      ],\n      [\n        5,\n        58,\n        10\n        /* State.AfterColon */\n      ],\n      [\n        6,\n        105,\n        7\n        /* State.FI */\n      ],\n      [\n        6,\n        73,\n        7\n        /* State.FI */\n      ],\n      [\n        7,\n        108,\n        8\n        /* State.FIL */\n      ],\n      [\n        7,\n        76,\n        8\n        /* State.FIL */\n      ],\n      [\n        8,\n        101,\n        9\n        /* State.BeforeColon */\n      ],\n      [\n        8,\n        69,\n        9\n        /* State.BeforeColon */\n      ],\n      [\n        9,\n        58,\n        10\n        /* State.AfterColon */\n      ],\n      [\n        10,\n        47,\n        11\n        /* State.AlmostThere */\n      ],\n      [\n        11,\n        47,\n        12\n        /* State.End */\n      ]\n    ]);\n  }\n  return _stateMachine;\n}\nvar _classifier = null;\nfunction getClassifier() {\n  if (_classifier === null) {\n    _classifier = new CharacterClassifier(\n      0\n      /* CharacterClass.None */\n    );\n    const FORCE_TERMINATION_CHARACTERS = ` \t\u003c\u003e'\"\\u3001\\u3002\\uFF61\\uFF64\\uFF0C\\uFF0E\\uFF1A\\uFF1B\\u2018\\u3008\\u300C\\u300E\\u3014\\uFF08\\uFF3B\\uFF5B\\uFF62\\uFF63\\uFF5D\\uFF3D\\uFF09\\u3015\\u300F\\u300D\\u3009\\u2019\\uFF40\\uFF5E\\u2026`;\n    for (let i = 0; i \u003c FORCE_TERMINATION_CHARACTERS.length; i++) {\n      _classifier.set(\n        FORCE_TERMINATION_CHARACTERS.charCodeAt(i),\n        1\n        /* CharacterClass.ForceTermination */\n      );\n    }\n    const CANNOT_END_WITH_CHARACTERS = \".,;:\";\n    for (let i = 0; i \u003c CANNOT_END_WITH_CHARACTERS.length; i++) {\n      _classifier.set(\n        CANNOT_END_WITH_CHARACTERS.charCodeAt(i),\n        2\n        /* CharacterClass.CannotEndIn */\n      );\n    }\n  }\n  return _classifier;\n}\nvar LinkComputer = class _LinkComputer {\n  static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n    let lastIncludedCharIndex = linkEndIndex - 1;\n    do {\n      const chCode = line.charCodeAt(lastIncludedCharIndex);\n      const chClass = classifier.get(chCode);\n      if (chClass !== 2) {\n        break;\n      }\n      lastIncludedCharIndex--;\n    } while (lastIncludedCharIndex \u003e linkBeginIndex);\n    if (linkBeginIndex \u003e 0) {\n      const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n      const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n      if (charCodeBeforeLink === 40 \u0026\u0026 lastCharCodeInLink === 41 || charCodeBeforeLink === 91 \u0026\u0026 lastCharCodeInLink === 93 || charCodeBeforeLink === 123 \u0026\u0026 lastCharCodeInLink === 125) {\n        lastIncludedCharIndex--;\n      }\n    }\n    return {\n      range: {\n        startLineNumber: lineNumber,\n        startColumn: linkBeginIndex + 1,\n        endLineNumber: lineNumber,\n        endColumn: lastIncludedCharIndex + 2\n      },\n      url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n    };\n  }\n  static computeLinks(model, stateMachine = getStateMachine()) {\n    const classifier = getClassifier();\n    const result = [];\n    for (let i = 1, lineCount = model.getLineCount(); i \u003c= lineCount; i++) {\n      const line = model.getLineContent(i);\n      const len = line.length;\n      let j = 0;\n      let linkBeginIndex = 0;\n      let linkBeginChCode = 0;\n      let state = 1;\n      let hasOpenParens = false;\n      let hasOpenSquareBracket = false;\n      let inSquareBrackets = false;\n      let hasOpenCurlyBracket = false;\n      while (j \u003c len) {\n        let resetStateMachine = false;\n        const chCode = line.charCodeAt(j);\n        if (state === 13) {\n          let chClass;\n          switch (chCode) {\n            case 40:\n              hasOpenParens = true;\n              chClass = 0;\n              break;\n            case 41:\n              chClass = hasOpenParens ? 0 : 1;\n              break;\n            case 91:\n              inSquareBrackets = true;\n              hasOpenSquareBracket = true;\n              chClass = 0;\n              break;\n            case 93:\n              inSquareBrackets = false;\n              chClass = hasOpenSquareBracket ? 0 : 1;\n              break;\n            case 123:\n              hasOpenCurlyBracket = true;\n              chClass = 0;\n              break;\n            case 125:\n              chClass = hasOpenCurlyBracket ? 0 : 1;\n              break;\n            case 39:\n            case 34:\n            case 96:\n              if (linkBeginChCode === chCode) {\n                chClass = 1;\n              } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {\n                chClass = 0;\n              } else {\n                chClass = 1;\n              }\n              break;\n            case 42:\n              chClass = linkBeginChCode === 42 ? 1 : 0;\n              break;\n            case 124:\n              chClass = linkBeginChCode === 124 ? 1 : 0;\n              break;\n            case 32:\n              chClass = inSquareBrackets ? 0 : 1;\n              break;\n            default:\n              chClass = classifier.get(chCode);\n          }\n          if (chClass === 1) {\n            result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n            resetStateMachine = true;\n          }\n        } else if (state === 12) {\n          let chClass;\n          if (chCode === 91) {\n            hasOpenSquareBracket = true;\n            chClass = 0;\n          } else {\n            chClass = classifier.get(chCode);\n          }\n          if (chClass === 1) {\n            resetStateMachine = true;\n          } else {\n            state = 13;\n          }\n        } else {\n          state = stateMachine.nextState(state, chCode);\n          if (state === 0) {\n            resetStateMachine = true;\n          }\n        }\n        if (resetStateMachine) {\n          state = 1;\n          hasOpenParens = false;\n          hasOpenSquareBracket = false;\n          hasOpenCurlyBracket = false;\n          linkBeginIndex = j + 1;\n          linkBeginChCode = chCode;\n        }\n        j++;\n      }\n      if (state === 13) {\n        result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n      }\n    }\n    return result;\n  }\n};\nfunction computeLinks(model) {\n  if (!model || typeof model.getLineCount !== \"function\" || typeof model.getLineContent !== \"function\") {\n    return [];\n  }\n  return LinkComputer.computeLinks(model);\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js\nvar BasicInplaceReplace = class {\n  constructor() {\n    this._defaultValueSet = [\n      [\"true\", \"false\"],\n      [\"True\", \"False\"],\n      [\"Private\", \"Public\", \"Friend\", \"ReadOnly\", \"Partial\", \"Protected\", \"WriteOnly\"],\n      [\"public\", \"protected\", \"private\"]\n    ];\n  }\n  navigateValueSet(range1, text1, range2, text2, up) {\n    if (range1 \u0026\u0026 text1) {\n      const result = this.doNavigateValueSet(text1, up);\n      if (result) {\n        return {\n          range: range1,\n          value: result\n        };\n      }\n    }\n    if (range2 \u0026\u0026 text2) {\n      const result = this.doNavigateValueSet(text2, up);\n      if (result) {\n        return {\n          range: range2,\n          value: result\n        };\n      }\n    }\n    return null;\n  }\n  doNavigateValueSet(text, up) {\n    const numberResult = this.numberReplace(text, up);\n    if (numberResult !== null) {\n      return numberResult;\n    }\n    return this.textReplace(text, up);\n  }\n  numberReplace(value, up) {\n    const precision = Math.pow(10, value.length - (value.lastIndexOf(\".\") + 1));\n    let n1 = Number(value);\n    const n2 = parseFloat(value);\n    if (!isNaN(n1) \u0026\u0026 !isNaN(n2) \u0026\u0026 n1 === n2) {\n      if (n1 === 0 \u0026\u0026 !up) {\n        return null;\n      } else {\n        n1 = Math.floor(n1 * precision);\n        n1 += up ? precision : -precision;\n        return String(n1 / precision);\n      }\n    }\n    return null;\n  }\n  textReplace(value, up) {\n    return this.valueSetsReplace(this._defaultValueSet, value, up);\n  }\n  valueSetsReplace(valueSets, value, up) {\n    let result = null;\n    for (let i = 0, len = valueSets.length; result === null \u0026\u0026 i \u003c len; i++) {\n      result = this.valueSetReplace(valueSets[i], value, up);\n    }\n    return result;\n  }\n  valueSetReplace(valueSet, value, up) {\n    let idx = valueSet.indexOf(value);\n    if (idx \u003e= 0) {\n      idx += up ? 1 : -1;\n      if (idx \u003c 0) {\n        idx = valueSet.length - 1;\n      } else {\n        idx %= valueSet.length;\n      }\n      return valueSet[idx];\n    }\n    return null;\n  }\n};\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js\nvar shortcutEvent = Object.freeze(function(callback, context) {\n  const handle = setTimeout(callback.bind(context), 0);\n  return { dispose() {\n    clearTimeout(handle);\n  } };\n});\nvar CancellationToken;\n(function(CancellationToken2) {\n  function isCancellationToken(thing) {\n    if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {\n      return true;\n    }\n    if (thing instanceof MutableToken) {\n      return true;\n    }\n    if (!thing || typeof thing !== \"object\") {\n      return false;\n    }\n    return typeof thing.isCancellationRequested === \"boolean\" \u0026\u0026 typeof thing.onCancellationRequested === \"function\";\n  }\n  CancellationToken2.isCancellationToken = isCancellationToken;\n  CancellationToken2.None = Object.freeze({\n    isCancellationRequested: false,\n    onCancellationRequested: Event.None\n  });\n  CancellationToken2.Cancelled = Object.freeze({\n    isCancellationRequested: true,\n    onCancellationRequested: shortcutEvent\n  });\n})(CancellationToken || (CancellationToken = {}));\nvar MutableToken = class {\n  constructor() {\n    this._isCancelled = false;\n    this._emitter = null;\n  }\n  cancel() {\n    if (!this._isCancelled) {\n      this._isCancelled = true;\n      if (this._emitter) {\n        this._emitter.fire(void 0);\n        this.dispose();\n      }\n    }\n  }\n  get isCancellationRequested() {\n    return this._isCancelled;\n  }\n  get onCancellationRequested() {\n    if (this._isCancelled) {\n      return shortcutEvent;\n    }\n    if (!this._emitter) {\n      this._emitter = new Emitter();\n    }\n    return this._emitter.event;\n  }\n  dispose() {\n    if (this._emitter) {\n      this._emitter.dispose();\n      this._emitter = null;\n    }\n  }\n};\nvar CancellationTokenSource = class {\n  constructor(parent) {\n    this._token = void 0;\n    this._parentListener = void 0;\n    this._parentListener = parent \u0026\u0026 parent.onCancellationRequested(this.cancel, this);\n  }\n  get token() {\n    if (!this._token) {\n      this._token = new MutableToken();\n    }\n    return this._token;\n  }\n  cancel() {\n    if (!this._token) {\n      this._token = CancellationToken.Cancelled;\n    } else if (this._token instanceof MutableToken) {\n      this._token.cancel();\n    }\n  }\n  dispose(cancel = false) {\n    var _a4;\n    if (cancel) {\n      this.cancel();\n    }\n    (_a4 = this._parentListener) === null || _a4 === void 0 ? void 0 : _a4.dispose();\n    if (!this._token) {\n      this._token = CancellationToken.None;\n    } else if (this._token instanceof MutableToken) {\n      this._token.dispose();\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js\nvar KeyCodeStrMap = class {\n  constructor() {\n    this._keyCodeToStr = [];\n    this._strToKeyCode = /* @__PURE__ */ Object.create(null);\n  }\n  define(keyCode, str) {\n    this._keyCodeToStr[keyCode] = str;\n    this._strToKeyCode[str.toLowerCase()] = keyCode;\n  }\n  keyCodeToStr(keyCode) {\n    return this._keyCodeToStr[keyCode];\n  }\n  strToKeyCode(str) {\n    return this._strToKeyCode[str.toLowerCase()] || 0;\n  }\n};\nvar uiMap = new KeyCodeStrMap();\nvar userSettingsUSMap = new KeyCodeStrMap();\nvar userSettingsGeneralMap = new KeyCodeStrMap();\nvar EVENT_KEY_CODE_MAP = new Array(230);\nvar NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};\nvar scanCodeIntToStr = [];\nvar scanCodeStrToInt = /* @__PURE__ */ Object.create(null);\nvar scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);\nvar IMMUTABLE_CODE_TO_KEY_CODE = [];\nvar IMMUTABLE_KEY_CODE_TO_CODE = [];\nfor (let i = 0; i \u003c= 193; i++) {\n  IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;\n}\nfor (let i = 0; i \u003c= 132; i++) {\n  IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;\n}\n(function() {\n  const empty = \"\";\n  const mappings = [\n    // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel\n    [1, 0, \"None\", 0, \"unknown\", 0, \"VK_UNKNOWN\", empty, empty],\n    [1, 1, \"Hyper\", 0, empty, 0, empty, empty, empty],\n    [1, 2, \"Super\", 0, empty, 0, empty, empty, empty],\n    [1, 3, \"Fn\", 0, empty, 0, empty, empty, empty],\n    [1, 4, \"FnLock\", 0, empty, 0, empty, empty, empty],\n    [1, 5, \"Suspend\", 0, empty, 0, empty, empty, empty],\n    [1, 6, \"Resume\", 0, empty, 0, empty, empty, empty],\n    [1, 7, \"Turbo\", 0, empty, 0, empty, empty, empty],\n    [1, 8, \"Sleep\", 0, empty, 0, \"VK_SLEEP\", empty, empty],\n    [1, 9, \"WakeUp\", 0, empty, 0, empty, empty, empty],\n    [0, 10, \"KeyA\", 31, \"A\", 65, \"VK_A\", empty, empty],\n    [0, 11, \"KeyB\", 32, \"B\", 66, \"VK_B\", empty, empty],\n    [0, 12, \"KeyC\", 33, \"C\", 67, \"VK_C\", empty, empty],\n    [0, 13, \"KeyD\", 34, \"D\", 68, \"VK_D\", empty, empty],\n    [0, 14, \"KeyE\", 35, \"E\", 69, \"VK_E\", empty, empty],\n    [0, 15, \"KeyF\", 36, \"F\", 70, \"VK_F\", empty, empty],\n    [0, 16, \"KeyG\", 37, \"G\", 71, \"VK_G\", empty, empty],\n    [0, 17, \"KeyH\", 38, \"H\", 72, \"VK_H\", empty, empty],\n    [0, 18, \"KeyI\", 39, \"I\", 73, \"VK_I\", empty, empty],\n    [0, 19, \"KeyJ\", 40, \"J\", 74, \"VK_J\", empty, empty],\n    [0, 20, \"KeyK\", 41, \"K\", 75, \"VK_K\", empty, empty],\n    [0, 21, \"KeyL\", 42, \"L\", 76, \"VK_L\", empty, empty],\n    [0, 22, \"KeyM\", 43, \"M\", 77, \"VK_M\", empty, empty],\n    [0, 23, \"KeyN\", 44, \"N\", 78, \"VK_N\", empty, empty],\n    [0, 24, \"KeyO\", 45, \"O\", 79, \"VK_O\", empty, empty],\n    [0, 25, \"KeyP\", 46, \"P\", 80, \"VK_P\", empty, empty],\n    [0, 26, \"KeyQ\", 47, \"Q\", 81, \"VK_Q\", empty, empty],\n    [0, 27, \"KeyR\", 48, \"R\", 82, \"VK_R\", empty, empty],\n    [0, 28, \"KeyS\", 49, \"S\", 83, \"VK_S\", empty, empty],\n    [0, 29, \"KeyT\", 50, \"T\", 84, \"VK_T\", empty, empty],\n    [0, 30, \"KeyU\", 51, \"U\", 85, \"VK_U\", empty, empty],\n    [0, 31, \"KeyV\", 52, \"V\", 86, \"VK_V\", empty, empty],\n    [0, 32, \"KeyW\", 53, \"W\", 87, \"VK_W\", empty, empty],\n    [0, 33, \"KeyX\", 54, \"X\", 88, \"VK_X\", empty, empty],\n    [0, 34, \"KeyY\", 55, \"Y\", 89, \"VK_Y\", empty, empty],\n    [0, 35, \"KeyZ\", 56, \"Z\", 90, \"VK_Z\", empty, empty],\n    [0, 36, \"Digit1\", 22, \"1\", 49, \"VK_1\", empty, empty],\n    [0, 37, \"Digit2\", 23, \"2\", 50, \"VK_2\", empty, empty],\n    [0, 38, \"Digit3\", 24, \"3\", 51, \"VK_3\", empty, empty],\n    [0, 39, \"Digit4\", 25, \"4\", 52, \"VK_4\", empty, empty],\n    [0, 40, \"Digit5\", 26, \"5\", 53, \"VK_5\", empty, empty],\n    [0, 41, \"Digit6\", 27, \"6\", 54, \"VK_6\", empty, empty],\n    [0, 42, \"Digit7\", 28, \"7\", 55, \"VK_7\", empty, empty],\n    [0, 43, \"Digit8\", 29, \"8\", 56, \"VK_8\", empty, empty],\n    [0, 44, \"Digit9\", 30, \"9\", 57, \"VK_9\", empty, empty],\n    [0, 45, \"Digit0\", 21, \"0\", 48, \"VK_0\", empty, empty],\n    [1, 46, \"Enter\", 3, \"Enter\", 13, \"VK_RETURN\", empty, empty],\n    [1, 47, \"Escape\", 9, \"Escape\", 27, \"VK_ESCAPE\", empty, empty],\n    [1, 48, \"Backspace\", 1, \"Backspace\", 8, \"VK_BACK\", empty, empty],\n    [1, 49, \"Tab\", 2, \"Tab\", 9, \"VK_TAB\", empty, empty],\n    [1, 50, \"Space\", 10, \"Space\", 32, \"VK_SPACE\", empty, empty],\n    [0, 51, \"Minus\", 88, \"-\", 189, \"VK_OEM_MINUS\", \"-\", \"OEM_MINUS\"],\n    [0, 52, \"Equal\", 86, \"=\", 187, \"VK_OEM_PLUS\", \"=\", \"OEM_PLUS\"],\n    [0, 53, \"BracketLeft\", 92, \"[\", 219, \"VK_OEM_4\", \"[\", \"OEM_4\"],\n    [0, 54, \"BracketRight\", 94, \"]\", 221, \"VK_OEM_6\", \"]\", \"OEM_6\"],\n    [0, 55, \"Backslash\", 93, \"\\\\\", 220, \"VK_OEM_5\", \"\\\\\", \"OEM_5\"],\n    [0, 56, \"IntlHash\", 0, empty, 0, empty, empty, empty],\n    // has been dropped from the w3c spec\n    [0, 57, \"Semicolon\", 85, \";\", 186, \"VK_OEM_1\", \";\", \"OEM_1\"],\n    [0, 58, \"Quote\", 95, \"'\", 222, \"VK_OEM_7\", \"'\", \"OEM_7\"],\n    [0, 59, \"Backquote\", 91, \"`\", 192, \"VK_OEM_3\", \"`\", \"OEM_3\"],\n    [0, 60, \"Comma\", 87, \",\", 188, \"VK_OEM_COMMA\", \",\", \"OEM_COMMA\"],\n    [0, 61, \"Period\", 89, \".\", 190, \"VK_OEM_PERIOD\", \".\", \"OEM_PERIOD\"],\n    [0, 62, \"Slash\", 90, \"/\", 191, \"VK_OEM_2\", \"/\", \"OEM_2\"],\n    [1, 63, \"CapsLock\", 8, \"CapsLock\", 20, \"VK_CAPITAL\", empty, empty],\n    [1, 64, \"F1\", 59, \"F1\", 112, \"VK_F1\", empty, empty],\n    [1, 65, \"F2\", 60, \"F2\", 113, \"VK_F2\", empty, empty],\n    [1, 66, \"F3\", 61, \"F3\", 114, \"VK_F3\", empty, empty],\n    [1, 67, \"F4\", 62, \"F4\", 115, \"VK_F4\", empty, empty],\n    [1, 68, \"F5\", 63, \"F5\", 116, \"VK_F5\", empty, empty],\n    [1, 69, \"F6\", 64, \"F6\", 117, \"VK_F6\", empty, empty],\n    [1, 70, \"F7\", 65, \"F7\", 118, \"VK_F7\", empty, empty],\n    [1, 71, \"F8\", 66, \"F8\", 119, \"VK_F8\", empty, empty],\n    [1, 72, \"F9\", 67, \"F9\", 120, \"VK_F9\", empty, empty],\n    [1, 73, \"F10\", 68, \"F10\", 121, \"VK_F10\", empty, empty],\n    [1, 74, \"F11\", 69, \"F11\", 122, \"VK_F11\", empty, empty],\n    [1, 75, \"F12\", 70, \"F12\", 123, \"VK_F12\", empty, empty],\n    [1, 76, \"PrintScreen\", 0, empty, 0, empty, empty, empty],\n    [1, 77, \"ScrollLock\", 84, \"ScrollLock\", 145, \"VK_SCROLL\", empty, empty],\n    [1, 78, \"Pause\", 7, \"PauseBreak\", 19, \"VK_PAUSE\", empty, empty],\n    [1, 79, \"Insert\", 19, \"Insert\", 45, \"VK_INSERT\", empty, empty],\n    [1, 80, \"Home\", 14, \"Home\", 36, \"VK_HOME\", empty, empty],\n    [1, 81, \"PageUp\", 11, \"PageUp\", 33, \"VK_PRIOR\", empty, empty],\n    [1, 82, \"Delete\", 20, \"Delete\", 46, \"VK_DELETE\", empty, empty],\n    [1, 83, \"End\", 13, \"End\", 35, \"VK_END\", empty, empty],\n    [1, 84, \"PageDown\", 12, \"PageDown\", 34, \"VK_NEXT\", empty, empty],\n    [1, 85, \"ArrowRight\", 17, \"RightArrow\", 39, \"VK_RIGHT\", \"Right\", empty],\n    [1, 86, \"ArrowLeft\", 15, \"LeftArrow\", 37, \"VK_LEFT\", \"Left\", empty],\n    [1, 87, \"ArrowDown\", 18, \"DownArrow\", 40, \"VK_DOWN\", \"Down\", empty],\n    [1, 88, \"ArrowUp\", 16, \"UpArrow\", 38, \"VK_UP\", \"Up\", empty],\n    [1, 89, \"NumLock\", 83, \"NumLock\", 144, \"VK_NUMLOCK\", empty, empty],\n    [1, 90, \"NumpadDivide\", 113, \"NumPad_Divide\", 111, \"VK_DIVIDE\", empty, empty],\n    [1, 91, \"NumpadMultiply\", 108, \"NumPad_Multiply\", 106, \"VK_MULTIPLY\", empty, empty],\n    [1, 92, \"NumpadSubtract\", 111, \"NumPad_Subtract\", 109, \"VK_SUBTRACT\", empty, empty],\n    [1, 93, \"NumpadAdd\", 109, \"NumPad_Add\", 107, \"VK_ADD\", empty, empty],\n    [1, 94, \"NumpadEnter\", 3, empty, 0, empty, empty, empty],\n    [1, 95, \"Numpad1\", 99, \"NumPad1\", 97, \"VK_NUMPAD1\", empty, empty],\n    [1, 96, \"Numpad2\", 100, \"NumPad2\", 98, \"VK_NUMPAD2\", empty, empty],\n    [1, 97, \"Numpad3\", 101, \"NumPad3\", 99, \"VK_NUMPAD3\", empty, empty],\n    [1, 98, \"Numpad4\", 102, \"NumPad4\", 100, \"VK_NUMPAD4\", empty, empty],\n    [1, 99, \"Numpad5\", 103, \"NumPad5\", 101, \"VK_NUMPAD5\", empty, empty],\n    [1, 100, \"Numpad6\", 104, \"NumPad6\", 102, \"VK_NUMPAD6\", empty, empty],\n    [1, 101, \"Numpad7\", 105, \"NumPad7\", 103, \"VK_NUMPAD7\", empty, empty],\n    [1, 102, \"Numpad8\", 106, \"NumPad8\", 104, \"VK_NUMPAD8\", empty, empty],\n    [1, 103, \"Numpad9\", 107, \"NumPad9\", 105, \"VK_NUMPAD9\", empty, empty],\n    [1, 104, \"Numpad0\", 98, \"NumPad0\", 96, \"VK_NUMPAD0\", empty, empty],\n    [1, 105, \"NumpadDecimal\", 112, \"NumPad_Decimal\", 110, \"VK_DECIMAL\", empty, empty],\n    [0, 106, \"IntlBackslash\", 97, \"OEM_102\", 226, \"VK_OEM_102\", empty, empty],\n    [1, 107, \"ContextMenu\", 58, \"ContextMenu\", 93, empty, empty, empty],\n    [1, 108, \"Power\", 0, empty, 0, empty, empty, empty],\n    [1, 109, \"NumpadEqual\", 0, empty, 0, empty, empty, empty],\n    [1, 110, \"F13\", 71, \"F13\", 124, \"VK_F13\", empty, empty],\n    [1, 111, \"F14\", 72, \"F14\", 125, \"VK_F14\", empty, empty],\n    [1, 112, \"F15\", 73, \"F15\", 126, \"VK_F15\", empty, empty],\n    [1, 113, \"F16\", 74, \"F16\", 127, \"VK_F16\", empty, empty],\n    [1, 114, \"F17\", 75, \"F17\", 128, \"VK_F17\", empty, empty],\n    [1, 115, \"F18\", 76, \"F18\", 129, \"VK_F18\", empty, empty],\n    [1, 116, \"F19\", 77, \"F19\", 130, \"VK_F19\", empty, empty],\n    [1, 117, \"F20\", 78, \"F20\", 131, \"VK_F20\", empty, empty],\n    [1, 118, \"F21\", 79, \"F21\", 132, \"VK_F21\", empty, empty],\n    [1, 119, \"F22\", 80, \"F22\", 133, \"VK_F22\", empty, empty],\n    [1, 120, \"F23\", 81, \"F23\", 134, \"VK_F23\", empty, empty],\n    [1, 121, \"F24\", 82, \"F24\", 135, \"VK_F24\", empty, empty],\n    [1, 122, \"Open\", 0, empty, 0, empty, empty, empty],\n    [1, 123, \"Help\", 0, empty, 0, empty, empty, empty],\n    [1, 124, \"Select\", 0, empty, 0, empty, empty, empty],\n    [1, 125, \"Again\", 0, empty, 0, empty, empty, empty],\n    [1, 126, \"Undo\", 0, empty, 0, empty, empty, empty],\n    [1, 127, \"Cut\", 0, empty, 0, empty, empty, empty],\n    [1, 128, \"Copy\", 0, empty, 0, empty, empty, empty],\n    [1, 129, \"Paste\", 0, empty, 0, empty, empty, empty],\n    [1, 130, \"Find\", 0, empty, 0, empty, empty, empty],\n    [1, 131, \"AudioVolumeMute\", 117, \"AudioVolumeMute\", 173, \"VK_VOLUME_MUTE\", empty, empty],\n    [1, 132, \"AudioVolumeUp\", 118, \"AudioVolumeUp\", 175, \"VK_VOLUME_UP\", empty, empty],\n    [1, 133, \"AudioVolumeDown\", 119, \"AudioVolumeDown\", 174, \"VK_VOLUME_DOWN\", empty, empty],\n    [1, 134, \"NumpadComma\", 110, \"NumPad_Separator\", 108, \"VK_SEPARATOR\", empty, empty],\n    [0, 135, \"IntlRo\", 115, \"ABNT_C1\", 193, \"VK_ABNT_C1\", empty, empty],\n    [1, 136, \"KanaMode\", 0, empty, 0, empty, empty, empty],\n    [0, 137, \"IntlYen\", 0, empty, 0, empty, empty, empty],\n    [1, 138, \"Convert\", 0, empty, 0, empty, empty, empty],\n    [1, 139, \"NonConvert\", 0, empty, 0, empty, empty, empty],\n    [1, 140, \"Lang1\", 0, empty, 0, empty, empty, empty],\n    [1, 141, \"Lang2\", 0, empty, 0, empty, empty, empty],\n    [1, 142, \"Lang3\", 0, empty, 0, empty, empty, empty],\n    [1, 143, \"Lang4\", 0, empty, 0, empty, empty, empty],\n    [1, 144, \"Lang5\", 0, empty, 0, empty, empty, empty],\n    [1, 145, \"Abort\", 0, empty, 0, empty, empty, empty],\n    [1, 146, \"Props\", 0, empty, 0, empty, empty, empty],\n    [1, 147, \"NumpadParenLeft\", 0, empty, 0, empty, empty, empty],\n    [1, 148, \"NumpadParenRight\", 0, empty, 0, empty, empty, empty],\n    [1, 149, \"NumpadBackspace\", 0, empty, 0, empty, empty, empty],\n    [1, 150, \"NumpadMemoryStore\", 0, empty, 0, empty, empty, empty],\n    [1, 151, \"NumpadMemoryRecall\", 0, empty, 0, empty, empty, empty],\n    [1, 152, \"NumpadMemoryClear\", 0, empty, 0, empty, empty, empty],\n    [1, 153, \"NumpadMemoryAdd\", 0, empty, 0, empty, empty, empty],\n    [1, 154, \"NumpadMemorySubtract\", 0, empty, 0, empty, empty, empty],\n    [1, 155, \"NumpadClear\", 131, \"Clear\", 12, \"VK_CLEAR\", empty, empty],\n    [1, 156, \"NumpadClearEntry\", 0, empty, 0, empty, empty, empty],\n    [1, 0, empty, 5, \"Ctrl\", 17, \"VK_CONTROL\", empty, empty],\n    [1, 0, empty, 4, \"Shift\", 16, \"VK_SHIFT\", empty, empty],\n    [1, 0, empty, 6, \"Alt\", 18, \"VK_MENU\", empty, empty],\n    [1, 0, empty, 57, \"Meta\", 91, \"VK_COMMAND\", empty, empty],\n    [1, 157, \"ControlLeft\", 5, empty, 0, \"VK_LCONTROL\", empty, empty],\n    [1, 158, \"ShiftLeft\", 4, empty, 0, \"VK_LSHIFT\", empty, empty],\n    [1, 159, \"AltLeft\", 6, empty, 0, \"VK_LMENU\", empty, empty],\n    [1, 160, \"MetaLeft\", 57, empty, 0, \"VK_LWIN\", empty, empty],\n    [1, 161, \"ControlRight\", 5, empty, 0, \"VK_RCONTROL\", empty, empty],\n    [1, 162, \"ShiftRight\", 4, empty, 0, \"VK_RSHIFT\", empty, empty],\n    [1, 163, \"AltRight\", 6, empty, 0, \"VK_RMENU\", empty, empty],\n    [1, 164, \"MetaRight\", 57, empty, 0, \"VK_RWIN\", empty, empty],\n    [1, 165, \"BrightnessUp\", 0, empty, 0, empty, empty, empty],\n    [1, 166, \"BrightnessDown\", 0, empty, 0, empty, empty, empty],\n    [1, 167, \"MediaPlay\", 0, empty, 0, empty, empty, empty],\n    [1, 168, \"MediaRecord\", 0, empty, 0, empty, empty, empty],\n    [1, 169, \"MediaFastForward\", 0, empty, 0, empty, empty, empty],\n    [1, 170, \"MediaRewind\", 0, empty, 0, empty, empty, empty],\n    [1, 171, \"MediaTrackNext\", 124, \"MediaTrackNext\", 176, \"VK_MEDIA_NEXT_TRACK\", empty, empty],\n    [1, 172, \"MediaTrackPrevious\", 125, \"MediaTrackPrevious\", 177, \"VK_MEDIA_PREV_TRACK\", empty, empty],\n    [1, 173, \"MediaStop\", 126, \"MediaStop\", 178, \"VK_MEDIA_STOP\", empty, empty],\n    [1, 174, \"Eject\", 0, empty, 0, empty, empty, empty],\n    [1, 175, \"MediaPlayPause\", 127, \"MediaPlayPause\", 179, \"VK_MEDIA_PLAY_PAUSE\", empty, empty],\n    [1, 176, \"MediaSelect\", 128, \"LaunchMediaPlayer\", 181, \"VK_MEDIA_LAUNCH_MEDIA_SELECT\", empty, empty],\n    [1, 177, \"LaunchMail\", 129, \"LaunchMail\", 180, \"VK_MEDIA_LAUNCH_MAIL\", empty, empty],\n    [1, 178, \"LaunchApp2\", 130, \"LaunchApp2\", 183, \"VK_MEDIA_LAUNCH_APP2\", empty, empty],\n    [1, 179, \"LaunchApp1\", 0, empty, 0, \"VK_MEDIA_LAUNCH_APP1\", empty, empty],\n    [1, 180, \"SelectTask\", 0, empty, 0, empty, empty, empty],\n    [1, 181, \"LaunchScreenSaver\", 0, empty, 0, empty, empty, empty],\n    [1, 182, \"BrowserSearch\", 120, \"BrowserSearch\", 170, \"VK_BROWSER_SEARCH\", empty, empty],\n    [1, 183, \"BrowserHome\", 121, \"BrowserHome\", 172, \"VK_BROWSER_HOME\", empty, empty],\n    [1, 184, \"BrowserBack\", 122, \"BrowserBack\", 166, \"VK_BROWSER_BACK\", empty, empty],\n    [1, 185, \"BrowserForward\", 123, \"BrowserForward\", 167, \"VK_BROWSER_FORWARD\", empty, empty],\n    [1, 186, \"BrowserStop\", 0, empty, 0, \"VK_BROWSER_STOP\", empty, empty],\n    [1, 187, \"BrowserRefresh\", 0, empty, 0, \"VK_BROWSER_REFRESH\", empty, empty],\n    [1, 188, \"BrowserFavorites\", 0, empty, 0, \"VK_BROWSER_FAVORITES\", empty, empty],\n    [1, 189, \"ZoomToggle\", 0, empty, 0, empty, empty, empty],\n    [1, 190, \"MailReply\", 0, empty, 0, empty, empty, empty],\n    [1, 191, \"MailForward\", 0, empty, 0, empty, empty, empty],\n    [1, 192, \"MailSend\", 0, empty, 0, empty, empty, empty],\n    // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n    // If an Input Method Editor is processing key input and the event is keydown, return 229.\n    [1, 0, empty, 114, \"KeyInComposition\", 229, empty, empty, empty],\n    [1, 0, empty, 116, \"ABNT_C2\", 194, \"VK_ABNT_C2\", empty, empty],\n    [1, 0, empty, 96, \"OEM_8\", 223, \"VK_OEM_8\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_KANA\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_HANGUL\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_JUNJA\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_FINAL\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_HANJA\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_KANJI\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_CONVERT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_NONCONVERT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_ACCEPT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_MODECHANGE\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_SELECT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_PRINT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_EXECUTE\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_SNAPSHOT\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_HELP\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_APPS\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_PROCESSKEY\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_PACKET\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_DBE_SBCSCHAR\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_DBE_DBCSCHAR\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_ATTN\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_CRSEL\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_EXSEL\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_EREOF\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_PLAY\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_ZOOM\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_NONAME\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_PA1\", empty, empty],\n    [1, 0, empty, 0, empty, 0, \"VK_OEM_CLEAR\", empty, empty]\n  ];\n  const seenKeyCode = [];\n  const seenScanCode = [];\n  for (const mapping of mappings) {\n    const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;\n    if (!seenScanCode[scanCode]) {\n      seenScanCode[scanCode] = true;\n      scanCodeIntToStr[scanCode] = scanCodeStr;\n      scanCodeStrToInt[scanCodeStr] = scanCode;\n      scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;\n      if (immutable) {\n        IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;\n        if (keyCode !== 0 \u0026\u0026 keyCode !== 3 \u0026\u0026 keyCode !== 5 \u0026\u0026 keyCode !== 4 \u0026\u0026 keyCode !== 6 \u0026\u0026 keyCode !== 57) {\n          IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;\n        }\n      }\n    }\n    if (!seenKeyCode[keyCode]) {\n      seenKeyCode[keyCode] = true;\n      if (!keyCodeStr) {\n        throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);\n      }\n      uiMap.define(keyCode, keyCodeStr);\n      userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);\n      userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);\n    }\n    if (eventKeyCode) {\n      EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;\n    }\n    if (vkey) {\n      NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;\n    }\n  }\n  IMMUTABLE_KEY_CODE_TO_CODE[\n    3\n    /* KeyCode.Enter */\n  ] = 46;\n})();\nvar KeyCodeUtils;\n(function(KeyCodeUtils2) {\n  function toString(keyCode) {\n    return uiMap.keyCodeToStr(keyCode);\n  }\n  KeyCodeUtils2.toString = toString;\n  function fromString(key) {\n    return uiMap.strToKeyCode(key);\n  }\n  KeyCodeUtils2.fromString = fromString;\n  function toUserSettingsUS(keyCode) {\n    return userSettingsUSMap.keyCodeToStr(keyCode);\n  }\n  KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;\n  function toUserSettingsGeneral(keyCode) {\n    return userSettingsGeneralMap.keyCodeToStr(keyCode);\n  }\n  KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;\n  function fromUserSettings(key) {\n    return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\n  }\n  KeyCodeUtils2.fromUserSettings = fromUserSettings;\n  function toElectronAccelerator(keyCode) {\n    if (keyCode \u003e= 98 \u0026\u0026 keyCode \u003c= 113) {\n      return null;\n    }\n    switch (keyCode) {\n      case 16:\n        return \"Up\";\n      case 18:\n        return \"Down\";\n      case 15:\n        return \"Left\";\n      case 17:\n        return \"Right\";\n    }\n    return uiMap.keyCodeToStr(keyCode);\n  }\n  KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;\n})(KeyCodeUtils || (KeyCodeUtils = {}));\nfunction KeyChord(firstPart, secondPart) {\n  const chordPart = (secondPart \u0026 65535) \u003c\u003c 16 \u003e\u003e\u003e 0;\n  return (firstPart | chordPart) \u003e\u003e\u003e 0;\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js\nvar Selection = class _Selection extends Range {\n  constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n    super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n    this.selectionStartLineNumber = selectionStartLineNumber;\n    this.selectionStartColumn = selectionStartColumn;\n    this.positionLineNumber = positionLineNumber;\n    this.positionColumn = positionColumn;\n  }\n  /**\n   * Transform to a human-readable representation.\n   */\n  toString() {\n    return \"[\" + this.selectionStartLineNumber + \",\" + this.selectionStartColumn + \" -\u003e \" + this.positionLineNumber + \",\" + this.positionColumn + \"]\";\n  }\n  /**\n   * Test if equals other selection.\n   */\n  equalsSelection(other) {\n    return _Selection.selectionsEqual(this, other);\n  }\n  /**\n   * Test if the two selections are equal.\n   */\n  static selectionsEqual(a2, b) {\n    return a2.selectionStartLineNumber === b.selectionStartLineNumber \u0026\u0026 a2.selectionStartColumn === b.selectionStartColumn \u0026\u0026 a2.positionLineNumber === b.positionLineNumber \u0026\u0026 a2.positionColumn === b.positionColumn;\n  }\n  /**\n   * Get directions (LTR or RTL).\n   */\n  getDirection() {\n    if (this.selectionStartLineNumber === this.startLineNumber \u0026\u0026 this.selectionStartColumn === this.startColumn) {\n      return 0;\n    }\n    return 1;\n  }\n  /**\n   * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n   */\n  setEndPosition(endLineNumber, endColumn) {\n    if (this.getDirection() === 0) {\n      return new _Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    return new _Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n  }\n  /**\n   * Get the position at `positionLineNumber` and `positionColumn`.\n   */\n  getPosition() {\n    return new Position(this.positionLineNumber, this.positionColumn);\n  }\n  /**\n   * Get the position at the start of the selection.\n  */\n  getSelectionStart() {\n    return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n  }\n  /**\n   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n   */\n  setStartPosition(startLineNumber, startColumn) {\n    if (this.getDirection() === 0) {\n      return new _Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    return new _Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n  }\n  // ----\n  /**\n   * Create a `Selection` from one or two positions\n   */\n  static fromPositions(start, end = start) {\n    return new _Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n  /**\n   * Creates a `Selection` from a range, given a direction.\n   */\n  static fromRange(range, direction) {\n    if (direction === 0) {\n      return new _Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    } else {\n      return new _Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n    }\n  }\n  /**\n   * Create a `Selection` from an `ISelection`.\n   */\n  static liftSelection(sel) {\n    return new _Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n  }\n  /**\n   * `a` equals `b`.\n   */\n  static selectionsArrEqual(a2, b) {\n    if (a2 \u0026\u0026 !b || !a2 \u0026\u0026 b) {\n      return false;\n    }\n    if (!a2 \u0026\u0026 !b) {\n      return true;\n    }\n    if (a2.length !== b.length) {\n      return false;\n    }\n    for (let i = 0, len = a2.length; i \u003c len; i++) {\n      if (!this.selectionsEqual(a2[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Test if `obj` is an `ISelection`.\n   */\n  static isISelection(obj) {\n    return obj \u0026\u0026 typeof obj.selectionStartLineNumber === \"number\" \u0026\u0026 typeof obj.selectionStartColumn === \"number\" \u0026\u0026 typeof obj.positionLineNumber === \"number\" \u0026\u0026 typeof obj.positionColumn === \"number\";\n  }\n  /**\n   * Create with a direction.\n   */\n  static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n    if (direction === 0) {\n      return new _Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    return new _Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js\nvar _codiconFontCharacters = /* @__PURE__ */ Object.create(null);\nfunction register(id, fontCharacter) {\n  if (isString(fontCharacter)) {\n    const val = _codiconFontCharacters[fontCharacter];\n    if (val === void 0) {\n      throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);\n    }\n    fontCharacter = val;\n  }\n  _codiconFontCharacters[id] = fontCharacter;\n  return { id };\n}\nvar Codicon = {\n  // built-in icons, with image name\n  add: register(\"add\", 6e4),\n  plus: register(\"plus\", 6e4),\n  gistNew: register(\"gist-new\", 6e4),\n  repoCreate: register(\"repo-create\", 6e4),\n  lightbulb: register(\"lightbulb\", 60001),\n  lightBulb: register(\"light-bulb\", 60001),\n  repo: register(\"repo\", 60002),\n  repoDelete: register(\"repo-delete\", 60002),\n  gistFork: register(\"gist-fork\", 60003),\n  repoForked: register(\"repo-forked\", 60003),\n  gitPullRequest: register(\"git-pull-request\", 60004),\n  gitPullRequestAbandoned: register(\"git-pull-request-abandoned\", 60004),\n  recordKeys: register(\"record-keys\", 60005),\n  keyboard: register(\"keyboard\", 60005),\n  tag: register(\"tag\", 60006),\n  tagAdd: register(\"tag-add\", 60006),\n  tagRemove: register(\"tag-remove\", 60006),\n  gitPullRequestLabel: register(\"git-pull-request-label\", 60006),\n  person: register(\"person\", 60007),\n  personFollow: register(\"person-follow\", 60007),\n  personOutline: register(\"person-outline\", 60007),\n  personFilled: register(\"person-filled\", 60007),\n  gitBranch: register(\"git-branch\", 60008),\n  gitBranchCreate: register(\"git-branch-create\", 60008),\n  gitBranchDelete: register(\"git-branch-delete\", 60008),\n  sourceControl: register(\"source-control\", 60008),\n  mirror: register(\"mirror\", 60009),\n  mirrorPublic: register(\"mirror-public\", 60009),\n  star: register(\"star\", 60010),\n  starAdd: register(\"star-add\", 60010),\n  starDelete: register(\"star-delete\", 60010),\n  starEmpty: register(\"star-empty\", 60010),\n  comment: register(\"comment\", 60011),\n  commentAdd: register(\"comment-add\", 60011),\n  alert: register(\"alert\", 60012),\n  warning: register(\"warning\", 60012),\n  search: register(\"search\", 60013),\n  searchSave: register(\"search-save\", 60013),\n  logOut: register(\"log-out\", 60014),\n  signOut: register(\"sign-out\", 60014),\n  logIn: register(\"log-in\", 60015),\n  signIn: register(\"sign-in\", 60015),\n  eye: register(\"eye\", 60016),\n  eyeUnwatch: register(\"eye-unwatch\", 60016),\n  eyeWatch: register(\"eye-watch\", 60016),\n  circleFilled: register(\"circle-filled\", 60017),\n  primitiveDot: register(\"primitive-dot\", 60017),\n  closeDirty: register(\"close-dirty\", 60017),\n  debugBreakpoint: register(\"debug-breakpoint\", 60017),\n  debugBreakpointDisabled: register(\"debug-breakpoint-disabled\", 60017),\n  debugHint: register(\"debug-hint\", 60017),\n  primitiveSquare: register(\"primitive-square\", 60018),\n  edit: register(\"edit\", 60019),\n  pencil: register(\"pencil\", 60019),\n  info: register(\"info\", 60020),\n  issueOpened: register(\"issue-opened\", 60020),\n  gistPrivate: register(\"gist-private\", 60021),\n  gitForkPrivate: register(\"git-fork-private\", 60021),\n  lock: register(\"lock\", 60021),\n  mirrorPrivate: register(\"mirror-private\", 60021),\n  close: register(\"close\", 60022),\n  removeClose: register(\"remove-close\", 60022),\n  x: register(\"x\", 60022),\n  repoSync: register(\"repo-sync\", 60023),\n  sync: register(\"sync\", 60023),\n  clone: register(\"clone\", 60024),\n  desktopDownload: register(\"desktop-download\", 60024),\n  beaker: register(\"beaker\", 60025),\n  microscope: register(\"microscope\", 60025),\n  vm: register(\"vm\", 60026),\n  deviceDesktop: register(\"device-desktop\", 60026),\n  file: register(\"file\", 60027),\n  fileText: register(\"file-text\", 60027),\n  more: register(\"more\", 60028),\n  ellipsis: register(\"ellipsis\", 60028),\n  kebabHorizontal: register(\"kebab-horizontal\", 60028),\n  mailReply: register(\"mail-reply\", 60029),\n  reply: register(\"reply\", 60029),\n  organization: register(\"organization\", 60030),\n  organizationFilled: register(\"organization-filled\", 60030),\n  organizationOutline: register(\"organization-outline\", 60030),\n  newFile: register(\"new-file\", 60031),\n  fileAdd: register(\"file-add\", 60031),\n  newFolder: register(\"new-folder\", 60032),\n  fileDirectoryCreate: register(\"file-directory-create\", 60032),\n  trash: register(\"trash\", 60033),\n  trashcan: register(\"trashcan\", 60033),\n  history: register(\"history\", 60034),\n  clock: register(\"clock\", 60034),\n  folder: register(\"folder\", 60035),\n  fileDirectory: register(\"file-directory\", 60035),\n  symbolFolder: register(\"symbol-folder\", 60035),\n  logoGithub: register(\"logo-github\", 60036),\n  markGithub: register(\"mark-github\", 60036),\n  github: register(\"github\", 60036),\n  terminal: register(\"terminal\", 60037),\n  console: register(\"console\", 60037),\n  repl: register(\"repl\", 60037),\n  zap: register(\"zap\", 60038),\n  symbolEvent: register(\"symbol-event\", 60038),\n  error: register(\"error\", 60039),\n  stop: register(\"stop\", 60039),\n  variable: register(\"variable\", 60040),\n  symbolVariable: register(\"symbol-variable\", 60040),\n  array: register(\"array\", 60042),\n  symbolArray: register(\"symbol-array\", 60042),\n  symbolModule: register(\"symbol-module\", 60043),\n  symbolPackage: register(\"symbol-package\", 60043),\n  symbolNamespace: register(\"symbol-namespace\", 60043),\n  symbolObject: register(\"symbol-object\", 60043),\n  symbolMethod: register(\"symbol-method\", 60044),\n  symbolFunction: register(\"symbol-function\", 60044),\n  symbolConstructor: register(\"symbol-constructor\", 60044),\n  symbolBoolean: register(\"symbol-boolean\", 60047),\n  symbolNull: register(\"symbol-null\", 60047),\n  symbolNumeric: register(\"symbol-numeric\", 60048),\n  symbolNumber: register(\"symbol-number\", 60048),\n  symbolStructure: register(\"symbol-structure\", 60049),\n  symbolStruct: register(\"symbol-struct\", 60049),\n  symbolParameter: register(\"symbol-parameter\", 60050),\n  symbolTypeParameter: register(\"symbol-type-parameter\", 60050),\n  symbolKey: register(\"symbol-key\", 60051),\n  symbolText: register(\"symbol-text\", 60051),\n  symbolReference: register(\"symbol-reference\", 60052),\n  goToFile: register(\"go-to-file\", 60052),\n  symbolEnum: register(\"symbol-enum\", 60053),\n  symbolValue: register(\"symbol-value\", 60053),\n  symbolRuler: register(\"symbol-ruler\", 60054),\n  symbolUnit: register(\"symbol-unit\", 60054),\n  activateBreakpoints: register(\"activate-breakpoints\", 60055),\n  archive: register(\"archive\", 60056),\n  arrowBoth: register(\"arrow-both\", 60057),\n  arrowDown: register(\"arrow-down\", 60058),\n  arrowLeft: register(\"arrow-left\", 60059),\n  arrowRight: register(\"arrow-right\", 60060),\n  arrowSmallDown: register(\"arrow-small-down\", 60061),\n  arrowSmallLeft: register(\"arrow-small-left\", 60062),\n  arrowSmallRight: register(\"arrow-small-right\", 60063),\n  arrowSmallUp: register(\"arrow-small-up\", 60064),\n  arrowUp: register(\"arrow-up\", 60065),\n  bell: register(\"bell\", 60066),\n  bold: register(\"bold\", 60067),\n  book: register(\"book\", 60068),\n  bookmark: register(\"bookmark\", 60069),\n  debugBreakpointConditionalUnverified: register(\"debug-breakpoint-conditional-unverified\", 60070),\n  debugBreakpointConditional: register(\"debug-breakpoint-conditional\", 60071),\n  debugBreakpointConditionalDisabled: register(\"debug-breakpoint-conditional-disabled\", 60071),\n  debugBreakpointDataUnverified: register(\"debug-breakpoint-data-unverified\", 60072),\n  debugBreakpointData: register(\"debug-breakpoint-data\", 60073),\n  debugBreakpointDataDisabled: register(\"debug-breakpoint-data-disabled\", 60073),\n  debugBreakpointLogUnverified: register(\"debug-breakpoint-log-unverified\", 60074),\n  debugBreakpointLog: register(\"debug-breakpoint-log\", 60075),\n  debugBreakpointLogDisabled: register(\"debug-breakpoint-log-disabled\", 60075),\n  briefcase: register(\"briefcase\", 60076),\n  broadcast: register(\"broadcast\", 60077),\n  browser: register(\"browser\", 60078),\n  bug: register(\"bug\", 60079),\n  calendar: register(\"calendar\", 60080),\n  caseSensitive: register(\"case-sensitive\", 60081),\n  check: register(\"check\", 60082),\n  checklist: register(\"checklist\", 60083),\n  chevronDown: register(\"chevron-down\", 60084),\n  dropDownButton: register(\"drop-down-button\", 60084),\n  chevronLeft: register(\"chevron-left\", 60085),\n  chevronRight: register(\"chevron-right\", 60086),\n  chevronUp: register(\"chevron-up\", 60087),\n  chromeClose: register(\"chrome-close\", 60088),\n  chromeMaximize: register(\"chrome-maximize\", 60089),\n  chromeMinimize: register(\"chrome-minimize\", 60090),\n  chromeRestore: register(\"chrome-restore\", 60091),\n  circle: register(\"circle\", 60092),\n  circleOutline: register(\"circle-outline\", 60092),\n  debugBreakpointUnverified: register(\"debug-breakpoint-unverified\", 60092),\n  circleSlash: register(\"circle-slash\", 60093),\n  circuitBoard: register(\"circuit-board\", 60094),\n  clearAll: register(\"clear-all\", 60095),\n  clippy: register(\"clippy\", 60096),\n  closeAll: register(\"close-all\", 60097),\n  cloudDownload: register(\"cloud-download\", 60098),\n  cloudUpload: register(\"cloud-upload\", 60099),\n  code: register(\"code\", 60100),\n  collapseAll: register(\"collapse-all\", 60101),\n  colorMode: register(\"color-mode\", 60102),\n  commentDiscussion: register(\"comment-discussion\", 60103),\n  compareChanges: register(\"compare-changes\", 60157),\n  creditCard: register(\"credit-card\", 60105),\n  dash: register(\"dash\", 60108),\n  dashboard: register(\"dashboard\", 60109),\n  database: register(\"database\", 60110),\n  debugContinue: register(\"debug-continue\", 60111),\n  debugDisconnect: register(\"debug-disconnect\", 60112),\n  debugPause: register(\"debug-pause\", 60113),\n  debugRestart: register(\"debug-restart\", 60114),\n  debugStart: register(\"debug-start\", 60115),\n  debugStepInto: register(\"debug-step-into\", 60116),\n  debugStepOut: register(\"debug-step-out\", 60117),\n  debugStepOver: register(\"debug-step-over\", 60118),\n  debugStop: register(\"debug-stop\", 60119),\n  debug: register(\"debug\", 60120),\n  deviceCameraVideo: register(\"device-camera-video\", 60121),\n  deviceCamera: register(\"device-camera\", 60122),\n  deviceMobile: register(\"device-mobile\", 60123),\n  diffAdded: register(\"diff-added\", 60124),\n  diffIgnored: register(\"diff-ignored\", 60125),\n  diffModified: register(\"diff-modified\", 60126),\n  diffRemoved: register(\"diff-removed\", 60127),\n  diffRenamed: register(\"diff-renamed\", 60128),\n  diff: register(\"diff\", 60129),\n  discard: register(\"discard\", 60130),\n  editorLayout: register(\"editor-layout\", 60131),\n  emptyWindow: register(\"empty-window\", 60132),\n  exclude: register(\"exclude\", 60133),\n  extensions: register(\"extensions\", 60134),\n  eyeClosed: register(\"eye-closed\", 60135),\n  fileBinary: register(\"file-binary\", 60136),\n  fileCode: register(\"file-code\", 60137),\n  fileMedia: register(\"file-media\", 60138),\n  filePdf: register(\"file-pdf\", 60139),\n  fileSubmodule: register(\"file-submodule\", 60140),\n  fileSymlinkDirectory: register(\"file-symlink-directory\", 60141),\n  fileSymlinkFile: register(\"file-symlink-file\", 60142),\n  fileZip: register(\"file-zip\", 60143),\n  files: register(\"files\", 60144),\n  filter: register(\"filter\", 60145),\n  flame: register(\"flame\", 60146),\n  foldDown: register(\"fold-down\", 60147),\n  foldUp: register(\"fold-up\", 60148),\n  fold: register(\"fold\", 60149),\n  folderActive: register(\"folder-active\", 60150),\n  folderOpened: register(\"folder-opened\", 60151),\n  gear: register(\"gear\", 60152),\n  gift: register(\"gift\", 60153),\n  gistSecret: register(\"gist-secret\", 60154),\n  gist: register(\"gist\", 60155),\n  gitCommit: register(\"git-commit\", 60156),\n  gitCompare: register(\"git-compare\", 60157),\n  gitMerge: register(\"git-merge\", 60158),\n  githubAction: register(\"github-action\", 60159),\n  githubAlt: register(\"github-alt\", 60160),\n  globe: register(\"globe\", 60161),\n  grabber: register(\"grabber\", 60162),\n  graph: register(\"graph\", 60163),\n  gripper: register(\"gripper\", 60164),\n  heart: register(\"heart\", 60165),\n  home: register(\"home\", 60166),\n  horizontalRule: register(\"horizontal-rule\", 60167),\n  hubot: register(\"hubot\", 60168),\n  inbox: register(\"inbox\", 60169),\n  issueClosed: register(\"issue-closed\", 60324),\n  issueReopened: register(\"issue-reopened\", 60171),\n  issues: register(\"issues\", 60172),\n  italic: register(\"italic\", 60173),\n  jersey: register(\"jersey\", 60174),\n  json: register(\"json\", 60175),\n  bracket: register(\"bracket\", 60175),\n  kebabVertical: register(\"kebab-vertical\", 60176),\n  key: register(\"key\", 60177),\n  law: register(\"law\", 60178),\n  lightbulbAutofix: register(\"lightbulb-autofix\", 60179),\n  linkExternal: register(\"link-external\", 60180),\n  link: register(\"link\", 60181),\n  listOrdered: register(\"list-ordered\", 60182),\n  listUnordered: register(\"list-unordered\", 60183),\n  liveShare: register(\"live-share\", 60184),\n  loading: register(\"loading\", 60185),\n  location: register(\"location\", 60186),\n  mailRead: register(\"mail-read\", 60187),\n  mail: register(\"mail\", 60188),\n  markdown: register(\"markdown\", 60189),\n  megaphone: register(\"megaphone\", 60190),\n  mention: register(\"mention\", 60191),\n  milestone: register(\"milestone\", 60192),\n  gitPullRequestMilestone: register(\"git-pull-request-milestone\", 60192),\n  mortarBoard: register(\"mortar-board\", 60193),\n  move: register(\"move\", 60194),\n  multipleWindows: register(\"multiple-windows\", 60195),\n  mute: register(\"mute\", 60196),\n  noNewline: register(\"no-newline\", 60197),\n  note: register(\"note\", 60198),\n  octoface: register(\"octoface\", 60199),\n  openPreview: register(\"open-preview\", 60200),\n  package: register(\"package\", 60201),\n  paintcan: register(\"paintcan\", 60202),\n  pin: register(\"pin\", 60203),\n  play: register(\"play\", 60204),\n  run: register(\"run\", 60204),\n  plug: register(\"plug\", 60205),\n  preserveCase: register(\"preserve-case\", 60206),\n  preview: register(\"preview\", 60207),\n  project: register(\"project\", 60208),\n  pulse: register(\"pulse\", 60209),\n  question: register(\"question\", 60210),\n  quote: register(\"quote\", 60211),\n  radioTower: register(\"radio-tower\", 60212),\n  reactions: register(\"reactions\", 60213),\n  references: register(\"references\", 60214),\n  refresh: register(\"refresh\", 60215),\n  regex: register(\"regex\", 60216),\n  remoteExplorer: register(\"remote-explorer\", 60217),\n  remote: register(\"remote\", 60218),\n  remove: register(\"remove\", 60219),\n  replaceAll: register(\"replace-all\", 60220),\n  replace: register(\"replace\", 60221),\n  repoClone: register(\"repo-clone\", 60222),\n  repoForcePush: register(\"repo-force-push\", 60223),\n  repoPull: register(\"repo-pull\", 60224),\n  repoPush: register(\"repo-push\", 60225),\n  report: register(\"report\", 60226),\n  requestChanges: register(\"request-changes\", 60227),\n  rocket: register(\"rocket\", 60228),\n  rootFolderOpened: register(\"root-folder-opened\", 60229),\n  rootFolder: register(\"root-folder\", 60230),\n  rss: register(\"rss\", 60231),\n  ruby: register(\"ruby\", 60232),\n  saveAll: register(\"save-all\", 60233),\n  saveAs: register(\"save-as\", 60234),\n  save: register(\"save\", 60235),\n  screenFull: register(\"screen-full\", 60236),\n  screenNormal: register(\"screen-normal\", 60237),\n  searchStop: register(\"search-stop\", 60238),\n  server: register(\"server\", 60240),\n  settingsGear: register(\"settings-gear\", 60241),\n  settings: register(\"settings\", 60242),\n  shield: register(\"shield\", 60243),\n  smiley: register(\"smiley\", 60244),\n  sortPrecedence: register(\"sort-precedence\", 60245),\n  splitHorizontal: register(\"split-horizontal\", 60246),\n  splitVertical: register(\"split-vertical\", 60247),\n  squirrel: register(\"squirrel\", 60248),\n  starFull: register(\"star-full\", 60249),\n  starHalf: register(\"star-half\", 60250),\n  symbolClass: register(\"symbol-class\", 60251),\n  symbolColor: register(\"symbol-color\", 60252),\n  symbolCustomColor: register(\"symbol-customcolor\", 60252),\n  symbolConstant: register(\"symbol-constant\", 60253),\n  symbolEnumMember: register(\"symbol-enum-member\", 60254),\n  symbolField: register(\"symbol-field\", 60255),\n  symbolFile: register(\"symbol-file\", 60256),\n  symbolInterface: register(\"symbol-interface\", 60257),\n  symbolKeyword: register(\"symbol-keyword\", 60258),\n  symbolMisc: register(\"symbol-misc\", 60259),\n  symbolOperator: register(\"symbol-operator\", 60260),\n  symbolProperty: register(\"symbol-property\", 60261),\n  wrench: register(\"wrench\", 60261),\n  wrenchSubaction: register(\"wrench-subaction\", 60261),\n  symbolSnippet: register(\"symbol-snippet\", 60262),\n  tasklist: register(\"tasklist\", 60263),\n  telescope: register(\"telescope\", 60264),\n  textSize: register(\"text-size\", 60265),\n  threeBars: register(\"three-bars\", 60266),\n  thumbsdown: register(\"thumbsdown\", 60267),\n  thumbsup: register(\"thumbsup\", 60268),\n  tools: register(\"tools\", 60269),\n  triangleDown: register(\"triangle-down\", 60270),\n  triangleLeft: register(\"triangle-left\", 60271),\n  triangleRight: register(\"triangle-right\", 60272),\n  triangleUp: register(\"triangle-up\", 60273),\n  twitter: register(\"twitter\", 60274),\n  unfold: register(\"unfold\", 60275),\n  unlock: register(\"unlock\", 60276),\n  unmute: register(\"unmute\", 60277),\n  unverified: register(\"unverified\", 60278),\n  verified: register(\"verified\", 60279),\n  versions: register(\"versions\", 60280),\n  vmActive: register(\"vm-active\", 60281),\n  vmOutline: register(\"vm-outline\", 60282),\n  vmRunning: register(\"vm-running\", 60283),\n  watch: register(\"watch\", 60284),\n  whitespace: register(\"whitespace\", 60285),\n  wholeWord: register(\"whole-word\", 60286),\n  window: register(\"window\", 60287),\n  wordWrap: register(\"word-wrap\", 60288),\n  zoomIn: register(\"zoom-in\", 60289),\n  zoomOut: register(\"zoom-out\", 60290),\n  listFilter: register(\"list-filter\", 60291),\n  listFlat: register(\"list-flat\", 60292),\n  listSelection: register(\"list-selection\", 60293),\n  selection: register(\"selection\", 60293),\n  listTree: register(\"list-tree\", 60294),\n  debugBreakpointFunctionUnverified: register(\"debug-breakpoint-function-unverified\", 60295),\n  debugBreakpointFunction: register(\"debug-breakpoint-function\", 60296),\n  debugBreakpointFunctionDisabled: register(\"debug-breakpoint-function-disabled\", 60296),\n  debugStackframeActive: register(\"debug-stackframe-active\", 60297),\n  circleSmallFilled: register(\"circle-small-filled\", 60298),\n  debugStackframeDot: register(\"debug-stackframe-dot\", 60298),\n  debugStackframe: register(\"debug-stackframe\", 60299),\n  debugStackframeFocused: register(\"debug-stackframe-focused\", 60299),\n  debugBreakpointUnsupported: register(\"debug-breakpoint-unsupported\", 60300),\n  symbolString: register(\"symbol-string\", 60301),\n  debugReverseContinue: register(\"debug-reverse-continue\", 60302),\n  debugStepBack: register(\"debug-step-back\", 60303),\n  debugRestartFrame: register(\"debug-restart-frame\", 60304),\n  callIncoming: register(\"call-incoming\", 60306),\n  callOutgoing: register(\"call-outgoing\", 60307),\n  menu: register(\"menu\", 60308),\n  expandAll: register(\"expand-all\", 60309),\n  feedback: register(\"feedback\", 60310),\n  gitPullRequestReviewer: register(\"git-pull-request-reviewer\", 60310),\n  groupByRefType: register(\"group-by-ref-type\", 60311),\n  ungroupByRefType: register(\"ungroup-by-ref-type\", 60312),\n  account: register(\"account\", 60313),\n  gitPullRequestAssignee: register(\"git-pull-request-assignee\", 60313),\n  bellDot: register(\"bell-dot\", 60314),\n  debugConsole: register(\"debug-console\", 60315),\n  library: register(\"library\", 60316),\n  output: register(\"output\", 60317),\n  runAll: register(\"run-all\", 60318),\n  syncIgnored: register(\"sync-ignored\", 60319),\n  pinned: register(\"pinned\", 60320),\n  githubInverted: register(\"github-inverted\", 60321),\n  debugAlt: register(\"debug-alt\", 60305),\n  serverProcess: register(\"server-process\", 60322),\n  serverEnvironment: register(\"server-environment\", 60323),\n  pass: register(\"pass\", 60324),\n  stopCircle: register(\"stop-circle\", 60325),\n  playCircle: register(\"play-circle\", 60326),\n  record: register(\"record\", 60327),\n  debugAltSmall: register(\"debug-alt-small\", 60328),\n  vmConnect: register(\"vm-connect\", 60329),\n  cloud: register(\"cloud\", 60330),\n  merge: register(\"merge\", 60331),\n  exportIcon: register(\"export\", 60332),\n  graphLeft: register(\"graph-left\", 60333),\n  magnet: register(\"magnet\", 60334),\n  notebook: register(\"notebook\", 60335),\n  redo: register(\"redo\", 60336),\n  checkAll: register(\"check-all\", 60337),\n  pinnedDirty: register(\"pinned-dirty\", 60338),\n  passFilled: register(\"pass-filled\", 60339),\n  circleLargeFilled: register(\"circle-large-filled\", 60340),\n  circleLarge: register(\"circle-large\", 60341),\n  circleLargeOutline: register(\"circle-large-outline\", 60341),\n  combine: register(\"combine\", 60342),\n  gather: register(\"gather\", 60342),\n  table: register(\"table\", 60343),\n  variableGroup: register(\"variable-group\", 60344),\n  typeHierarchy: register(\"type-hierarchy\", 60345),\n  typeHierarchySub: register(\"type-hierarchy-sub\", 60346),\n  typeHierarchySuper: register(\"type-hierarchy-super\", 60347),\n  gitPullRequestCreate: register(\"git-pull-request-create\", 60348),\n  runAbove: register(\"run-above\", 60349),\n  runBelow: register(\"run-below\", 60350),\n  notebookTemplate: register(\"notebook-template\", 60351),\n  debugRerun: register(\"debug-rerun\", 60352),\n  workspaceTrusted: register(\"workspace-trusted\", 60353),\n  workspaceUntrusted: register(\"workspace-untrusted\", 60354),\n  workspaceUnspecified: register(\"workspace-unspecified\", 60355),\n  terminalCmd: register(\"terminal-cmd\", 60356),\n  terminalDebian: register(\"terminal-debian\", 60357),\n  terminalLinux: register(\"terminal-linux\", 60358),\n  terminalPowershell: register(\"terminal-powershell\", 60359),\n  terminalTmux: register(\"terminal-tmux\", 60360),\n  terminalUbuntu: register(\"terminal-ubuntu\", 60361),\n  terminalBash: register(\"terminal-bash\", 60362),\n  arrowSwap: register(\"arrow-swap\", 60363),\n  copy: register(\"copy\", 60364),\n  personAdd: register(\"person-add\", 60365),\n  filterFilled: register(\"filter-filled\", 60366),\n  wand: register(\"wand\", 60367),\n  debugLineByLine: register(\"debug-line-by-line\", 60368),\n  inspect: register(\"inspect\", 60369),\n  layers: register(\"layers\", 60370),\n  layersDot: register(\"layers-dot\", 60371),\n  layersActive: register(\"layers-active\", 60372),\n  compass: register(\"compass\", 60373),\n  compassDot: register(\"compass-dot\", 60374),\n  compassActive: register(\"compass-active\", 60375),\n  azure: register(\"azure\", 60376),\n  issueDraft: register(\"issue-draft\", 60377),\n  gitPullRequestClosed: register(\"git-pull-request-closed\", 60378),\n  gitPullRequestDraft: register(\"git-pull-request-draft\", 60379),\n  debugAll: register(\"debug-all\", 60380),\n  debugCoverage: register(\"debug-coverage\", 60381),\n  runErrors: register(\"run-errors\", 60382),\n  folderLibrary: register(\"folder-library\", 60383),\n  debugContinueSmall: register(\"debug-continue-small\", 60384),\n  beakerStop: register(\"beaker-stop\", 60385),\n  graphLine: register(\"graph-line\", 60386),\n  graphScatter: register(\"graph-scatter\", 60387),\n  pieChart: register(\"pie-chart\", 60388),\n  bracketDot: register(\"bracket-dot\", 60389),\n  bracketError: register(\"bracket-error\", 60390),\n  lockSmall: register(\"lock-small\", 60391),\n  azureDevops: register(\"azure-devops\", 60392),\n  verifiedFilled: register(\"verified-filled\", 60393),\n  newLine: register(\"newline\", 60394),\n  layout: register(\"layout\", 60395),\n  layoutActivitybarLeft: register(\"layout-activitybar-left\", 60396),\n  layoutActivitybarRight: register(\"layout-activitybar-right\", 60397),\n  layoutPanelLeft: register(\"layout-panel-left\", 60398),\n  layoutPanelCenter: register(\"layout-panel-center\", 60399),\n  layoutPanelJustify: register(\"layout-panel-justify\", 60400),\n  layoutPanelRight: register(\"layout-panel-right\", 60401),\n  layoutPanel: register(\"layout-panel\", 60402),\n  layoutSidebarLeft: register(\"layout-sidebar-left\", 60403),\n  layoutSidebarRight: register(\"layout-sidebar-right\", 60404),\n  layoutStatusbar: register(\"layout-statusbar\", 60405),\n  layoutMenubar: register(\"layout-menubar\", 60406),\n  layoutCentered: register(\"layout-centered\", 60407),\n  layoutSidebarRightOff: register(\"layout-sidebar-right-off\", 60416),\n  layoutPanelOff: register(\"layout-panel-off\", 60417),\n  layoutSidebarLeftOff: register(\"layout-sidebar-left-off\", 60418),\n  target: register(\"target\", 60408),\n  indent: register(\"indent\", 60409),\n  recordSmall: register(\"record-small\", 60410),\n  errorSmall: register(\"error-small\", 60411),\n  arrowCircleDown: register(\"arrow-circle-down\", 60412),\n  arrowCircleLeft: register(\"arrow-circle-left\", 60413),\n  arrowCircleRight: register(\"arrow-circle-right\", 60414),\n  arrowCircleUp: register(\"arrow-circle-up\", 60415),\n  heartFilled: register(\"heart-filled\", 60420),\n  map: register(\"map\", 60421),\n  mapFilled: register(\"map-filled\", 60422),\n  circleSmall: register(\"circle-small\", 60423),\n  bellSlash: register(\"bell-slash\", 60424),\n  bellSlashDot: register(\"bell-slash-dot\", 60425),\n  commentUnresolved: register(\"comment-unresolved\", 60426),\n  gitPullRequestGoToChanges: register(\"git-pull-request-go-to-changes\", 60427),\n  gitPullRequestNewChanges: register(\"git-pull-request-new-changes\", 60428),\n  searchFuzzy: register(\"search-fuzzy\", 60429),\n  commentDraft: register(\"comment-draft\", 60430),\n  send: register(\"send\", 60431),\n  sparkle: register(\"sparkle\", 60432),\n  insert: register(\"insert\", 60433),\n  mic: register(\"mic\", 60434),\n  thumbsDownFilled: register(\"thumbsdown-filled\", 60435),\n  thumbsUpFilled: register(\"thumbsup-filled\", 60436),\n  coffee: register(\"coffee\", 60437),\n  snake: register(\"snake\", 60438),\n  game: register(\"game\", 60439),\n  vr: register(\"vr\", 60440),\n  chip: register(\"chip\", 60441),\n  piano: register(\"piano\", 60442),\n  music: register(\"music\", 60443),\n  micFilled: register(\"mic-filled\", 60444),\n  gitFetch: register(\"git-fetch\", 60445),\n  copilot: register(\"copilot\", 60446),\n  lightbulbSparkle: register(\"lightbulb-sparkle\", 60447),\n  lightbulbSparkleAutofix: register(\"lightbulb-sparkle-autofix\", 60447),\n  robot: register(\"robot\", 60448),\n  sparkleFilled: register(\"sparkle-filled\", 60449),\n  diffSingle: register(\"diff-single\", 60450),\n  diffMultiple: register(\"diff-multiple\", 60451),\n  // derived icons, that could become separate icons\n  dialogError: register(\"dialog-error\", \"error\"),\n  dialogWarning: register(\"dialog-warning\", \"warning\"),\n  dialogInfo: register(\"dialog-info\", \"info\"),\n  dialogClose: register(\"dialog-close\", \"close\"),\n  treeItemExpanded: register(\"tree-item-expanded\", \"chevron-down\"),\n  // collapsed is done with rotation\n  treeFilterOnTypeOn: register(\"tree-filter-on-type-on\", \"list-filter\"),\n  treeFilterOnTypeOff: register(\"tree-filter-on-type-off\", \"list-selection\"),\n  treeFilterClear: register(\"tree-filter-clear\", \"close\"),\n  treeItemLoading: register(\"tree-item-loading\", \"loading\"),\n  menuSelection: register(\"menu-selection\", \"check\"),\n  menuSubmenu: register(\"menu-submenu\", \"chevron-right\"),\n  menuBarMore: register(\"menubar-more\", \"more\"),\n  scrollbarButtonLeft: register(\"scrollbar-button-left\", \"triangle-left\"),\n  scrollbarButtonRight: register(\"scrollbar-button-right\", \"triangle-right\"),\n  scrollbarButtonUp: register(\"scrollbar-button-up\", \"triangle-up\"),\n  scrollbarButtonDown: register(\"scrollbar-button-down\", \"triangle-down\"),\n  toolBarMore: register(\"toolbar-more\", \"more\"),\n  quickInputBack: register(\"quick-input-back\", \"arrow-left\")\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js\nvar TokenizationRegistry = class {\n  constructor() {\n    this._tokenizationSupports = /* @__PURE__ */ new Map();\n    this._factories = /* @__PURE__ */ new Map();\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n    this._colorMap = null;\n  }\n  handleChange(languageIds) {\n    this._onDidChange.fire({\n      changedLanguages: languageIds,\n      changedColorMap: false\n    });\n  }\n  register(languageId, support) {\n    this._tokenizationSupports.set(languageId, support);\n    this.handleChange([languageId]);\n    return toDisposable(() =\u003e {\n      if (this._tokenizationSupports.get(languageId) !== support) {\n        return;\n      }\n      this._tokenizationSupports.delete(languageId);\n      this.handleChange([languageId]);\n    });\n  }\n  get(languageId) {\n    return this._tokenizationSupports.get(languageId) || null;\n  }\n  registerFactory(languageId, factory) {\n    var _a4;\n    (_a4 = this._factories.get(languageId)) === null || _a4 === void 0 ? void 0 : _a4.dispose();\n    const myData = new TokenizationSupportFactoryData(this, languageId, factory);\n    this._factories.set(languageId, myData);\n    return toDisposable(() =\u003e {\n      const v = this._factories.get(languageId);\n      if (!v || v !== myData) {\n        return;\n      }\n      this._factories.delete(languageId);\n      v.dispose();\n    });\n  }\n  async getOrCreate(languageId) {\n    const tokenizationSupport = this.get(languageId);\n    if (tokenizationSupport) {\n      return tokenizationSupport;\n    }\n    const factory = this._factories.get(languageId);\n    if (!factory || factory.isResolved) {\n      return null;\n    }\n    await factory.resolve();\n    return this.get(languageId);\n  }\n  isResolved(languageId) {\n    const tokenizationSupport = this.get(languageId);\n    if (tokenizationSupport) {\n      return true;\n    }\n    const factory = this._factories.get(languageId);\n    if (!factory || factory.isResolved) {\n      return true;\n    }\n    return false;\n  }\n  setColorMap(colorMap) {\n    this._colorMap = colorMap;\n    this._onDidChange.fire({\n      changedLanguages: Array.from(this._tokenizationSupports.keys()),\n      changedColorMap: true\n    });\n  }\n  getColorMap() {\n    return this._colorMap;\n  }\n  getDefaultBackground() {\n    if (this._colorMap \u0026\u0026 this._colorMap.length \u003e 2) {\n      return this._colorMap[\n        2\n        /* ColorId.DefaultBackground */\n      ];\n    }\n    return null;\n  }\n};\nvar TokenizationSupportFactoryData = class extends Disposable {\n  get isResolved() {\n    return this._isResolved;\n  }\n  constructor(_registry, _languageId, _factory) {\n    super();\n    this._registry = _registry;\n    this._languageId = _languageId;\n    this._factory = _factory;\n    this._isDisposed = false;\n    this._resolvePromise = null;\n    this._isResolved = false;\n  }\n  dispose() {\n    this._isDisposed = true;\n    super.dispose();\n  }\n  async resolve() {\n    if (!this._resolvePromise) {\n      this._resolvePromise = this._create();\n    }\n    return this._resolvePromise;\n  }\n  async _create() {\n    const value = await this._factory.tokenizationSupport;\n    this._isResolved = true;\n    if (value \u0026\u0026 !this._isDisposed) {\n      this._register(this._registry.register(this._languageId, value));\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js\nvar Token = class {\n  constructor(offset, type, language) {\n    this.offset = offset;\n    this.type = type;\n    this.language = language;\n    this._tokenBrand = void 0;\n  }\n  toString() {\n    return \"(\" + this.offset + \", \" + this.type + \")\";\n  }\n};\nvar CompletionItemKinds;\n(function(CompletionItemKinds2) {\n  const byKind = /* @__PURE__ */ new Map();\n  byKind.set(0, Codicon.symbolMethod);\n  byKind.set(1, Codicon.symbolFunction);\n  byKind.set(2, Codicon.symbolConstructor);\n  byKind.set(3, Codicon.symbolField);\n  byKind.set(4, Codicon.symbolVariable);\n  byKind.set(5, Codicon.symbolClass);\n  byKind.set(6, Codicon.symbolStruct);\n  byKind.set(7, Codicon.symbolInterface);\n  byKind.set(8, Codicon.symbolModule);\n  byKind.set(9, Codicon.symbolProperty);\n  byKind.set(10, Codicon.symbolEvent);\n  byKind.set(11, Codicon.symbolOperator);\n  byKind.set(12, Codicon.symbolUnit);\n  byKind.set(13, Codicon.symbolValue);\n  byKind.set(15, Codicon.symbolEnum);\n  byKind.set(14, Codicon.symbolConstant);\n  byKind.set(15, Codicon.symbolEnum);\n  byKind.set(16, Codicon.symbolEnumMember);\n  byKind.set(17, Codicon.symbolKeyword);\n  byKind.set(27, Codicon.symbolSnippet);\n  byKind.set(18, Codicon.symbolText);\n  byKind.set(19, Codicon.symbolColor);\n  byKind.set(20, Codicon.symbolFile);\n  byKind.set(21, Codicon.symbolReference);\n  byKind.set(22, Codicon.symbolCustomColor);\n  byKind.set(23, Codicon.symbolFolder);\n  byKind.set(24, Codicon.symbolTypeParameter);\n  byKind.set(25, Codicon.account);\n  byKind.set(26, Codicon.issues);\n  function toIcon(kind) {\n    let codicon = byKind.get(kind);\n    if (!codicon) {\n      console.info(\"No codicon found for CompletionItemKind \" + kind);\n      codicon = Codicon.symbolProperty;\n    }\n    return codicon;\n  }\n  CompletionItemKinds2.toIcon = toIcon;\n  const data = /* @__PURE__ */ new Map();\n  data.set(\n    \"method\",\n    0\n    /* CompletionItemKind.Method */\n  );\n  data.set(\n    \"function\",\n    1\n    /* CompletionItemKind.Function */\n  );\n  data.set(\n    \"constructor\",\n    2\n    /* CompletionItemKind.Constructor */\n  );\n  data.set(\n    \"field\",\n    3\n    /* CompletionItemKind.Field */\n  );\n  data.set(\n    \"variable\",\n    4\n    /* CompletionItemKind.Variable */\n  );\n  data.set(\n    \"class\",\n    5\n    /* CompletionItemKind.Class */\n  );\n  data.set(\n    \"struct\",\n    6\n    /* CompletionItemKind.Struct */\n  );\n  data.set(\n    \"interface\",\n    7\n    /* CompletionItemKind.Interface */\n  );\n  data.set(\n    \"module\",\n    8\n    /* CompletionItemKind.Module */\n  );\n  data.set(\n    \"property\",\n    9\n    /* CompletionItemKind.Property */\n  );\n  data.set(\n    \"event\",\n    10\n    /* CompletionItemKind.Event */\n  );\n  data.set(\n    \"operator\",\n    11\n    /* CompletionItemKind.Operator */\n  );\n  data.set(\n    \"unit\",\n    12\n    /* CompletionItemKind.Unit */\n  );\n  data.set(\n    \"value\",\n    13\n    /* CompletionItemKind.Value */\n  );\n  data.set(\n    \"constant\",\n    14\n    /* CompletionItemKind.Constant */\n  );\n  data.set(\n    \"enum\",\n    15\n    /* CompletionItemKind.Enum */\n  );\n  data.set(\n    \"enum-member\",\n    16\n    /* CompletionItemKind.EnumMember */\n  );\n  data.set(\n    \"enumMember\",\n    16\n    /* CompletionItemKind.EnumMember */\n  );\n  data.set(\n    \"keyword\",\n    17\n    /* CompletionItemKind.Keyword */\n  );\n  data.set(\n    \"snippet\",\n    27\n    /* CompletionItemKind.Snippet */\n  );\n  data.set(\n    \"text\",\n    18\n    /* CompletionItemKind.Text */\n  );\n  data.set(\n    \"color\",\n    19\n    /* CompletionItemKind.Color */\n  );\n  data.set(\n    \"file\",\n    20\n    /* CompletionItemKind.File */\n  );\n  data.set(\n    \"reference\",\n    21\n    /* CompletionItemKind.Reference */\n  );\n  data.set(\n    \"customcolor\",\n    22\n    /* CompletionItemKind.Customcolor */\n  );\n  data.set(\n    \"folder\",\n    23\n    /* CompletionItemKind.Folder */\n  );\n  data.set(\n    \"type-parameter\",\n    24\n    /* CompletionItemKind.TypeParameter */\n  );\n  data.set(\n    \"typeParameter\",\n    24\n    /* CompletionItemKind.TypeParameter */\n  );\n  data.set(\n    \"account\",\n    25\n    /* CompletionItemKind.User */\n  );\n  data.set(\n    \"issue\",\n    26\n    /* CompletionItemKind.Issue */\n  );\n  function fromString(value, strict) {\n    let res = data.get(value);\n    if (typeof res === \"undefined\" \u0026\u0026 !strict) {\n      res = 9;\n    }\n    return res;\n  }\n  CompletionItemKinds2.fromString = fromString;\n})(CompletionItemKinds || (CompletionItemKinds = {}));\nvar InlineCompletionTriggerKind;\n(function(InlineCompletionTriggerKind3) {\n  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3[\"Automatic\"] = 0] = \"Automatic\";\n  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nvar SignatureHelpTriggerKind;\n(function(SignatureHelpTriggerKind3) {\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"Invoke\"] = 1] = \"Invoke\";\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\nvar DocumentHighlightKind;\n(function(DocumentHighlightKind4) {\n  DocumentHighlightKind4[DocumentHighlightKind4[\"Text\"] = 0] = \"Text\";\n  DocumentHighlightKind4[DocumentHighlightKind4[\"Read\"] = 1] = \"Read\";\n  DocumentHighlightKind4[DocumentHighlightKind4[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\nvar symbolKindNames = {\n  [\n    17\n    /* SymbolKind.Array */\n  ]: localize(\"Array\", \"array\"),\n  [\n    16\n    /* SymbolKind.Boolean */\n  ]: localize(\"Boolean\", \"boolean\"),\n  [\n    4\n    /* SymbolKind.Class */\n  ]: localize(\"Class\", \"class\"),\n  [\n    13\n    /* SymbolKind.Constant */\n  ]: localize(\"Constant\", \"constant\"),\n  [\n    8\n    /* SymbolKind.Constructor */\n  ]: localize(\"Constructor\", \"constructor\"),\n  [\n    9\n    /* SymbolKind.Enum */\n  ]: localize(\"Enum\", \"enumeration\"),\n  [\n    21\n    /* SymbolKind.EnumMember */\n  ]: localize(\"EnumMember\", \"enumeration member\"),\n  [\n    23\n    /* SymbolKind.Event */\n  ]: localize(\"Event\", \"event\"),\n  [\n    7\n    /* SymbolKind.Field */\n  ]: localize(\"Field\", \"field\"),\n  [\n    0\n    /* SymbolKind.File */\n  ]: localize(\"File\", \"file\"),\n  [\n    11\n    /* SymbolKind.Function */\n  ]: localize(\"Function\", \"function\"),\n  [\n    10\n    /* SymbolKind.Interface */\n  ]: localize(\"Interface\", \"interface\"),\n  [\n    19\n    /* SymbolKind.Key */\n  ]: localize(\"Key\", \"key\"),\n  [\n    5\n    /* SymbolKind.Method */\n  ]: localize(\"Method\", \"method\"),\n  [\n    1\n    /* SymbolKind.Module */\n  ]: localize(\"Module\", \"module\"),\n  [\n    2\n    /* SymbolKind.Namespace */\n  ]: localize(\"Namespace\", \"namespace\"),\n  [\n    20\n    /* SymbolKind.Null */\n  ]: localize(\"Null\", \"null\"),\n  [\n    15\n    /* SymbolKind.Number */\n  ]: localize(\"Number\", \"number\"),\n  [\n    18\n    /* SymbolKind.Object */\n  ]: localize(\"Object\", \"object\"),\n  [\n    24\n    /* SymbolKind.Operator */\n  ]: localize(\"Operator\", \"operator\"),\n  [\n    3\n    /* SymbolKind.Package */\n  ]: localize(\"Package\", \"package\"),\n  [\n    6\n    /* SymbolKind.Property */\n  ]: localize(\"Property\", \"property\"),\n  [\n    14\n    /* SymbolKind.String */\n  ]: localize(\"String\", \"string\"),\n  [\n    22\n    /* SymbolKind.Struct */\n  ]: localize(\"Struct\", \"struct\"),\n  [\n    25\n    /* SymbolKind.TypeParameter */\n  ]: localize(\"TypeParameter\", \"type parameter\"),\n  [\n    12\n    /* SymbolKind.Variable */\n  ]: localize(\"Variable\", \"variable\")\n};\nvar SymbolKinds;\n(function(SymbolKinds2) {\n  const byKind = /* @__PURE__ */ new Map();\n  byKind.set(0, Codicon.symbolFile);\n  byKind.set(1, Codicon.symbolModule);\n  byKind.set(2, Codicon.symbolNamespace);\n  byKind.set(3, Codicon.symbolPackage);\n  byKind.set(4, Codicon.symbolClass);\n  byKind.set(5, Codicon.symbolMethod);\n  byKind.set(6, Codicon.symbolProperty);\n  byKind.set(7, Codicon.symbolField);\n  byKind.set(8, Codicon.symbolConstructor);\n  byKind.set(9, Codicon.symbolEnum);\n  byKind.set(10, Codicon.symbolInterface);\n  byKind.set(11, Codicon.symbolFunction);\n  byKind.set(12, Codicon.symbolVariable);\n  byKind.set(13, Codicon.symbolConstant);\n  byKind.set(14, Codicon.symbolString);\n  byKind.set(15, Codicon.symbolNumber);\n  byKind.set(16, Codicon.symbolBoolean);\n  byKind.set(17, Codicon.symbolArray);\n  byKind.set(18, Codicon.symbolObject);\n  byKind.set(19, Codicon.symbolKey);\n  byKind.set(20, Codicon.symbolNull);\n  byKind.set(21, Codicon.symbolEnumMember);\n  byKind.set(22, Codicon.symbolStruct);\n  byKind.set(23, Codicon.symbolEvent);\n  byKind.set(24, Codicon.symbolOperator);\n  byKind.set(25, Codicon.symbolTypeParameter);\n  function toIcon(kind) {\n    let icon = byKind.get(kind);\n    if (!icon) {\n      console.info(\"No codicon found for SymbolKind \" + kind);\n      icon = Codicon.symbolProperty;\n    }\n    return icon;\n  }\n  SymbolKinds2.toIcon = toIcon;\n})(SymbolKinds || (SymbolKinds = {}));\nvar FoldingRangeKind = class _FoldingRangeKind {\n  /**\n   * Returns a {@link FoldingRangeKind} for the given value.\n   *\n   * @param value of the kind.\n   */\n  static fromValue(value) {\n    switch (value) {\n      case \"comment\":\n        return _FoldingRangeKind.Comment;\n      case \"imports\":\n        return _FoldingRangeKind.Imports;\n      case \"region\":\n        return _FoldingRangeKind.Region;\n    }\n    return new _FoldingRangeKind(value);\n  }\n  /**\n   * Creates a new {@link FoldingRangeKind}.\n   *\n   * @param value of the kind.\n   */\n  constructor(value) {\n    this.value = value;\n  }\n};\nFoldingRangeKind.Comment = new FoldingRangeKind(\"comment\");\nFoldingRangeKind.Imports = new FoldingRangeKind(\"imports\");\nFoldingRangeKind.Region = new FoldingRangeKind(\"region\");\nvar Command;\n(function(Command3) {\n  function is(obj) {\n    if (!obj || typeof obj !== \"object\") {\n      return false;\n    }\n    return typeof obj.id === \"string\" \u0026\u0026 typeof obj.title === \"string\";\n  }\n  Command3.is = is;\n})(Command || (Command = {}));\nvar InlayHintKind;\n(function(InlayHintKind3) {\n  InlayHintKind3[InlayHintKind3[\"Type\"] = 1] = \"Type\";\n  InlayHintKind3[InlayHintKind3[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\nvar TokenizationRegistry2 = new TokenizationRegistry();\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js\nvar AccessibilitySupport;\n(function(AccessibilitySupport2) {\n  AccessibilitySupport2[AccessibilitySupport2[\"Unknown\"] = 0] = \"Unknown\";\n  AccessibilitySupport2[AccessibilitySupport2[\"Disabled\"] = 1] = \"Disabled\";\n  AccessibilitySupport2[AccessibilitySupport2[\"Enabled\"] = 2] = \"Enabled\";\n})(AccessibilitySupport || (AccessibilitySupport = {}));\nvar CodeActionTriggerType;\n(function(CodeActionTriggerType2) {\n  CodeActionTriggerType2[CodeActionTriggerType2[\"Invoke\"] = 1] = \"Invoke\";\n  CodeActionTriggerType2[CodeActionTriggerType2[\"Auto\"] = 2] = \"Auto\";\n})(CodeActionTriggerType || (CodeActionTriggerType = {}));\nvar CompletionItemInsertTextRule;\n(function(CompletionItemInsertTextRule2) {\n  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2[\"None\"] = 0] = \"None\";\n  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2[\"KeepWhitespace\"] = 1] = \"KeepWhitespace\";\n  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2[\"InsertAsSnippet\"] = 4] = \"InsertAsSnippet\";\n})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));\nvar CompletionItemKind;\n(function(CompletionItemKind3) {\n  CompletionItemKind3[CompletionItemKind3[\"Method\"] = 0] = \"Method\";\n  CompletionItemKind3[CompletionItemKind3[\"Function\"] = 1] = \"Function\";\n  CompletionItemKind3[CompletionItemKind3[\"Constructor\"] = 2] = \"Constructor\";\n  CompletionItemKind3[CompletionItemKind3[\"Field\"] = 3] = \"Field\";\n  CompletionItemKind3[CompletionItemKind3[\"Variable\"] = 4] = \"Variable\";\n  CompletionItemKind3[CompletionItemKind3[\"Class\"] = 5] = \"Class\";\n  CompletionItemKind3[CompletionItemKind3[\"Struct\"] = 6] = \"Struct\";\n  CompletionItemKind3[CompletionItemKind3[\"Interface\"] = 7] = \"Interface\";\n  CompletionItemKind3[CompletionItemKind3[\"Module\"] = 8] = \"Module\";\n  CompletionItemKind3[CompletionItemKind3[\"Property\"] = 9] = \"Property\";\n  CompletionItemKind3[CompletionItemKind3[\"Event\"] = 10] = \"Event\";\n  CompletionItemKind3[CompletionItemKind3[\"Operator\"] = 11] = \"Operator\";\n  CompletionItemKind3[CompletionItemKind3[\"Unit\"] = 12] = \"Unit\";\n  CompletionItemKind3[CompletionItemKind3[\"Value\"] = 13] = \"Value\";\n  CompletionItemKind3[CompletionItemKind3[\"Constant\"] = 14] = \"Constant\";\n  CompletionItemKind3[CompletionItemKind3[\"Enum\"] = 15] = \"Enum\";\n  CompletionItemKind3[CompletionItemKind3[\"EnumMember\"] = 16] = \"EnumMember\";\n  CompletionItemKind3[CompletionItemKind3[\"Keyword\"] = 17] = \"Keyword\";\n  CompletionItemKind3[CompletionItemKind3[\"Text\"] = 18] = \"Text\";\n  CompletionItemKind3[CompletionItemKind3[\"Color\"] = 19] = \"Color\";\n  CompletionItemKind3[CompletionItemKind3[\"File\"] = 20] = \"File\";\n  CompletionItemKind3[CompletionItemKind3[\"Reference\"] = 21] = \"Reference\";\n  CompletionItemKind3[CompletionItemKind3[\"Customcolor\"] = 22] = \"Customcolor\";\n  CompletionItemKind3[CompletionItemKind3[\"Folder\"] = 23] = \"Folder\";\n  CompletionItemKind3[CompletionItemKind3[\"TypeParameter\"] = 24] = \"TypeParameter\";\n  CompletionItemKind3[CompletionItemKind3[\"User\"] = 25] = \"User\";\n  CompletionItemKind3[CompletionItemKind3[\"Issue\"] = 26] = \"Issue\";\n  CompletionItemKind3[CompletionItemKind3[\"Snippet\"] = 27] = \"Snippet\";\n})(CompletionItemKind || (CompletionItemKind = {}));\nvar CompletionItemTag;\n(function(CompletionItemTag3) {\n  CompletionItemTag3[CompletionItemTag3[\"Deprecated\"] = 1] = \"Deprecated\";\n})(CompletionItemTag || (CompletionItemTag = {}));\nvar CompletionTriggerKind;\n(function(CompletionTriggerKind2) {\n  CompletionTriggerKind2[CompletionTriggerKind2[\"Invoke\"] = 0] = \"Invoke\";\n  CompletionTriggerKind2[CompletionTriggerKind2[\"TriggerCharacter\"] = 1] = \"TriggerCharacter\";\n  CompletionTriggerKind2[CompletionTriggerKind2[\"TriggerForIncompleteCompletions\"] = 2] = \"TriggerForIncompleteCompletions\";\n})(CompletionTriggerKind || (CompletionTriggerKind = {}));\nvar ContentWidgetPositionPreference;\n(function(ContentWidgetPositionPreference2) {\n  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2[\"EXACT\"] = 0] = \"EXACT\";\n  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2[\"ABOVE\"] = 1] = \"ABOVE\";\n  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2[\"BELOW\"] = 2] = \"BELOW\";\n})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));\nvar CursorChangeReason;\n(function(CursorChangeReason2) {\n  CursorChangeReason2[CursorChangeReason2[\"NotSet\"] = 0] = \"NotSet\";\n  CursorChangeReason2[CursorChangeReason2[\"ContentFlush\"] = 1] = \"ContentFlush\";\n  CursorChangeReason2[CursorChangeReason2[\"RecoverFromMarkers\"] = 2] = \"RecoverFromMarkers\";\n  CursorChangeReason2[CursorChangeReason2[\"Explicit\"] = 3] = \"Explicit\";\n  CursorChangeReason2[CursorChangeReason2[\"Paste\"] = 4] = \"Paste\";\n  CursorChangeReason2[CursorChangeReason2[\"Undo\"] = 5] = \"Undo\";\n  CursorChangeReason2[CursorChangeReason2[\"Redo\"] = 6] = \"Redo\";\n})(CursorChangeReason || (CursorChangeReason = {}));\nvar DefaultEndOfLine;\n(function(DefaultEndOfLine2) {\n  DefaultEndOfLine2[DefaultEndOfLine2[\"LF\"] = 1] = \"LF\";\n  DefaultEndOfLine2[DefaultEndOfLine2[\"CRLF\"] = 2] = \"CRLF\";\n})(DefaultEndOfLine || (DefaultEndOfLine = {}));\nvar DocumentHighlightKind2;\n(function(DocumentHighlightKind4) {\n  DocumentHighlightKind4[DocumentHighlightKind4[\"Text\"] = 0] = \"Text\";\n  DocumentHighlightKind4[DocumentHighlightKind4[\"Read\"] = 1] = \"Read\";\n  DocumentHighlightKind4[DocumentHighlightKind4[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));\nvar EditorAutoIndentStrategy;\n(function(EditorAutoIndentStrategy2) {\n  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2[\"None\"] = 0] = \"None\";\n  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2[\"Keep\"] = 1] = \"Keep\";\n  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2[\"Brackets\"] = 2] = \"Brackets\";\n  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2[\"Advanced\"] = 3] = \"Advanced\";\n  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2[\"Full\"] = 4] = \"Full\";\n})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));\nvar EditorOption;\n(function(EditorOption2) {\n  EditorOption2[EditorOption2[\"acceptSuggestionOnCommitCharacter\"] = 0] = \"acceptSuggestionOnCommitCharacter\";\n  EditorOption2[EditorOption2[\"acceptSuggestionOnEnter\"] = 1] = \"acceptSuggestionOnEnter\";\n  EditorOption2[EditorOption2[\"accessibilitySupport\"] = 2] = \"accessibilitySupport\";\n  EditorOption2[EditorOption2[\"accessibilityPageSize\"] = 3] = \"accessibilityPageSize\";\n  EditorOption2[EditorOption2[\"ariaLabel\"] = 4] = \"ariaLabel\";\n  EditorOption2[EditorOption2[\"ariaRequired\"] = 5] = \"ariaRequired\";\n  EditorOption2[EditorOption2[\"autoClosingBrackets\"] = 6] = \"autoClosingBrackets\";\n  EditorOption2[EditorOption2[\"autoClosingComments\"] = 7] = \"autoClosingComments\";\n  EditorOption2[EditorOption2[\"screenReaderAnnounceInlineSuggestion\"] = 8] = \"screenReaderAnnounceInlineSuggestion\";\n  EditorOption2[EditorOption2[\"autoClosingDelete\"] = 9] = \"autoClosingDelete\";\n  EditorOption2[EditorOption2[\"autoClosingOvertype\"] = 10] = \"autoClosingOvertype\";\n  EditorOption2[EditorOption2[\"autoClosingQuotes\"] = 11] = \"autoClosingQuotes\";\n  EditorOption2[EditorOption2[\"autoIndent\"] = 12] = \"autoIndent\";\n  EditorOption2[EditorOption2[\"automaticLayout\"] = 13] = \"automaticLayout\";\n  EditorOption2[EditorOption2[\"autoSurround\"] = 14] = \"autoSurround\";\n  EditorOption2[EditorOption2[\"bracketPairColorization\"] = 15] = \"bracketPairColorization\";\n  EditorOption2[EditorOption2[\"guides\"] = 16] = \"guides\";\n  EditorOption2[EditorOption2[\"codeLens\"] = 17] = \"codeLens\";\n  EditorOption2[EditorOption2[\"codeLensFontFamily\"] = 18] = \"codeLensFontFamily\";\n  EditorOption2[EditorOption2[\"codeLensFontSize\"] = 19] = \"codeLensFontSize\";\n  EditorOption2[EditorOption2[\"colorDecorators\"] = 20] = \"colorDecorators\";\n  EditorOption2[EditorOption2[\"colorDecoratorsLimit\"] = 21] = \"colorDecoratorsLimit\";\n  EditorOption2[EditorOption2[\"columnSelection\"] = 22] = \"columnSelection\";\n  EditorOption2[EditorOption2[\"comments\"] = 23] = \"comments\";\n  EditorOption2[EditorOption2[\"contextmenu\"] = 24] = \"contextmenu\";\n  EditorOption2[EditorOption2[\"copyWithSyntaxHighlighting\"] = 25] = \"copyWithSyntaxHighlighting\";\n  EditorOption2[EditorOption2[\"cursorBlinking\"] = 26] = \"cursorBlinking\";\n  EditorOption2[EditorOption2[\"cursorSmoothCaretAnimation\"] = 27] = \"cursorSmoothCaretAnimation\";\n  EditorOption2[EditorOption2[\"cursorStyle\"] = 28] = \"cursorStyle\";\n  EditorOption2[EditorOption2[\"cursorSurroundingLines\"] = 29] = \"cursorSurroundingLines\";\n  EditorOption2[EditorOption2[\"cursorSurroundingLinesStyle\"] = 30] = \"cursorSurroundingLinesStyle\";\n  EditorOption2[EditorOption2[\"cursorWidth\"] = 31] = \"cursorWidth\";\n  EditorOption2[EditorOption2[\"disableLayerHinting\"] = 32] = \"disableLayerHinting\";\n  EditorOption2[EditorOption2[\"disableMonospaceOptimizations\"] = 33] = \"disableMonospaceOptimizations\";\n  EditorOption2[EditorOption2[\"domReadOnly\"] = 34] = \"domReadOnly\";\n  EditorOption2[EditorOption2[\"dragAndDrop\"] = 35] = \"dragAndDrop\";\n  EditorOption2[EditorOption2[\"dropIntoEditor\"] = 36] = \"dropIntoEditor\";\n  EditorOption2[EditorOption2[\"emptySelectionClipboard\"] = 37] = \"emptySelectionClipboard\";\n  EditorOption2[EditorOption2[\"experimentalWhitespaceRendering\"] = 38] = \"experimentalWhitespaceRendering\";\n  EditorOption2[EditorOption2[\"extraEditorClassName\"] = 39] = \"extraEditorClassName\";\n  EditorOption2[EditorOption2[\"fastScrollSensitivity\"] = 40] = \"fastScrollSensitivity\";\n  EditorOption2[EditorOption2[\"find\"] = 41] = \"find\";\n  EditorOption2[EditorOption2[\"fixedOverflowWidgets\"] = 42] = \"fixedOverflowWidgets\";\n  EditorOption2[EditorOption2[\"folding\"] = 43] = \"folding\";\n  EditorOption2[EditorOption2[\"foldingStrategy\"] = 44] = \"foldingStrategy\";\n  EditorOption2[EditorOption2[\"foldingHighlight\"] = 45] = \"foldingHighlight\";\n  EditorOption2[EditorOption2[\"foldingImportsByDefault\"] = 46] = \"foldingImportsByDefault\";\n  EditorOption2[EditorOption2[\"foldingMaximumRegions\"] = 47] = \"foldingMaximumRegions\";\n  EditorOption2[EditorOption2[\"unfoldOnClickAfterEndOfLine\"] = 48] = \"unfoldOnClickAfterEndOfLine\";\n  EditorOption2[EditorOption2[\"fontFamily\"] = 49] = \"fontFamily\";\n  EditorOption2[EditorOption2[\"fontInfo\"] = 50] = \"fontInfo\";\n  EditorOption2[EditorOption2[\"fontLigatures\"] = 51] = \"fontLigatures\";\n  EditorOption2[EditorOption2[\"fontSize\"] = 52] = \"fontSize\";\n  EditorOption2[EditorOption2[\"fontWeight\"] = 53] = \"fontWeight\";\n  EditorOption2[EditorOption2[\"fontVariations\"] = 54] = \"fontVariations\";\n  EditorOption2[EditorOption2[\"formatOnPaste\"] = 55] = \"formatOnPaste\";\n  EditorOption2[EditorOption2[\"formatOnType\"] = 56] = \"formatOnType\";\n  EditorOption2[EditorOption2[\"glyphMargin\"] = 57] = \"glyphMargin\";\n  EditorOption2[EditorOption2[\"gotoLocation\"] = 58] = \"gotoLocation\";\n  EditorOption2[EditorOption2[\"hideCursorInOverviewRuler\"] = 59] = \"hideCursorInOverviewRuler\";\n  EditorOption2[EditorOption2[\"hover\"] = 60] = \"hover\";\n  EditorOption2[EditorOption2[\"inDiffEditor\"] = 61] = \"inDiffEditor\";\n  EditorOption2[EditorOption2[\"inlineSuggest\"] = 62] = \"inlineSuggest\";\n  EditorOption2[EditorOption2[\"letterSpacing\"] = 63] = \"letterSpacing\";\n  EditorOption2[EditorOption2[\"lightbulb\"] = 64] = \"lightbulb\";\n  EditorOption2[EditorOption2[\"lineDecorationsWidth\"] = 65] = \"lineDecorationsWidth\";\n  EditorOption2[EditorOption2[\"lineHeight\"] = 66] = \"lineHeight\";\n  EditorOption2[EditorOption2[\"lineNumbers\"] = 67] = \"lineNumbers\";\n  EditorOption2[EditorOption2[\"lineNumbersMinChars\"] = 68] = \"lineNumbersMinChars\";\n  EditorOption2[EditorOption2[\"linkedEditing\"] = 69] = \"linkedEditing\";\n  EditorOption2[EditorOption2[\"links\"] = 70] = \"links\";\n  EditorOption2[EditorOption2[\"matchBrackets\"] = 71] = \"matchBrackets\";\n  EditorOption2[EditorOption2[\"minimap\"] = 72] = \"minimap\";\n  EditorOption2[EditorOption2[\"mouseStyle\"] = 73] = \"mouseStyle\";\n  EditorOption2[EditorOption2[\"mouseWheelScrollSensitivity\"] = 74] = \"mouseWheelScrollSensitivity\";\n  EditorOption2[EditorOption2[\"mouseWheelZoom\"] = 75] = \"mouseWheelZoom\";\n  EditorOption2[EditorOption2[\"multiCursorMergeOverlapping\"] = 76] = \"multiCursorMergeOverlapping\";\n  EditorOption2[EditorOption2[\"multiCursorModifier\"] = 77] = \"multiCursorModifier\";\n  EditorOption2[EditorOption2[\"multiCursorPaste\"] = 78] = \"multiCursorPaste\";\n  EditorOption2[EditorOption2[\"multiCursorLimit\"] = 79] = \"multiCursorLimit\";\n  EditorOption2[EditorOption2[\"occurrencesHighlight\"] = 80] = \"occurrencesHighlight\";\n  EditorOption2[EditorOption2[\"overviewRulerBorder\"] = 81] = \"overviewRulerBorder\";\n  EditorOption2[EditorOption2[\"overviewRulerLanes\"] = 82] = \"overviewRulerLanes\";\n  EditorOption2[EditorOption2[\"padding\"] = 83] = \"padding\";\n  EditorOption2[EditorOption2[\"pasteAs\"] = 84] = \"pasteAs\";\n  EditorOption2[EditorOption2[\"parameterHints\"] = 85] = \"parameterHints\";\n  EditorOption2[EditorOption2[\"peekWidgetDefaultFocus\"] = 86] = \"peekWidgetDefaultFocus\";\n  EditorOption2[EditorOption2[\"definitionLinkOpensInPeek\"] = 87] = \"definitionLinkOpensInPeek\";\n  EditorOption2[EditorOption2[\"quickSuggestions\"] = 88] = \"quickSuggestions\";\n  EditorOption2[EditorOption2[\"quickSuggestionsDelay\"] = 89] = \"quickSuggestionsDelay\";\n  EditorOption2[EditorOption2[\"readOnly\"] = 90] = \"readOnly\";\n  EditorOption2[EditorOption2[\"readOnlyMessage\"] = 91] = \"readOnlyMessage\";\n  EditorOption2[EditorOption2[\"renameOnType\"] = 92] = \"renameOnType\";\n  EditorOption2[EditorOption2[\"renderControlCharacters\"] = 93] = \"renderControlCharacters\";\n  EditorOption2[EditorOption2[\"renderFinalNewline\"] = 94] = \"renderFinalNewline\";\n  EditorOption2[EditorOption2[\"renderLineHighlight\"] = 95] = \"renderLineHighlight\";\n  EditorOption2[EditorOption2[\"renderLineHighlightOnlyWhenFocus\"] = 96] = \"renderLineHighlightOnlyWhenFocus\";\n  EditorOption2[EditorOption2[\"renderValidationDecorations\"] = 97] = \"renderValidationDecorations\";\n  EditorOption2[EditorOption2[\"renderWhitespace\"] = 98] = \"renderWhitespace\";\n  EditorOption2[EditorOption2[\"revealHorizontalRightPadding\"] = 99] = \"revealHorizontalRightPadding\";\n  EditorOption2[EditorOption2[\"roundedSelection\"] = 100] = \"roundedSelection\";\n  EditorOption2[EditorOption2[\"rulers\"] = 101] = \"rulers\";\n  EditorOption2[EditorOption2[\"scrollbar\"] = 102] = \"scrollbar\";\n  EditorOption2[EditorOption2[\"scrollBeyondLastColumn\"] = 103] = \"scrollBeyondLastColumn\";\n  EditorOption2[EditorOption2[\"scrollBeyondLastLine\"] = 104] = \"scrollBeyondLastLine\";\n  EditorOption2[EditorOption2[\"scrollPredominantAxis\"] = 105] = \"scrollPredominantAxis\";\n  EditorOption2[EditorOption2[\"selectionClipboard\"] = 106] = \"selectionClipboard\";\n  EditorOption2[EditorOption2[\"selectionHighlight\"] = 107] = \"selectionHighlight\";\n  EditorOption2[EditorOption2[\"selectOnLineNumbers\"] = 108] = \"selectOnLineNumbers\";\n  EditorOption2[EditorOption2[\"showFoldingControls\"] = 109] = \"showFoldingControls\";\n  EditorOption2[EditorOption2[\"showUnused\"] = 110] = \"showUnused\";\n  EditorOption2[EditorOption2[\"snippetSuggestions\"] = 111] = \"snippetSuggestions\";\n  EditorOption2[EditorOption2[\"smartSelect\"] = 112] = \"smartSelect\";\n  EditorOption2[EditorOption2[\"smoothScrolling\"] = 113] = \"smoothScrolling\";\n  EditorOption2[EditorOption2[\"stickyScroll\"] = 114] = \"stickyScroll\";\n  EditorOption2[EditorOption2[\"stickyTabStops\"] = 115] = \"stickyTabStops\";\n  EditorOption2[EditorOption2[\"stopRenderingLineAfter\"] = 116] = \"stopRenderingLineAfter\";\n  EditorOption2[EditorOption2[\"suggest\"] = 117] = \"suggest\";\n  EditorOption2[EditorOption2[\"suggestFontSize\"] = 118] = \"suggestFontSize\";\n  EditorOption2[EditorOption2[\"suggestLineHeight\"] = 119] = \"suggestLineHeight\";\n  EditorOption2[EditorOption2[\"suggestOnTriggerCharacters\"] = 120] = \"suggestOnTriggerCharacters\";\n  EditorOption2[EditorOption2[\"suggestSelection\"] = 121] = \"suggestSelection\";\n  EditorOption2[EditorOption2[\"tabCompletion\"] = 122] = \"tabCompletion\";\n  EditorOption2[EditorOption2[\"tabIndex\"] = 123] = \"tabIndex\";\n  EditorOption2[EditorOption2[\"unicodeHighlighting\"] = 124] = \"unicodeHighlighting\";\n  EditorOption2[EditorOption2[\"unusualLineTerminators\"] = 125] = \"unusualLineTerminators\";\n  EditorOption2[EditorOption2[\"useShadowDOM\"] = 126] = \"useShadowDOM\";\n  EditorOption2[EditorOption2[\"useTabStops\"] = 127] = \"useTabStops\";\n  EditorOption2[EditorOption2[\"wordBreak\"] = 128] = \"wordBreak\";\n  EditorOption2[EditorOption2[\"wordSeparators\"] = 129] = \"wordSeparators\";\n  EditorOption2[EditorOption2[\"wordWrap\"] = 130] = \"wordWrap\";\n  EditorOption2[EditorOption2[\"wordWrapBreakAfterCharacters\"] = 131] = \"wordWrapBreakAfterCharacters\";\n  EditorOption2[EditorOption2[\"wordWrapBreakBeforeCharacters\"] = 132] = \"wordWrapBreakBeforeCharacters\";\n  EditorOption2[EditorOption2[\"wordWrapColumn\"] = 133] = \"wordWrapColumn\";\n  EditorOption2[EditorOption2[\"wordWrapOverride1\"] = 134] = \"wordWrapOverride1\";\n  EditorOption2[EditorOption2[\"wordWrapOverride2\"] = 135] = \"wordWrapOverride2\";\n  EditorOption2[EditorOption2[\"wrappingIndent\"] = 136] = \"wrappingIndent\";\n  EditorOption2[EditorOption2[\"wrappingStrategy\"] = 137] = \"wrappingStrategy\";\n  EditorOption2[EditorOption2[\"showDeprecated\"] = 138] = \"showDeprecated\";\n  EditorOption2[EditorOption2[\"inlayHints\"] = 139] = \"inlayHints\";\n  EditorOption2[EditorOption2[\"editorClassName\"] = 140] = \"editorClassName\";\n  EditorOption2[EditorOption2[\"pixelRatio\"] = 141] = \"pixelRatio\";\n  EditorOption2[EditorOption2[\"tabFocusMode\"] = 142] = \"tabFocusMode\";\n  EditorOption2[EditorOption2[\"layoutInfo\"] = 143] = \"layoutInfo\";\n  EditorOption2[EditorOption2[\"wrappingInfo\"] = 144] = \"wrappingInfo\";\n  EditorOption2[EditorOption2[\"defaultColorDecorators\"] = 145] = \"defaultColorDecorators\";\n  EditorOption2[EditorOption2[\"colorDecoratorsActivatedOn\"] = 146] = \"colorDecoratorsActivatedOn\";\n  EditorOption2[EditorOption2[\"inlineCompletionsAccessibilityVerbose\"] = 147] = \"inlineCompletionsAccessibilityVerbose\";\n})(EditorOption || (EditorOption = {}));\nvar EndOfLinePreference;\n(function(EndOfLinePreference2) {\n  EndOfLinePreference2[EndOfLinePreference2[\"TextDefined\"] = 0] = \"TextDefined\";\n  EndOfLinePreference2[EndOfLinePreference2[\"LF\"] = 1] = \"LF\";\n  EndOfLinePreference2[EndOfLinePreference2[\"CRLF\"] = 2] = \"CRLF\";\n})(EndOfLinePreference || (EndOfLinePreference = {}));\nvar EndOfLineSequence;\n(function(EndOfLineSequence2) {\n  EndOfLineSequence2[EndOfLineSequence2[\"LF\"] = 0] = \"LF\";\n  EndOfLineSequence2[EndOfLineSequence2[\"CRLF\"] = 1] = \"CRLF\";\n})(EndOfLineSequence || (EndOfLineSequence = {}));\nvar GlyphMarginLane;\n(function(GlyphMarginLane3) {\n  GlyphMarginLane3[GlyphMarginLane3[\"Left\"] = 1] = \"Left\";\n  GlyphMarginLane3[GlyphMarginLane3[\"Right\"] = 2] = \"Right\";\n})(GlyphMarginLane || (GlyphMarginLane = {}));\nvar IndentAction;\n(function(IndentAction2) {\n  IndentAction2[IndentAction2[\"None\"] = 0] = \"None\";\n  IndentAction2[IndentAction2[\"Indent\"] = 1] = \"Indent\";\n  IndentAction2[IndentAction2[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n  IndentAction2[IndentAction2[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\nvar InjectedTextCursorStops;\n(function(InjectedTextCursorStops3) {\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Both\"] = 0] = \"Both\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Right\"] = 1] = \"Right\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Left\"] = 2] = \"Left\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nvar InlayHintKind2;\n(function(InlayHintKind3) {\n  InlayHintKind3[InlayHintKind3[\"Type\"] = 1] = \"Type\";\n  InlayHintKind3[InlayHintKind3[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind2 || (InlayHintKind2 = {}));\nvar InlineCompletionTriggerKind2;\n(function(InlineCompletionTriggerKind3) {\n  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3[\"Automatic\"] = 0] = \"Automatic\";\n  InlineCompletionTriggerKind3[InlineCompletionTriggerKind3[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));\nvar KeyCode;\n(function(KeyCode2) {\n  KeyCode2[KeyCode2[\"DependsOnKbLayout\"] = -1] = \"DependsOnKbLayout\";\n  KeyCode2[KeyCode2[\"Unknown\"] = 0] = \"Unknown\";\n  KeyCode2[KeyCode2[\"Backspace\"] = 1] = \"Backspace\";\n  KeyCode2[KeyCode2[\"Tab\"] = 2] = \"Tab\";\n  KeyCode2[KeyCode2[\"Enter\"] = 3] = \"Enter\";\n  KeyCode2[KeyCode2[\"Shift\"] = 4] = \"Shift\";\n  KeyCode2[KeyCode2[\"Ctrl\"] = 5] = \"Ctrl\";\n  KeyCode2[KeyCode2[\"Alt\"] = 6] = \"Alt\";\n  KeyCode2[KeyCode2[\"PauseBreak\"] = 7] = \"PauseBreak\";\n  KeyCode2[KeyCode2[\"CapsLock\"] = 8] = \"CapsLock\";\n  KeyCode2[KeyCode2[\"Escape\"] = 9] = \"Escape\";\n  KeyCode2[KeyCode2[\"Space\"] = 10] = \"Space\";\n  KeyCode2[KeyCode2[\"PageUp\"] = 11] = \"PageUp\";\n  KeyCode2[KeyCode2[\"PageDown\"] = 12] = \"PageDown\";\n  KeyCode2[KeyCode2[\"End\"] = 13] = \"End\";\n  KeyCode2[KeyCode2[\"Home\"] = 14] = \"Home\";\n  KeyCode2[KeyCode2[\"LeftArrow\"] = 15] = \"LeftArrow\";\n  KeyCode2[KeyCode2[\"UpArrow\"] = 16] = \"UpArrow\";\n  KeyCode2[KeyCode2[\"RightArrow\"] = 17] = \"RightArrow\";\n  KeyCode2[KeyCode2[\"DownArrow\"] = 18] = \"DownArrow\";\n  KeyCode2[KeyCode2[\"Insert\"] = 19] = \"Insert\";\n  KeyCode2[KeyCode2[\"Delete\"] = 20] = \"Delete\";\n  KeyCode2[KeyCode2[\"Digit0\"] = 21] = \"Digit0\";\n  KeyCode2[KeyCode2[\"Digit1\"] = 22] = \"Digit1\";\n  KeyCode2[KeyCode2[\"Digit2\"] = 23] = \"Digit2\";\n  KeyCode2[KeyCode2[\"Digit3\"] = 24] = \"Digit3\";\n  KeyCode2[KeyCode2[\"Digit4\"] = 25] = \"Digit4\";\n  KeyCode2[KeyCode2[\"Digit5\"] = 26] = \"Digit5\";\n  KeyCode2[KeyCode2[\"Digit6\"] = 27] = \"Digit6\";\n  KeyCode2[KeyCode2[\"Digit7\"] = 28] = \"Digit7\";\n  KeyCode2[KeyCode2[\"Digit8\"] = 29] = \"Digit8\";\n  KeyCode2[KeyCode2[\"Digit9\"] = 30] = \"Digit9\";\n  KeyCode2[KeyCode2[\"KeyA\"] = 31] = \"KeyA\";\n  KeyCode2[KeyCode2[\"KeyB\"] = 32] = \"KeyB\";\n  KeyCode2[KeyCode2[\"KeyC\"] = 33] = \"KeyC\";\n  KeyCode2[KeyCode2[\"KeyD\"] = 34] = \"KeyD\";\n  KeyCode2[KeyCode2[\"KeyE\"] = 35] = \"KeyE\";\n  KeyCode2[KeyCode2[\"KeyF\"] = 36] = \"KeyF\";\n  KeyCode2[KeyCode2[\"KeyG\"] = 37] = \"KeyG\";\n  KeyCode2[KeyCode2[\"KeyH\"] = 38] = \"KeyH\";\n  KeyCode2[KeyCode2[\"KeyI\"] = 39] = \"KeyI\";\n  KeyCode2[KeyCode2[\"KeyJ\"] = 40] = \"KeyJ\";\n  KeyCode2[KeyCode2[\"KeyK\"] = 41] = \"KeyK\";\n  KeyCode2[KeyCode2[\"KeyL\"] = 42] = \"KeyL\";\n  KeyCode2[KeyCode2[\"KeyM\"] = 43] = \"KeyM\";\n  KeyCode2[KeyCode2[\"KeyN\"] = 44] = \"KeyN\";\n  KeyCode2[KeyCode2[\"KeyO\"] = 45] = \"KeyO\";\n  KeyCode2[KeyCode2[\"KeyP\"] = 46] = \"KeyP\";\n  KeyCode2[KeyCode2[\"KeyQ\"] = 47] = \"KeyQ\";\n  KeyCode2[KeyCode2[\"KeyR\"] = 48] = \"KeyR\";\n  KeyCode2[KeyCode2[\"KeyS\"] = 49] = \"KeyS\";\n  KeyCode2[KeyCode2[\"KeyT\"] = 50] = \"KeyT\";\n  KeyCode2[KeyCode2[\"KeyU\"] = 51] = \"KeyU\";\n  KeyCode2[KeyCode2[\"KeyV\"] = 52] = \"KeyV\";\n  KeyCode2[KeyCode2[\"KeyW\"] = 53] = \"KeyW\";\n  KeyCode2[KeyCode2[\"KeyX\"] = 54] = \"KeyX\";\n  KeyCode2[KeyCode2[\"KeyY\"] = 55] = \"KeyY\";\n  KeyCode2[KeyCode2[\"KeyZ\"] = 56] = \"KeyZ\";\n  KeyCode2[KeyCode2[\"Meta\"] = 57] = \"Meta\";\n  KeyCode2[KeyCode2[\"ContextMenu\"] = 58] = \"ContextMenu\";\n  KeyCode2[KeyCode2[\"F1\"] = 59] = \"F1\";\n  KeyCode2[KeyCode2[\"F2\"] = 60] = \"F2\";\n  KeyCode2[KeyCode2[\"F3\"] = 61] = \"F3\";\n  KeyCode2[KeyCode2[\"F4\"] = 62] = \"F4\";\n  KeyCode2[KeyCode2[\"F5\"] = 63] = \"F5\";\n  KeyCode2[KeyCode2[\"F6\"] = 64] = \"F6\";\n  KeyCode2[KeyCode2[\"F7\"] = 65] = \"F7\";\n  KeyCode2[KeyCode2[\"F8\"] = 66] = \"F8\";\n  KeyCode2[KeyCode2[\"F9\"] = 67] = \"F9\";\n  KeyCode2[KeyCode2[\"F10\"] = 68] = \"F10\";\n  KeyCode2[KeyCode2[\"F11\"] = 69] = \"F11\";\n  KeyCode2[KeyCode2[\"F12\"] = 70] = \"F12\";\n  KeyCode2[KeyCode2[\"F13\"] = 71] = \"F13\";\n  KeyCode2[KeyCode2[\"F14\"] = 72] = \"F14\";\n  KeyCode2[KeyCode2[\"F15\"] = 73] = \"F15\";\n  KeyCode2[KeyCode2[\"F16\"] = 74] = \"F16\";\n  KeyCode2[KeyCode2[\"F17\"] = 75] = \"F17\";\n  KeyCode2[KeyCode2[\"F18\"] = 76] = \"F18\";\n  KeyCode2[KeyCode2[\"F19\"] = 77] = \"F19\";\n  KeyCode2[KeyCode2[\"F20\"] = 78] = \"F20\";\n  KeyCode2[KeyCode2[\"F21\"] = 79] = \"F21\";\n  KeyCode2[KeyCode2[\"F22\"] = 80] = \"F22\";\n  KeyCode2[KeyCode2[\"F23\"] = 81] = \"F23\";\n  KeyCode2[KeyCode2[\"F24\"] = 82] = \"F24\";\n  KeyCode2[KeyCode2[\"NumLock\"] = 83] = \"NumLock\";\n  KeyCode2[KeyCode2[\"ScrollLock\"] = 84] = \"ScrollLock\";\n  KeyCode2[KeyCode2[\"Semicolon\"] = 85] = \"Semicolon\";\n  KeyCode2[KeyCode2[\"Equal\"] = 86] = \"Equal\";\n  KeyCode2[KeyCode2[\"Comma\"] = 87] = \"Comma\";\n  KeyCode2[KeyCode2[\"Minus\"] = 88] = \"Minus\";\n  KeyCode2[KeyCode2[\"Period\"] = 89] = \"Period\";\n  KeyCode2[KeyCode2[\"Slash\"] = 90] = \"Slash\";\n  KeyCode2[KeyCode2[\"Backquote\"] = 91] = \"Backquote\";\n  KeyCode2[KeyCode2[\"BracketLeft\"] = 92] = \"BracketLeft\";\n  KeyCode2[KeyCode2[\"Backslash\"] = 93] = \"Backslash\";\n  KeyCode2[KeyCode2[\"BracketRight\"] = 94] = \"BracketRight\";\n  KeyCode2[KeyCode2[\"Quote\"] = 95] = \"Quote\";\n  KeyCode2[KeyCode2[\"OEM_8\"] = 96] = \"OEM_8\";\n  KeyCode2[KeyCode2[\"IntlBackslash\"] = 97] = \"IntlBackslash\";\n  KeyCode2[KeyCode2[\"Numpad0\"] = 98] = \"Numpad0\";\n  KeyCode2[KeyCode2[\"Numpad1\"] = 99] = \"Numpad1\";\n  KeyCode2[KeyCode2[\"Numpad2\"] = 100] = \"Numpad2\";\n  KeyCode2[KeyCode2[\"Numpad3\"] = 101] = \"Numpad3\";\n  KeyCode2[KeyCode2[\"Numpad4\"] = 102] = \"Numpad4\";\n  KeyCode2[KeyCode2[\"Numpad5\"] = 103] = \"Numpad5\";\n  KeyCode2[KeyCode2[\"Numpad6\"] = 104] = \"Numpad6\";\n  KeyCode2[KeyCode2[\"Numpad7\"] = 105] = \"Numpad7\";\n  KeyCode2[KeyCode2[\"Numpad8\"] = 106] = \"Numpad8\";\n  KeyCode2[KeyCode2[\"Numpad9\"] = 107] = \"Numpad9\";\n  KeyCode2[KeyCode2[\"NumpadMultiply\"] = 108] = \"NumpadMultiply\";\n  KeyCode2[KeyCode2[\"NumpadAdd\"] = 109] = \"NumpadAdd\";\n  KeyCode2[KeyCode2[\"NUMPAD_SEPARATOR\"] = 110] = \"NUMPAD_SEPARATOR\";\n  KeyCode2[KeyCode2[\"NumpadSubtract\"] = 111] = \"NumpadSubtract\";\n  KeyCode2[KeyCode2[\"NumpadDecimal\"] = 112] = \"NumpadDecimal\";\n  KeyCode2[KeyCode2[\"NumpadDivide\"] = 113] = \"NumpadDivide\";\n  KeyCode2[KeyCode2[\"KEY_IN_COMPOSITION\"] = 114] = \"KEY_IN_COMPOSITION\";\n  KeyCode2[KeyCode2[\"ABNT_C1\"] = 115] = \"ABNT_C1\";\n  KeyCode2[KeyCode2[\"ABNT_C2\"] = 116] = \"ABNT_C2\";\n  KeyCode2[KeyCode2[\"AudioVolumeMute\"] = 117] = \"AudioVolumeMute\";\n  KeyCode2[KeyCode2[\"AudioVolumeUp\"] = 118] = \"AudioVolumeUp\";\n  KeyCode2[KeyCode2[\"AudioVolumeDown\"] = 119] = \"AudioVolumeDown\";\n  KeyCode2[KeyCode2[\"BrowserSearch\"] = 120] = \"BrowserSearch\";\n  KeyCode2[KeyCode2[\"BrowserHome\"] = 121] = \"BrowserHome\";\n  KeyCode2[KeyCode2[\"BrowserBack\"] = 122] = \"BrowserBack\";\n  KeyCode2[KeyCode2[\"BrowserForward\"] = 123] = \"BrowserForward\";\n  KeyCode2[KeyCode2[\"MediaTrackNext\"] = 124] = \"MediaTrackNext\";\n  KeyCode2[KeyCode2[\"MediaTrackPrevious\"] = 125] = \"MediaTrackPrevious\";\n  KeyCode2[KeyCode2[\"MediaStop\"] = 126] = \"MediaStop\";\n  KeyCode2[KeyCode2[\"MediaPlayPause\"] = 127] = \"MediaPlayPause\";\n  KeyCode2[KeyCode2[\"LaunchMediaPlayer\"] = 128] = \"LaunchMediaPlayer\";\n  KeyCode2[KeyCode2[\"LaunchMail\"] = 129] = \"LaunchMail\";\n  KeyCode2[KeyCode2[\"LaunchApp2\"] = 130] = \"LaunchApp2\";\n  KeyCode2[KeyCode2[\"Clear\"] = 131] = \"Clear\";\n  KeyCode2[KeyCode2[\"MAX_VALUE\"] = 132] = \"MAX_VALUE\";\n})(KeyCode || (KeyCode = {}));\nvar MarkerSeverity;\n(function(MarkerSeverity2) {\n  MarkerSeverity2[MarkerSeverity2[\"Hint\"] = 1] = \"Hint\";\n  MarkerSeverity2[MarkerSeverity2[\"Info\"] = 2] = \"Info\";\n  MarkerSeverity2[MarkerSeverity2[\"Warning\"] = 4] = \"Warning\";\n  MarkerSeverity2[MarkerSeverity2[\"Error\"] = 8] = \"Error\";\n})(MarkerSeverity || (MarkerSeverity = {}));\nvar MarkerTag;\n(function(MarkerTag2) {\n  MarkerTag2[MarkerTag2[\"Unnecessary\"] = 1] = \"Unnecessary\";\n  MarkerTag2[MarkerTag2[\"Deprecated\"] = 2] = \"Deprecated\";\n})(MarkerTag || (MarkerTag = {}));\nvar MinimapPosition;\n(function(MinimapPosition3) {\n  MinimapPosition3[MinimapPosition3[\"Inline\"] = 1] = \"Inline\";\n  MinimapPosition3[MinimapPosition3[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {}));\nvar MouseTargetType;\n(function(MouseTargetType2) {\n  MouseTargetType2[MouseTargetType2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  MouseTargetType2[MouseTargetType2[\"TEXTAREA\"] = 1] = \"TEXTAREA\";\n  MouseTargetType2[MouseTargetType2[\"GUTTER_GLYPH_MARGIN\"] = 2] = \"GUTTER_GLYPH_MARGIN\";\n  MouseTargetType2[MouseTargetType2[\"GUTTER_LINE_NUMBERS\"] = 3] = \"GUTTER_LINE_NUMBERS\";\n  MouseTargetType2[MouseTargetType2[\"GUTTER_LINE_DECORATIONS\"] = 4] = \"GUTTER_LINE_DECORATIONS\";\n  MouseTargetType2[MouseTargetType2[\"GUTTER_VIEW_ZONE\"] = 5] = \"GUTTER_VIEW_ZONE\";\n  MouseTargetType2[MouseTargetType2[\"CONTENT_TEXT\"] = 6] = \"CONTENT_TEXT\";\n  MouseTargetType2[MouseTargetType2[\"CONTENT_EMPTY\"] = 7] = \"CONTENT_EMPTY\";\n  MouseTargetType2[MouseTargetType2[\"CONTENT_VIEW_ZONE\"] = 8] = \"CONTENT_VIEW_ZONE\";\n  MouseTargetType2[MouseTargetType2[\"CONTENT_WIDGET\"] = 9] = \"CONTENT_WIDGET\";\n  MouseTargetType2[MouseTargetType2[\"OVERVIEW_RULER\"] = 10] = \"OVERVIEW_RULER\";\n  MouseTargetType2[MouseTargetType2[\"SCROLLBAR\"] = 11] = \"SCROLLBAR\";\n  MouseTargetType2[MouseTargetType2[\"OVERLAY_WIDGET\"] = 12] = \"OVERLAY_WIDGET\";\n  MouseTargetType2[MouseTargetType2[\"OUTSIDE_EDITOR\"] = 13] = \"OUTSIDE_EDITOR\";\n})(MouseTargetType || (MouseTargetType = {}));\nvar OverlayWidgetPositionPreference;\n(function(OverlayWidgetPositionPreference2) {\n  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2[\"TOP_RIGHT_CORNER\"] = 0] = \"TOP_RIGHT_CORNER\";\n  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2[\"BOTTOM_RIGHT_CORNER\"] = 1] = \"BOTTOM_RIGHT_CORNER\";\n  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2[\"TOP_CENTER\"] = 2] = \"TOP_CENTER\";\n})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));\nvar OverviewRulerLane;\n(function(OverviewRulerLane3) {\n  OverviewRulerLane3[OverviewRulerLane3[\"Left\"] = 1] = \"Left\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Center\"] = 2] = \"Center\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Right\"] = 4] = \"Right\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\nvar PositionAffinity;\n(function(PositionAffinity2) {\n  PositionAffinity2[PositionAffinity2[\"Left\"] = 0] = \"Left\";\n  PositionAffinity2[PositionAffinity2[\"Right\"] = 1] = \"Right\";\n  PositionAffinity2[PositionAffinity2[\"None\"] = 2] = \"None\";\n  PositionAffinity2[PositionAffinity2[\"LeftOfInjectedText\"] = 3] = \"LeftOfInjectedText\";\n  PositionAffinity2[PositionAffinity2[\"RightOfInjectedText\"] = 4] = \"RightOfInjectedText\";\n})(PositionAffinity || (PositionAffinity = {}));\nvar RenderLineNumbersType;\n(function(RenderLineNumbersType2) {\n  RenderLineNumbersType2[RenderLineNumbersType2[\"Off\"] = 0] = \"Off\";\n  RenderLineNumbersType2[RenderLineNumbersType2[\"On\"] = 1] = \"On\";\n  RenderLineNumbersType2[RenderLineNumbersType2[\"Relative\"] = 2] = \"Relative\";\n  RenderLineNumbersType2[RenderLineNumbersType2[\"Interval\"] = 3] = \"Interval\";\n  RenderLineNumbersType2[RenderLineNumbersType2[\"Custom\"] = 4] = \"Custom\";\n})(RenderLineNumbersType || (RenderLineNumbersType = {}));\nvar RenderMinimap;\n(function(RenderMinimap2) {\n  RenderMinimap2[RenderMinimap2[\"None\"] = 0] = \"None\";\n  RenderMinimap2[RenderMinimap2[\"Text\"] = 1] = \"Text\";\n  RenderMinimap2[RenderMinimap2[\"Blocks\"] = 2] = \"Blocks\";\n})(RenderMinimap || (RenderMinimap = {}));\nvar ScrollType;\n(function(ScrollType2) {\n  ScrollType2[ScrollType2[\"Smooth\"] = 0] = \"Smooth\";\n  ScrollType2[ScrollType2[\"Immediate\"] = 1] = \"Immediate\";\n})(ScrollType || (ScrollType = {}));\nvar ScrollbarVisibility;\n(function(ScrollbarVisibility2) {\n  ScrollbarVisibility2[ScrollbarVisibility2[\"Auto\"] = 1] = \"Auto\";\n  ScrollbarVisibility2[ScrollbarVisibility2[\"Hidden\"] = 2] = \"Hidden\";\n  ScrollbarVisibility2[ScrollbarVisibility2[\"Visible\"] = 3] = \"Visible\";\n})(ScrollbarVisibility || (ScrollbarVisibility = {}));\nvar SelectionDirection;\n(function(SelectionDirection2) {\n  SelectionDirection2[SelectionDirection2[\"LTR\"] = 0] = \"LTR\";\n  SelectionDirection2[SelectionDirection2[\"RTL\"] = 1] = \"RTL\";\n})(SelectionDirection || (SelectionDirection = {}));\nvar ShowAiIconMode;\n(function(ShowAiIconMode2) {\n  ShowAiIconMode2[\"Off\"] = \"off\";\n  ShowAiIconMode2[\"OnCode\"] = \"onCode\";\n  ShowAiIconMode2[\"On\"] = \"on\";\n})(ShowAiIconMode || (ShowAiIconMode = {}));\nvar SignatureHelpTriggerKind2;\n(function(SignatureHelpTriggerKind3) {\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"Invoke\"] = 1] = \"Invoke\";\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));\nvar SymbolKind;\n(function(SymbolKind3) {\n  SymbolKind3[SymbolKind3[\"File\"] = 0] = \"File\";\n  SymbolKind3[SymbolKind3[\"Module\"] = 1] = \"Module\";\n  SymbolKind3[SymbolKind3[\"Namespace\"] = 2] = \"Namespace\";\n  SymbolKind3[SymbolKind3[\"Package\"] = 3] = \"Package\";\n  SymbolKind3[SymbolKind3[\"Class\"] = 4] = \"Class\";\n  SymbolKind3[SymbolKind3[\"Method\"] = 5] = \"Method\";\n  SymbolKind3[SymbolKind3[\"Property\"] = 6] = \"Property\";\n  SymbolKind3[SymbolKind3[\"Field\"] = 7] = \"Field\";\n  SymbolKind3[SymbolKind3[\"Constructor\"] = 8] = \"Constructor\";\n  SymbolKind3[SymbolKind3[\"Enum\"] = 9] = \"Enum\";\n  SymbolKind3[SymbolKind3[\"Interface\"] = 10] = \"Interface\";\n  SymbolKind3[SymbolKind3[\"Function\"] = 11] = \"Function\";\n  SymbolKind3[SymbolKind3[\"Variable\"] = 12] = \"Variable\";\n  SymbolKind3[SymbolKind3[\"Constant\"] = 13] = \"Constant\";\n  SymbolKind3[SymbolKind3[\"String\"] = 14] = \"String\";\n  SymbolKind3[SymbolKind3[\"Number\"] = 15] = \"Number\";\n  SymbolKind3[SymbolKind3[\"Boolean\"] = 16] = \"Boolean\";\n  SymbolKind3[SymbolKind3[\"Array\"] = 17] = \"Array\";\n  SymbolKind3[SymbolKind3[\"Object\"] = 18] = \"Object\";\n  SymbolKind3[SymbolKind3[\"Key\"] = 19] = \"Key\";\n  SymbolKind3[SymbolKind3[\"Null\"] = 20] = \"Null\";\n  SymbolKind3[SymbolKind3[\"EnumMember\"] = 21] = \"EnumMember\";\n  SymbolKind3[SymbolKind3[\"Struct\"] = 22] = \"Struct\";\n  SymbolKind3[SymbolKind3[\"Event\"] = 23] = \"Event\";\n  SymbolKind3[SymbolKind3[\"Operator\"] = 24] = \"Operator\";\n  SymbolKind3[SymbolKind3[\"TypeParameter\"] = 25] = \"TypeParameter\";\n})(SymbolKind || (SymbolKind = {}));\nvar SymbolTag;\n(function(SymbolTag3) {\n  SymbolTag3[SymbolTag3[\"Deprecated\"] = 1] = \"Deprecated\";\n})(SymbolTag || (SymbolTag = {}));\nvar TextEditorCursorBlinkingStyle;\n(function(TextEditorCursorBlinkingStyle2) {\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Hidden\"] = 0] = \"Hidden\";\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Blink\"] = 1] = \"Blink\";\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Smooth\"] = 2] = \"Smooth\";\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Phase\"] = 3] = \"Phase\";\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Expand\"] = 4] = \"Expand\";\n  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2[\"Solid\"] = 5] = \"Solid\";\n})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));\nvar TextEditorCursorStyle;\n(function(TextEditorCursorStyle2) {\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"Line\"] = 1] = \"Line\";\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"Block\"] = 2] = \"Block\";\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"Underline\"] = 3] = \"Underline\";\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"LineThin\"] = 4] = \"LineThin\";\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"BlockOutline\"] = 5] = \"BlockOutline\";\n  TextEditorCursorStyle2[TextEditorCursorStyle2[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));\nvar TrackedRangeStickiness;\n(function(TrackedRangeStickiness2) {\n  TrackedRangeStickiness2[TrackedRangeStickiness2[\"AlwaysGrowsWhenTypingAtEdges\"] = 0] = \"AlwaysGrowsWhenTypingAtEdges\";\n  TrackedRangeStickiness2[TrackedRangeStickiness2[\"NeverGrowsWhenTypingAtEdges\"] = 1] = \"NeverGrowsWhenTypingAtEdges\";\n  TrackedRangeStickiness2[TrackedRangeStickiness2[\"GrowsOnlyWhenTypingBefore\"] = 2] = \"GrowsOnlyWhenTypingBefore\";\n  TrackedRangeStickiness2[TrackedRangeStickiness2[\"GrowsOnlyWhenTypingAfter\"] = 3] = \"GrowsOnlyWhenTypingAfter\";\n})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));\nvar WrappingIndent;\n(function(WrappingIndent2) {\n  WrappingIndent2[WrappingIndent2[\"None\"] = 0] = \"None\";\n  WrappingIndent2[WrappingIndent2[\"Same\"] = 1] = \"Same\";\n  WrappingIndent2[WrappingIndent2[\"Indent\"] = 2] = \"Indent\";\n  WrappingIndent2[WrappingIndent2[\"DeepIndent\"] = 3] = \"DeepIndent\";\n})(WrappingIndent || (WrappingIndent = {}));\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js\nvar KeyMod = class {\n  static chord(firstPart, secondPart) {\n    return KeyChord(firstPart, secondPart);\n  }\n};\nKeyMod.CtrlCmd = 2048;\nKeyMod.Shift = 1024;\nKeyMod.Alt = 512;\nKeyMod.WinCtrl = 256;\nfunction createMonacoBaseAPI() {\n  return {\n    editor: void 0,\n    // undefined override expected here\n    languages: void 0,\n    // undefined override expected here\n    CancellationTokenSource,\n    Emitter,\n    KeyCode,\n    KeyMod,\n    Position,\n    Range,\n    Selection,\n    SelectionDirection,\n    MarkerSeverity,\n    MarkerTag,\n    Uri: URI,\n    Token\n  };\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js\nvar WordCharacterClassifier = class extends CharacterClassifier {\n  constructor(wordSeparators) {\n    super(\n      0\n      /* WordCharacterClass.Regular */\n    );\n    for (let i = 0, len = wordSeparators.length; i \u003c len; i++) {\n      this.set(\n        wordSeparators.charCodeAt(i),\n        2\n        /* WordCharacterClass.WordSeparator */\n      );\n    }\n    this.set(\n      32,\n      1\n      /* WordCharacterClass.Whitespace */\n    );\n    this.set(\n      9,\n      1\n      /* WordCharacterClass.Whitespace */\n    );\n  }\n};\nfunction once(computeFn) {\n  const cache = {};\n  return (input) =\u003e {\n    if (!cache.hasOwnProperty(input)) {\n      cache[input] = computeFn(input);\n    }\n    return cache[input];\n  };\n}\nvar getMapForWordSeparators = once((input) =\u003e new WordCharacterClassifier(input));\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/model.js\nvar OverviewRulerLane2;\n(function(OverviewRulerLane3) {\n  OverviewRulerLane3[OverviewRulerLane3[\"Left\"] = 1] = \"Left\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Center\"] = 2] = \"Center\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Right\"] = 4] = \"Right\";\n  OverviewRulerLane3[OverviewRulerLane3[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane2 || (OverviewRulerLane2 = {}));\nvar GlyphMarginLane2;\n(function(GlyphMarginLane3) {\n  GlyphMarginLane3[GlyphMarginLane3[\"Left\"] = 1] = \"Left\";\n  GlyphMarginLane3[GlyphMarginLane3[\"Right\"] = 2] = \"Right\";\n})(GlyphMarginLane2 || (GlyphMarginLane2 = {}));\nvar MinimapPosition2;\n(function(MinimapPosition3) {\n  MinimapPosition3[MinimapPosition3[\"Inline\"] = 1] = \"Inline\";\n  MinimapPosition3[MinimapPosition3[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition2 || (MinimapPosition2 = {}));\nvar InjectedTextCursorStops2;\n(function(InjectedTextCursorStops3) {\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Both\"] = 0] = \"Both\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Right\"] = 1] = \"Right\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"Left\"] = 2] = \"Left\";\n  InjectedTextCursorStops3[InjectedTextCursorStops3[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex === 0) {\n    return true;\n  }\n  const charBefore = text.charCodeAt(matchStartIndex - 1);\n  if (wordSeparators.get(charBefore) !== 0) {\n    return true;\n  }\n  if (charBefore === 13 || charBefore === 10) {\n    return true;\n  }\n  if (matchLength \u003e 0) {\n    const firstCharInMatch = text.charCodeAt(matchStartIndex);\n    if (wordSeparators.get(firstCharInMatch) !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex + matchLength === textLength) {\n    return true;\n  }\n  const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n  if (wordSeparators.get(charAfter) !== 0) {\n    return true;\n  }\n  if (charAfter === 13 || charAfter === 10) {\n    return true;\n  }\n  if (matchLength \u003e 0) {\n    const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n    if (wordSeparators.get(lastCharInMatch) !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) \u0026\u0026 rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);\n}\nvar Searcher = class {\n  constructor(wordSeparators, searchRegex) {\n    this._wordSeparators = wordSeparators;\n    this._searchRegex = searchRegex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n  reset(lastIndex) {\n    this._searchRegex.lastIndex = lastIndex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n  next(text) {\n    const textLength = text.length;\n    let m;\n    do {\n      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n        return null;\n      }\n      m = this._searchRegex.exec(text);\n      if (!m) {\n        return null;\n      }\n      const matchStartIndex = m.index;\n      const matchLength = m[0].length;\n      if (matchStartIndex === this._prevMatchStartIndex \u0026\u0026 matchLength === this._prevMatchLength) {\n        if (matchLength === 0) {\n          if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) \u003e 65535) {\n            this._searchRegex.lastIndex += 2;\n          } else {\n            this._searchRegex.lastIndex += 1;\n          }\n          continue;\n        }\n        return null;\n      }\n      this._prevMatchStartIndex = matchStartIndex;\n      this._prevMatchLength = matchLength;\n      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n        return m;\n      }\n    } while (m);\n    return null;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/assert.js\nfunction assertNever(value, message = \"Unreachable\") {\n  throw new Error(message);\n}\nfunction assertFn(condition) {\n  if (!condition()) {\n    debugger;\n    condition();\n    onUnexpectedError(new BugIndicatingError(\"Assertion Failed\"));\n  }\n}\nfunction checkAdjacentItems(items, predicate) {\n  let i = 0;\n  while (i \u003c items.length - 1) {\n    const a2 = items[i];\n    const b = items[i + 1];\n    if (!predicate(a2, b)) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js\nvar UnicodeTextModelHighlighter = class {\n  static computeUnicodeHighlights(model, options, range) {\n    const startLine = range ? range.startLineNumber : 1;\n    const endLine = range ? range.endLineNumber : model.getLineCount();\n    const codePointHighlighter = new CodePointHighlighter(options);\n    const candidates = codePointHighlighter.getCandidateCodePoints();\n    let regex;\n    if (candidates === \"allNonBasicAscii\") {\n      regex = new RegExp(\"[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]\", \"g\");\n    } else {\n      regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, \"g\");\n    }\n    const searcher = new Searcher(null, regex);\n    const ranges = [];\n    let hasMore = false;\n    let m;\n    let ambiguousCharacterCount = 0;\n    let invisibleCharacterCount = 0;\n    let nonBasicAsciiCharacterCount = 0;\n    forLoop:\n      for (let lineNumber = startLine, lineCount = endLine; lineNumber \u003c= lineCount; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const lineLength = lineContent.length;\n        searcher.reset(0);\n        do {\n          m = searcher.next(lineContent);\n          if (m) {\n            let startIndex = m.index;\n            let endIndex = m.index + m[0].length;\n            if (startIndex \u003e 0) {\n              const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n              if (isHighSurrogate(charCodeBefore)) {\n                startIndex--;\n              }\n            }\n            if (endIndex + 1 \u003c lineLength) {\n              const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n              if (isHighSurrogate(charCodeBefore)) {\n                endIndex++;\n              }\n            }\n            const str = lineContent.substring(startIndex, endIndex);\n            let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n            if (word \u0026\u0026 word.endColumn \u003c= startIndex + 1) {\n              word = null;\n            }\n            const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n            if (highlightReason !== 0) {\n              if (highlightReason === 3) {\n                ambiguousCharacterCount++;\n              } else if (highlightReason === 2) {\n                invisibleCharacterCount++;\n              } else if (highlightReason === 1) {\n                nonBasicAsciiCharacterCount++;\n              } else {\n                assertNever(highlightReason);\n              }\n              const MAX_RESULT_LENGTH = 1e3;\n              if (ranges.length \u003e= MAX_RESULT_LENGTH) {\n                hasMore = true;\n                break forLoop;\n              }\n              ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n            }\n          }\n        } while (m);\n      }\n    return {\n      ranges,\n      hasMore,\n      ambiguousCharacterCount,\n      invisibleCharacterCount,\n      nonBasicAsciiCharacterCount\n    };\n  }\n  static computeUnicodeHighlightReason(char, options) {\n    const codePointHighlighter = new CodePointHighlighter(options);\n    const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n    switch (reason) {\n      case 0:\n        return null;\n      case 2:\n        return {\n          kind: 1\n          /* UnicodeHighlighterReasonKind.Invisible */\n        };\n      case 3: {\n        const codePoint = char.codePointAt(0);\n        const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n        const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) =\u003e !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n        return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n      }\n      case 1:\n        return {\n          kind: 2\n          /* UnicodeHighlighterReasonKind.NonBasicAscii */\n        };\n    }\n  }\n};\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n  const src = `[${escapeRegExpCharacters(codePoints.map((i) =\u003e String.fromCodePoint(i)).join(\"\"))}]`;\n  return src;\n}\nvar CodePointHighlighter = class {\n  constructor(options) {\n    this.options = options;\n    this.allowedCodePoints = new Set(options.allowedCodePoints);\n    this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n  }\n  getCandidateCodePoints() {\n    if (this.options.nonBasicASCII) {\n      return \"allNonBasicAscii\";\n    }\n    const set = /* @__PURE__ */ new Set();\n    if (this.options.invisibleCharacters) {\n      for (const cp of InvisibleCharacters.codePoints) {\n        if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n          set.add(cp);\n        }\n      }\n    }\n    if (this.options.ambiguousCharacters) {\n      for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n        set.add(cp);\n      }\n    }\n    for (const cp of this.allowedCodePoints) {\n      set.delete(cp);\n    }\n    return set;\n  }\n  shouldHighlightNonBasicASCII(character, wordContext) {\n    const codePoint = character.codePointAt(0);\n    if (this.allowedCodePoints.has(codePoint)) {\n      return 0;\n    }\n    if (this.options.nonBasicASCII) {\n      return 1;\n    }\n    let hasBasicASCIICharacters = false;\n    let hasNonConfusableNonBasicAsciiCharacter = false;\n    if (wordContext) {\n      for (const char of wordContext) {\n        const codePoint2 = char.codePointAt(0);\n        const isBasicASCII2 = isBasicASCII(char);\n        hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;\n        if (!isBasicASCII2 \u0026\u0026 !this.ambiguousCharacters.isAmbiguous(codePoint2) \u0026\u0026 !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {\n          hasNonConfusableNonBasicAsciiCharacter = true;\n        }\n      }\n    }\n    if (\n      /* Don't allow mixing weird looking characters with ASCII */\n      !hasBasicASCIICharacters \u0026\u0026 /* Is there an obviously weird looking character? */\n      hasNonConfusableNonBasicAsciiCharacter\n    ) {\n      return 0;\n    }\n    if (this.options.invisibleCharacters) {\n      if (!isAllowedInvisibleCharacter(character) \u0026\u0026 InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n        return 2;\n      }\n    }\n    if (this.options.ambiguousCharacters) {\n      if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n        return 3;\n      }\n    }\n    return 0;\n  }\n};\nfunction isAllowedInvisibleCharacter(character) {\n  return character === \" \" || character === \"\\n\" || character === \"\t\";\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js\nvar LinesDiff = class {\n  constructor(changes, moves, hitTimeout) {\n    this.changes = changes;\n    this.moves = moves;\n    this.hitTimeout = hitTimeout;\n  }\n};\nvar MovedText = class {\n  constructor(lineRangeMapping, changes) {\n    this.lineRangeMapping = lineRangeMapping;\n    this.changes = changes;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\nvar OffsetRange = class _OffsetRange {\n  static addRange(range, sortedRanges) {\n    let i = 0;\n    while (i \u003c sortedRanges.length \u0026\u0026 sortedRanges[i].endExclusive \u003c range.start) {\n      i++;\n    }\n    let j = i;\n    while (j \u003c sortedRanges.length \u0026\u0026 sortedRanges[j].start \u003c= range.endExclusive) {\n      j++;\n    }\n    if (i === j) {\n      sortedRanges.splice(i, 0, range);\n    } else {\n      const start = Math.min(range.start, sortedRanges[i].start);\n      const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n      sortedRanges.splice(i, j - i, new _OffsetRange(start, end));\n    }\n  }\n  static tryCreate(start, endExclusive) {\n    if (start \u003e endExclusive) {\n      return void 0;\n    }\n    return new _OffsetRange(start, endExclusive);\n  }\n  static ofLength(length) {\n    return new _OffsetRange(0, length);\n  }\n  static ofStartAndLength(start, length) {\n    return new _OffsetRange(start, start + length);\n  }\n  constructor(start, endExclusive) {\n    this.start = start;\n    this.endExclusive = endExclusive;\n    if (start \u003e endExclusive) {\n      throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n    }\n  }\n  get isEmpty() {\n    return this.start === this.endExclusive;\n  }\n  delta(offset) {\n    return new _OffsetRange(this.start + offset, this.endExclusive + offset);\n  }\n  deltaStart(offset) {\n    return new _OffsetRange(this.start + offset, this.endExclusive);\n  }\n  deltaEnd(offset) {\n    return new _OffsetRange(this.start, this.endExclusive + offset);\n  }\n  get length() {\n    return this.endExclusive - this.start;\n  }\n  toString() {\n    return `[${this.start}, ${this.endExclusive})`;\n  }\n  equals(other) {\n    return this.start === other.start \u0026\u0026 this.endExclusive === other.endExclusive;\n  }\n  containsRange(other) {\n    return this.start \u003c= other.start \u0026\u0026 other.endExclusive \u003c= this.endExclusive;\n  }\n  contains(offset) {\n    return this.start \u003c= offset \u0026\u0026 offset \u003c this.endExclusive;\n  }\n  /**\n   * for all numbers n: range1.contains(n) or range2.contains(n) =\u003e range1.join(range2).contains(n)\n   * The joined range is the smallest range that contains both ranges.\n   */\n  join(other) {\n    return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n  }\n  /**\n   * for all numbers n: range1.contains(n) and range2.contains(n) \u003c=\u003e range1.intersect(range2).contains(n)\n   *\n   * The resulting range is empty if the ranges do not intersect, but touch.\n   * If the ranges don't even touch, the result is undefined.\n   */\n  intersect(other) {\n    const start = Math.max(this.start, other.start);\n    const end = Math.min(this.endExclusive, other.endExclusive);\n    if (start \u003c= end) {\n      return new _OffsetRange(start, end);\n    }\n    return void 0;\n  }\n  isBefore(other) {\n    return this.endExclusive \u003c= other.start;\n  }\n  isAfter(other) {\n    return this.start \u003e= other.endExclusive;\n  }\n  slice(arr) {\n    return arr.slice(this.start, this.endExclusive);\n  }\n  /**\n   * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n   * The range must not be empty.\n   */\n  clip(value) {\n    if (this.isEmpty) {\n      throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n    }\n    return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n  }\n  /**\n   * Returns `r := value + k * length` such that `r` is contained in this range.\n   * The range must not be empty.\n   *\n   * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n   */\n  clipCyclic(value) {\n    if (this.isEmpty) {\n      throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n    }\n    if (value \u003c this.start) {\n      return this.endExclusive - (this.start - value) % this.length;\n    }\n    if (value \u003e= this.endExclusive) {\n      return this.start + (value - this.start) % this.length;\n    }\n    return value;\n  }\n  forEach(f2) {\n    for (let i = this.start; i \u003c this.endExclusive; i++) {\n      f2(i);\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/arraysFind.js\nfunction findLastMonotonous(array, predicate) {\n  const idx = findLastIdxMonotonous(array, predicate);\n  return idx === -1 ? void 0 : array[idx];\n}\nfunction findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n  let i = startIdx;\n  let j = endIdxEx;\n  while (i \u003c j) {\n    const k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      i = k + 1;\n    } else {\n      j = k;\n    }\n  }\n  return i - 1;\n}\nfunction findFirstMonotonous(array, predicate) {\n  const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n  return idx === array.length ? void 0 : array[idx];\n}\nfunction findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\n  let i = startIdx;\n  let j = endIdxEx;\n  while (i \u003c j) {\n    const k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      j = k;\n    } else {\n      i = k + 1;\n    }\n  }\n  return i;\n}\nvar MonotonousArray = class _MonotonousArray {\n  constructor(_array) {\n    this._array = _array;\n    this._findLastMonotonousLastIdx = 0;\n  }\n  /**\n   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n   */\n  findLastMonotonous(predicate) {\n    if (_MonotonousArray.assertInvariants) {\n      if (this._prevFindLastPredicate) {\n        for (const item of this._array) {\n          if (this._prevFindLastPredicate(item) \u0026\u0026 !predicate(item)) {\n            throw new Error(\"MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.\");\n          }\n        }\n      }\n      this._prevFindLastPredicate = predicate;\n    }\n    const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n    this._findLastMonotonousLastIdx = idx + 1;\n    return idx === -1 ? void 0 : this._array[idx];\n  }\n};\nMonotonousArray.assertInvariants = false;\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js\nvar LineRange = class _LineRange {\n  static fromRange(range) {\n    return new _LineRange(range.startLineNumber, range.endLineNumber);\n  }\n  static fromRangeInclusive(range) {\n    return new _LineRange(range.startLineNumber, range.endLineNumber + 1);\n  }\n  /**\n   * @param lineRanges An array of sorted line ranges.\n   */\n  static joinMany(lineRanges) {\n    if (lineRanges.length === 0) {\n      return [];\n    }\n    let result = new LineRangeSet(lineRanges[0].slice());\n    for (let i = 1; i \u003c lineRanges.length; i++) {\n      result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n    }\n    return result.ranges;\n  }\n  static ofLength(startLineNumber, length) {\n    return new _LineRange(startLineNumber, startLineNumber + length);\n  }\n  /**\n   * @internal\n   */\n  static deserialize(lineRange) {\n    return new _LineRange(lineRange[0], lineRange[1]);\n  }\n  constructor(startLineNumber, endLineNumberExclusive) {\n    if (startLineNumber \u003e endLineNumberExclusive) {\n      throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n    }\n    this.startLineNumber = startLineNumber;\n    this.endLineNumberExclusive = endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range contains the given line number.\n   */\n  contains(lineNumber) {\n    return this.startLineNumber \u003c= lineNumber \u0026\u0026 lineNumber \u003c this.endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range is empty.\n   */\n  get isEmpty() {\n    return this.startLineNumber === this.endLineNumberExclusive;\n  }\n  /**\n   * Moves this line range by the given offset of line numbers.\n   */\n  delta(offset) {\n    return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n  }\n  deltaLength(offset) {\n    return new _LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n  }\n  /**\n   * The number of lines this line range spans.\n   */\n  get length() {\n    return this.endLineNumberExclusive - this.startLineNumber;\n  }\n  /**\n   * Creates a line range that combines this and the given line range.\n   */\n  join(other) {\n    return new _LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n  }\n  toString() {\n    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n  }\n  /**\n   * The resulting range is empty if the ranges do not intersect, but touch.\n   * If the ranges don't even touch, the result is undefined.\n   */\n  intersect(other) {\n    const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n    const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n    if (startLineNumber \u003c= endLineNumberExclusive) {\n      return new _LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    return void 0;\n  }\n  intersectsStrict(other) {\n    return this.startLineNumber \u003c other.endLineNumberExclusive \u0026\u0026 other.startLineNumber \u003c this.endLineNumberExclusive;\n  }\n  overlapOrTouch(other) {\n    return this.startLineNumber \u003c= other.endLineNumberExclusive \u0026\u0026 other.startLineNumber \u003c= this.endLineNumberExclusive;\n  }\n  equals(b) {\n    return this.startLineNumber === b.startLineNumber \u0026\u0026 this.endLineNumberExclusive === b.endLineNumberExclusive;\n  }\n  toInclusiveRange() {\n    if (this.isEmpty) {\n      return null;\n    }\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n  }\n  toExclusiveRange() {\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n  }\n  mapToLineArray(f2) {\n    const result = [];\n    for (let lineNumber = this.startLineNumber; lineNumber \u003c this.endLineNumberExclusive; lineNumber++) {\n      result.push(f2(lineNumber));\n    }\n    return result;\n  }\n  forEach(f2) {\n    for (let lineNumber = this.startLineNumber; lineNumber \u003c this.endLineNumberExclusive; lineNumber++) {\n      f2(lineNumber);\n    }\n  }\n  /**\n   * @internal\n   */\n  serialize() {\n    return [this.startLineNumber, this.endLineNumberExclusive];\n  }\n  includes(lineNumber) {\n    return this.startLineNumber \u003c= lineNumber \u0026\u0026 lineNumber \u003c this.endLineNumberExclusive;\n  }\n  /**\n   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n   * @internal\n   */\n  toOffsetRange() {\n    return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n  }\n};\nvar LineRangeSet = class _LineRangeSet {\n  constructor(_normalizedRanges = []) {\n    this._normalizedRanges = _normalizedRanges;\n  }\n  get ranges() {\n    return this._normalizedRanges;\n  }\n  addRange(range) {\n    if (range.length === 0) {\n      return;\n    }\n    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) =\u003e r.endLineNumberExclusive \u003e= range.startLineNumber);\n    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) =\u003e r.startLineNumber \u003c= range.endLineNumberExclusive) + 1;\n    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n      this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n    } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n      const joinRange = this._normalizedRanges[joinRangeStartIdx];\n      this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n    } else {\n      const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n      this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n    }\n  }\n  contains(lineNumber) {\n    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) =\u003e r.startLineNumber \u003c= lineNumber);\n    return !!rangeThatStartsBeforeEnd \u0026\u0026 rangeThatStartsBeforeEnd.endLineNumberExclusive \u003e lineNumber;\n  }\n  intersects(range) {\n    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) =\u003e r.startLineNumber \u003c range.endLineNumberExclusive);\n    return !!rangeThatStartsBeforeEnd \u0026\u0026 rangeThatStartsBeforeEnd.endLineNumberExclusive \u003e range.startLineNumber;\n  }\n  getUnion(other) {\n    if (this._normalizedRanges.length === 0) {\n      return other;\n    }\n    if (other._normalizedRanges.length === 0) {\n      return this;\n    }\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    let current = null;\n    while (i1 \u003c this._normalizedRanges.length || i2 \u003c other._normalizedRanges.length) {\n      let next = null;\n      if (i1 \u003c this._normalizedRanges.length \u0026\u0026 i2 \u003c other._normalizedRanges.length) {\n        const lineRange1 = this._normalizedRanges[i1];\n        const lineRange2 = other._normalizedRanges[i2];\n        if (lineRange1.startLineNumber \u003c lineRange2.startLineNumber) {\n          next = lineRange1;\n          i1++;\n        } else {\n          next = lineRange2;\n          i2++;\n        }\n      } else if (i1 \u003c this._normalizedRanges.length) {\n        next = this._normalizedRanges[i1];\n        i1++;\n      } else {\n        next = other._normalizedRanges[i2];\n        i2++;\n      }\n      if (current === null) {\n        current = next;\n      } else {\n        if (current.endLineNumberExclusive \u003e= next.startLineNumber) {\n          current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n        } else {\n          result.push(current);\n          current = next;\n        }\n      }\n    }\n    if (current !== null) {\n      result.push(current);\n    }\n    return new _LineRangeSet(result);\n  }\n  /**\n   * Subtracts all ranges in this set from `range` and returns the result.\n   */\n  subtractFrom(range) {\n    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) =\u003e r.endLineNumberExclusive \u003e= range.startLineNumber);\n    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) =\u003e r.startLineNumber \u003c= range.endLineNumberExclusive) + 1;\n    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n      return new _LineRangeSet([range]);\n    }\n    const result = [];\n    let startLineNumber = range.startLineNumber;\n    for (let i = joinRangeStartIdx; i \u003c joinRangeEndIdxExclusive; i++) {\n      const r = this._normalizedRanges[i];\n      if (r.startLineNumber \u003e startLineNumber) {\n        result.push(new LineRange(startLineNumber, r.startLineNumber));\n      }\n      startLineNumber = r.endLineNumberExclusive;\n    }\n    if (startLineNumber \u003c range.endLineNumberExclusive) {\n      result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n    }\n    return new _LineRangeSet(result);\n  }\n  toString() {\n    return this._normalizedRanges.map((r) =\u003e r.toString()).join(\", \");\n  }\n  getIntersection(other) {\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    while (i1 \u003c this._normalizedRanges.length \u0026\u0026 i2 \u003c other._normalizedRanges.length) {\n      const r1 = this._normalizedRanges[i1];\n      const r2 = other._normalizedRanges[i2];\n      const i = r1.intersect(r2);\n      if (i \u0026\u0026 !i.isEmpty) {\n        result.push(i);\n      }\n      if (r1.endLineNumberExclusive \u003c r2.endLineNumberExclusive) {\n        i1++;\n      } else {\n        i2++;\n      }\n    }\n    return new _LineRangeSet(result);\n  }\n  getWithDelta(value) {\n    return new _LineRangeSet(this._normalizedRanges.map((r) =\u003e r.delta(value)));\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js\nvar LineRangeMapping = class _LineRangeMapping {\n  static inverse(mapping, originalLineCount, modifiedLineCount) {\n    const result = [];\n    let lastOriginalEndLineNumber = 1;\n    let lastModifiedEndLineNumber = 1;\n    for (const m of mapping) {\n      const r2 = new DetailedLineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber), void 0);\n      if (!r2.modified.isEmpty) {\n        result.push(r2);\n      }\n      lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n      lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n    }\n    const r = new DetailedLineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), void 0);\n    if (!r.modified.isEmpty) {\n      result.push(r);\n    }\n    return result;\n  }\n  constructor(originalRange, modifiedRange) {\n    this.original = originalRange;\n    this.modified = modifiedRange;\n  }\n  toString() {\n    return `{${this.original.toString()}-\u003e${this.modified.toString()}}`;\n  }\n  flip() {\n    return new _LineRangeMapping(this.modified, this.original);\n  }\n  join(other) {\n    return new _LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n  }\n};\nvar DetailedLineRangeMapping = class _DetailedLineRangeMapping extends LineRangeMapping {\n  constructor(originalRange, modifiedRange, innerChanges) {\n    super(originalRange, modifiedRange);\n    this.innerChanges = innerChanges;\n  }\n  flip() {\n    var _a4;\n    return new _DetailedLineRangeMapping(this.modified, this.original, (_a4 = this.innerChanges) === null || _a4 === void 0 ? void 0 : _a4.map((c) =\u003e c.flip()));\n  }\n};\nvar RangeMapping = class _RangeMapping {\n  constructor(originalRange, modifiedRange) {\n    this.originalRange = originalRange;\n    this.modifiedRange = modifiedRange;\n  }\n  toString() {\n    return `{${this.originalRange.toString()}-\u003e${this.modifiedRange.toString()}}`;\n  }\n  flip() {\n    return new _RangeMapping(this.modifiedRange, this.originalRange);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js\nvar MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nvar LegacyLinesDiffComputer = class {\n  computeDiff(originalLines, modifiedLines, options) {\n    var _a4;\n    const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n      maxComputationTime: options.maxComputationTimeMs,\n      shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n      shouldComputeCharChanges: true,\n      shouldMakePrettyDiff: true,\n      shouldPostProcessCharChanges: true\n    });\n    const result = diffComputer.computeDiff();\n    const changes = [];\n    let lastChange = null;\n    for (const c of result.changes) {\n      let originalRange;\n      if (c.originalEndLineNumber === 0) {\n        originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n      } else {\n        originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n      }\n      let modifiedRange;\n      if (c.modifiedEndLineNumber === 0) {\n        modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n      } else {\n        modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n      }\n      let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a4 = c.charChanges) === null || _a4 === void 0 ? void 0 : _a4.map((c2) =\u003e new RangeMapping(new Range(c2.originalStartLineNumber, c2.originalStartColumn, c2.originalEndLineNumber, c2.originalEndColumn), new Range(c2.modifiedStartLineNumber, c2.modifiedStartColumn, c2.modifiedEndLineNumber, c2.modifiedEndColumn))));\n      if (lastChange) {\n        if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n          change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges \u0026\u0026 change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);\n          changes.pop();\n        }\n      }\n      changes.push(change);\n      lastChange = change;\n    }\n    assertFn(() =\u003e {\n      return checkAdjacentItems(changes, (m1, m2) =\u003e m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive \u0026\u0026 // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n      m1.original.endLineNumberExclusive \u003c m2.original.startLineNumber \u0026\u0026 m1.modified.endLineNumberExclusive \u003c m2.modified.startLineNumber);\n    });\n    return new LinesDiff(changes, [], result.quitEarly);\n  }\n};\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n  return diffAlgo.ComputeDiff(pretty);\n}\nvar LineSequence = class {\n  constructor(lines) {\n    const startColumns = [];\n    const endColumns = [];\n    for (let i = 0, length = lines.length; i \u003c length; i++) {\n      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n      endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n    }\n    this.lines = lines;\n    this._startColumns = startColumns;\n    this._endColumns = endColumns;\n  }\n  getElements() {\n    const elements = [];\n    for (let i = 0, len = this.lines.length; i \u003c len; i++) {\n      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n    }\n    return elements;\n  }\n  getStrictElement(index) {\n    return this.lines[index];\n  }\n  getStartLineNumber(i) {\n    return i + 1;\n  }\n  getEndLineNumber(i) {\n    return i + 1;\n  }\n  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n    const charCodes = [];\n    const lineNumbers = [];\n    const columns = [];\n    let len = 0;\n    for (let index = startIndex; index \u003c= endIndex; index++) {\n      const lineContent = this.lines[index];\n      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;\n      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;\n      for (let col = startColumn; col \u003c endColumn; col++) {\n        charCodes[len] = lineContent.charCodeAt(col - 1);\n        lineNumbers[len] = index + 1;\n        columns[len] = col;\n        len++;\n      }\n      if (!shouldIgnoreTrimWhitespace \u0026\u0026 index \u003c endIndex) {\n        charCodes[len] = 10;\n        lineNumbers[len] = index + 1;\n        columns[len] = lineContent.length + 1;\n        len++;\n      }\n    }\n    return new CharSequence(charCodes, lineNumbers, columns);\n  }\n};\nvar CharSequence = class {\n  constructor(charCodes, lineNumbers, columns) {\n    this._charCodes = charCodes;\n    this._lineNumbers = lineNumbers;\n    this._columns = columns;\n  }\n  toString() {\n    return \"[\" + this._charCodes.map((s, idx) =\u003e (s === 10 ? \"\\\\n\" : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(\", \") + \"]\";\n  }\n  _assertIndex(index, arr) {\n    if (index \u003c 0 || index \u003e= arr.length) {\n      throw new Error(`Illegal index`);\n    }\n  }\n  getElements() {\n    return this._charCodes;\n  }\n  getStartLineNumber(i) {\n    if (i \u003e 0 \u0026\u0026 i === this._lineNumbers.length) {\n      return this.getEndLineNumber(i - 1);\n    }\n    this._assertIndex(i, this._lineNumbers);\n    return this._lineNumbers[i];\n  }\n  getEndLineNumber(i) {\n    if (i === -1) {\n      return this.getStartLineNumber(i + 1);\n    }\n    this._assertIndex(i, this._lineNumbers);\n    if (this._charCodes[i] === 10) {\n      return this._lineNumbers[i] + 1;\n    }\n    return this._lineNumbers[i];\n  }\n  getStartColumn(i) {\n    if (i \u003e 0 \u0026\u0026 i === this._columns.length) {\n      return this.getEndColumn(i - 1);\n    }\n    this._assertIndex(i, this._columns);\n    return this._columns[i];\n  }\n  getEndColumn(i) {\n    if (i === -1) {\n      return this.getStartColumn(i + 1);\n    }\n    this._assertIndex(i, this._columns);\n    if (this._charCodes[i] === 10) {\n      return 1;\n    }\n    return this._columns[i] + 1;\n  }\n};\nvar CharChange = class _CharChange {\n  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalStartColumn = originalStartColumn;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.originalEndColumn = originalEndColumn;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedStartColumn = modifiedStartColumn;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.modifiedEndColumn = modifiedEndColumn;\n  }\n  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n    const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n    const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n    const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n    const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n    const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n    const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n    const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n  }\n};\nfunction postProcessCharChanges(rawChanges) {\n  if (rawChanges.length \u003c= 1) {\n    return rawChanges;\n  }\n  const result = [rawChanges[0]];\n  let prevChange = result[0];\n  for (let i = 1, len = rawChanges.length; i \u003c len; i++) {\n    const currChange = rawChanges[i];\n    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n    if (matchingLength \u003c MINIMUM_MATCHING_CHARACTER_LENGTH) {\n      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;\n      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;\n    } else {\n      result.push(currChange);\n      prevChange = currChange;\n    }\n  }\n  return result;\n}\nvar LineChange = class _LineChange {\n  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.charChanges = charChanges;\n  }\n  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n    let originalStartLineNumber;\n    let originalEndLineNumber;\n    let modifiedStartLineNumber;\n    let modifiedEndLineNumber;\n    let charChanges = void 0;\n    if (diffChange.originalLength === 0) {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n      originalEndLineNumber = 0;\n    } else {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n    }\n    if (diffChange.modifiedLength === 0) {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n      modifiedEndLineNumber = 0;\n    } else {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    }\n    if (shouldComputeCharChanges \u0026\u0026 diffChange.originalLength \u003e 0 \u0026\u0026 diffChange.originalLength \u003c 20 \u0026\u0026 diffChange.modifiedLength \u003e 0 \u0026\u0026 diffChange.modifiedLength \u003c 20 \u0026\u0026 continueCharDiff()) {\n      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      if (originalCharSequence.getElements().length \u003e 0 \u0026\u0026 modifiedCharSequence.getElements().length \u003e 0) {\n        let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n        if (shouldPostProcessCharChanges) {\n          rawChanges = postProcessCharChanges(rawChanges);\n        }\n        charChanges = [];\n        for (let i = 0, length = rawChanges.length; i \u003c length; i++) {\n          charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n        }\n      }\n    }\n    return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n  }\n};\nvar DiffComputer = class {\n  constructor(originalLines, modifiedLines, opts) {\n    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n    this.originalLines = originalLines;\n    this.modifiedLines = modifiedLines;\n    this.original = new LineSequence(originalLines);\n    this.modified = new LineSequence(modifiedLines);\n    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));\n  }\n  computeDiff() {\n    if (this.original.lines.length === 1 \u0026\u0026 this.original.lines[0].length === 0) {\n      if (this.modified.lines.length === 1 \u0026\u0026 this.modified.lines[0].length === 0) {\n        return {\n          quitEarly: false,\n          changes: []\n        };\n      }\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: 1,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: this.modified.lines.length,\n          charChanges: void 0\n        }]\n      };\n    }\n    if (this.modified.lines.length === 1 \u0026\u0026 this.modified.lines[0].length === 0) {\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: this.original.lines.length,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: 1,\n          charChanges: void 0\n        }]\n      };\n    }\n    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n    const rawChanges = diffResult.changes;\n    const quitEarly = diffResult.quitEarly;\n    if (this.shouldIgnoreTrimWhitespace) {\n      const lineChanges = [];\n      for (let i = 0, length = rawChanges.length; i \u003c length; i++) {\n        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n      }\n      return {\n        quitEarly,\n        changes: lineChanges\n      };\n    }\n    const result = [];\n    let originalLineIndex = 0;\n    let modifiedLineIndex = 0;\n    for (let i = -1, len = rawChanges.length; i \u003c len; i++) {\n      const nextChange = i + 1 \u003c len ? rawChanges[i + 1] : null;\n      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;\n      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;\n      while (originalLineIndex \u003c originalStop \u0026\u0026 modifiedLineIndex \u003c modifiedStop) {\n        const originalLine = this.originalLines[originalLineIndex];\n        const modifiedLine = this.modifiedLines[modifiedLineIndex];\n        if (originalLine !== modifiedLine) {\n          {\n            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n            while (originalStartColumn \u003e 1 \u0026\u0026 modifiedStartColumn \u003e 1) {\n              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n              originalStartColumn--;\n              modifiedStartColumn--;\n            }\n            if (originalStartColumn \u003e 1 || modifiedStartColumn \u003e 1) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n            }\n          }\n          {\n            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n            const originalMaxColumn = originalLine.length + 1;\n            const modifiedMaxColumn = modifiedLine.length + 1;\n            while (originalEndColumn \u003c originalMaxColumn \u0026\u0026 modifiedEndColumn \u003c modifiedMaxColumn) {\n              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n              originalEndColumn++;\n              modifiedEndColumn++;\n            }\n            if (originalEndColumn \u003c originalMaxColumn || modifiedEndColumn \u003c modifiedMaxColumn) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n            }\n          }\n        }\n        originalLineIndex++;\n        modifiedLineIndex++;\n      }\n      if (nextChange) {\n        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n        originalLineIndex += nextChange.originalLength;\n        modifiedLineIndex += nextChange.modifiedLength;\n      }\n    }\n    return {\n      quitEarly,\n      changes: result\n    };\n  }\n  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n      return;\n    }\n    let charChanges = void 0;\n    if (this.shouldComputeCharChanges) {\n      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n    }\n    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n  }\n  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    const len = result.length;\n    if (len === 0) {\n      return false;\n    }\n    const prevChange = result[len - 1];\n    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n      return false;\n    }\n    if (prevChange.originalEndLineNumber === originalLineNumber \u0026\u0026 prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n      if (this.shouldComputeCharChanges \u0026\u0026 prevChange.charChanges) {\n        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n      }\n      return true;\n    }\n    if (prevChange.originalEndLineNumber + 1 === originalLineNumber \u0026\u0026 prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n      prevChange.originalEndLineNumber = originalLineNumber;\n      prevChange.modifiedEndLineNumber = modifiedLineNumber;\n      if (this.shouldComputeCharChanges \u0026\u0026 prevChange.charChanges) {\n        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n      }\n      return true;\n    }\n    return false;\n  }\n};\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n  const r = firstNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n  const r = lastNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n  if (maximumRuntime === 0) {\n    return () =\u003e true;\n  }\n  const startTime = Date.now();\n  return () =\u003e {\n    return Date.now() - startTime \u003c maximumRuntime;\n  };\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js\nvar DiffAlgorithmResult = class _DiffAlgorithmResult {\n  static trivial(seq1, seq2) {\n    return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n  }\n  static trivialTimedOut(seq1, seq2) {\n    return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n  }\n  constructor(diffs, hitTimeout) {\n    this.diffs = diffs;\n    this.hitTimeout = hitTimeout;\n  }\n};\nvar SequenceDiff = class _SequenceDiff {\n  static invert(sequenceDiffs, doc1Length) {\n    const result = [];\n    forEachAdjacent(sequenceDiffs, (a2, b) =\u003e {\n      result.push(_SequenceDiff.fromOffsetPairs(a2 ? a2.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a2 ? a2.seq2Range.endExclusive - a2.seq1Range.endExclusive : 0) + doc1Length)));\n    });\n    return result;\n  }\n  static fromOffsetPairs(start, endExclusive) {\n    return new _SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));\n  }\n  constructor(seq1Range, seq2Range) {\n    this.seq1Range = seq1Range;\n    this.seq2Range = seq2Range;\n  }\n  swap() {\n    return new _SequenceDiff(this.seq2Range, this.seq1Range);\n  }\n  toString() {\n    return `${this.seq1Range} \u003c-\u003e ${this.seq2Range}`;\n  }\n  join(other) {\n    return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n  }\n  delta(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n  }\n  deltaStart(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new _SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n  }\n  deltaEnd(offset) {\n    if (offset === 0) {\n      return this;\n    }\n    return new _SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n  }\n  intersect(other) {\n    const i1 = this.seq1Range.intersect(other.seq1Range);\n    const i2 = this.seq2Range.intersect(other.seq2Range);\n    if (!i1 || !i2) {\n      return void 0;\n    }\n    return new _SequenceDiff(i1, i2);\n  }\n  getStarts() {\n    return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n  }\n  getEndExclusives() {\n    return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n  }\n};\nvar OffsetPair = class {\n  constructor(offset1, offset2) {\n    this.offset1 = offset1;\n    this.offset2 = offset2;\n  }\n  toString() {\n    return `${this.offset1} \u003c-\u003e ${this.offset2}`;\n  }\n};\nOffsetPair.zero = new OffsetPair(0, 0);\nOffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\nvar InfiniteTimeout = class {\n  isValid() {\n    return true;\n  }\n};\nInfiniteTimeout.instance = new InfiniteTimeout();\nvar DateTimeout = class {\n  constructor(timeout) {\n    this.timeout = timeout;\n    this.startTime = Date.now();\n    this.valid = true;\n    if (timeout \u003c= 0) {\n      throw new BugIndicatingError(\"timeout must be positive\");\n    }\n  }\n  // Recommendation: Set a log-point `{this.disable()}` in the body\n  isValid() {\n    const valid = Date.now() - this.startTime \u003c this.timeout;\n    if (!valid \u0026\u0026 this.valid) {\n      this.valid = false;\n      debugger;\n    }\n    return this.valid;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js\nvar Array2D = class {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.array = [];\n    this.array = new Array(width * height);\n  }\n  get(x, y) {\n    return this.array[x + y * this.width];\n  }\n  set(x, y, value) {\n    this.array[x + y * this.width] = value;\n  }\n};\nfunction isSpace(charCode) {\n  return charCode === 32 || charCode === 9;\n}\nvar LineRangeFragment = class _LineRangeFragment {\n  static getKey(chr) {\n    let key = this.chrKeys.get(chr);\n    if (key === void 0) {\n      key = this.chrKeys.size;\n      this.chrKeys.set(chr, key);\n    }\n    return key;\n  }\n  constructor(range, lines, source) {\n    this.range = range;\n    this.lines = lines;\n    this.source = source;\n    this.histogram = [];\n    let counter = 0;\n    for (let i = range.startLineNumber - 1; i \u003c range.endLineNumberExclusive - 1; i++) {\n      const line = lines[i];\n      for (let j = 0; j \u003c line.length; j++) {\n        counter++;\n        const chr = line[j];\n        const key2 = _LineRangeFragment.getKey(chr);\n        this.histogram[key2] = (this.histogram[key2] || 0) + 1;\n      }\n      counter++;\n      const key = _LineRangeFragment.getKey(\"\\n\");\n      this.histogram[key] = (this.histogram[key] || 0) + 1;\n    }\n    this.totalCount = counter;\n  }\n  computeSimilarity(other) {\n    var _a4, _b2;\n    let sumDifferences = 0;\n    const maxLength = Math.max(this.histogram.length, other.histogram.length);\n    for (let i = 0; i \u003c maxLength; i++) {\n      sumDifferences += Math.abs(((_a4 = this.histogram[i]) !== null \u0026\u0026 _a4 !== void 0 ? _a4 : 0) - ((_b2 = other.histogram[i]) !== null \u0026\u0026 _b2 !== void 0 ? _b2 : 0));\n    }\n    return 1 - sumDifferences / (this.totalCount + other.totalCount);\n  }\n};\nLineRangeFragment.chrKeys = /* @__PURE__ */ new Map();\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js\nvar DynamicProgrammingDiffing = class {\n  compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n    if (sequence1.length === 0 || sequence2.length === 0) {\n      return DiffAlgorithmResult.trivial(sequence1, sequence2);\n    }\n    const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n    const directions = new Array2D(sequence1.length, sequence2.length);\n    const lengths = new Array2D(sequence1.length, sequence2.length);\n    for (let s12 = 0; s12 \u003c sequence1.length; s12++) {\n      for (let s22 = 0; s22 \u003c sequence2.length; s22++) {\n        if (!timeout.isValid()) {\n          return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n        }\n        const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);\n        const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);\n        let extendedSeqScore;\n        if (sequence1.getElement(s12) === sequence2.getElement(s22)) {\n          if (s12 === 0 || s22 === 0) {\n            extendedSeqScore = 0;\n          } else {\n            extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);\n          }\n          if (s12 \u003e 0 \u0026\u0026 s22 \u003e 0 \u0026\u0026 directions.get(s12 - 1, s22 - 1) === 3) {\n            extendedSeqScore += lengths.get(s12 - 1, s22 - 1);\n          }\n          extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;\n        } else {\n          extendedSeqScore = -1;\n        }\n        const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n        if (newValue === extendedSeqScore) {\n          const prevLen = s12 \u003e 0 \u0026\u0026 s22 \u003e 0 ? lengths.get(s12 - 1, s22 - 1) : 0;\n          lengths.set(s12, s22, prevLen + 1);\n          directions.set(s12, s22, 3);\n        } else if (newValue === horizontalLen) {\n          lengths.set(s12, s22, 0);\n          directions.set(s12, s22, 1);\n        } else if (newValue === verticalLen) {\n          lengths.set(s12, s22, 0);\n          directions.set(s12, s22, 2);\n        }\n        lcsLengths.set(s12, s22, newValue);\n      }\n    }\n    const result = [];\n    let lastAligningPosS1 = sequence1.length;\n    let lastAligningPosS2 = sequence2.length;\n    function reportDecreasingAligningPositions(s12, s22) {\n      if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {\n        result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));\n      }\n      lastAligningPosS1 = s12;\n      lastAligningPosS2 = s22;\n    }\n    let s1 = sequence1.length - 1;\n    let s2 = sequence2.length - 1;\n    while (s1 \u003e= 0 \u0026\u0026 s2 \u003e= 0) {\n      if (directions.get(s1, s2) === 3) {\n        reportDecreasingAligningPositions(s1, s2);\n        s1--;\n        s2--;\n      } else {\n        if (directions.get(s1, s2) === 1) {\n          s1--;\n        } else {\n          s2--;\n        }\n      }\n    }\n    reportDecreasingAligningPositions(-1, -1);\n    result.reverse();\n    return new DiffAlgorithmResult(result, false);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js\nvar MyersDiffAlgorithm = class {\n  compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n    if (seq1.length === 0 || seq2.length === 0) {\n      return DiffAlgorithmResult.trivial(seq1, seq2);\n    }\n    const seqX = seq1;\n    const seqY = seq2;\n    function getXAfterSnake(x, y) {\n      while (x \u003c seqX.length \u0026\u0026 y \u003c seqY.length \u0026\u0026 seqX.getElement(x) === seqY.getElement(y)) {\n        x++;\n        y++;\n      }\n      return x;\n    }\n    let d = 0;\n    const V = new FastInt32Array();\n    V.set(0, getXAfterSnake(0, 0));\n    const paths = new FastArrayNegativeIndices();\n    paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n    let k = 0;\n    loop:\n      while (true) {\n        d++;\n        if (!timeout.isValid()) {\n          return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n        }\n        const lowerBound = -Math.min(d, seqY.length + d % 2);\n        const upperBound = Math.min(d, seqX.length + d % 2);\n        for (k = lowerBound; k \u003c= upperBound; k += 2) {\n          let step = 0;\n          const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1);\n          const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1;\n          step++;\n          const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n          const y = x - k;\n          step++;\n          if (x \u003e seqX.length || y \u003e seqY.length) {\n            continue;\n          }\n          const newMaxX = getXAfterSnake(x, y);\n          V.set(k, newMaxX);\n          const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n          paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n          if (V.get(k) === seqX.length \u0026\u0026 V.get(k) - k === seqY.length) {\n            break loop;\n          }\n        }\n      }\n    let path = paths.get(k);\n    const result = [];\n    let lastAligningPosS1 = seqX.length;\n    let lastAligningPosS2 = seqY.length;\n    while (true) {\n      const endX = path ? path.x + path.length : 0;\n      const endY = path ? path.y + path.length : 0;\n      if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n        result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n      }\n      if (!path) {\n        break;\n      }\n      lastAligningPosS1 = path.x;\n      lastAligningPosS2 = path.y;\n      path = path.prev;\n    }\n    result.reverse();\n    return new DiffAlgorithmResult(result, false);\n  }\n};\nvar SnakePath = class {\n  constructor(prev, x, y, length) {\n    this.prev = prev;\n    this.x = x;\n    this.y = y;\n    this.length = length;\n  }\n};\nvar FastInt32Array = class {\n  constructor() {\n    this.positiveArr = new Int32Array(10);\n    this.negativeArr = new Int32Array(10);\n  }\n  get(idx) {\n    if (idx \u003c 0) {\n      idx = -idx - 1;\n      return this.negativeArr[idx];\n    } else {\n      return this.positiveArr[idx];\n    }\n  }\n  set(idx, value) {\n    if (idx \u003c 0) {\n      idx = -idx - 1;\n      if (idx \u003e= this.negativeArr.length) {\n        const arr = this.negativeArr;\n        this.negativeArr = new Int32Array(arr.length * 2);\n        this.negativeArr.set(arr);\n      }\n      this.negativeArr[idx] = value;\n    } else {\n      if (idx \u003e= this.positiveArr.length) {\n        const arr = this.positiveArr;\n        this.positiveArr = new Int32Array(arr.length * 2);\n        this.positiveArr.set(arr);\n      }\n      this.positiveArr[idx] = value;\n    }\n  }\n};\nvar FastArrayNegativeIndices = class {\n  constructor() {\n    this.positiveArr = [];\n    this.negativeArr = [];\n  }\n  get(idx) {\n    if (idx \u003c 0) {\n      idx = -idx - 1;\n      return this.negativeArr[idx];\n    } else {\n      return this.positiveArr[idx];\n    }\n  }\n  set(idx, value) {\n    if (idx \u003c 0) {\n      idx = -idx - 1;\n      this.negativeArr[idx] = value;\n    } else {\n      this.positiveArr[idx] = value;\n    }\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/map.js\nvar _a3;\nvar _b;\nvar ResourceMapEntry = class {\n  constructor(uri, value) {\n    this.uri = uri;\n    this.value = value;\n  }\n};\nfunction isEntries(arg) {\n  return Array.isArray(arg);\n}\nvar ResourceMap = class _ResourceMap {\n  constructor(arg, toKey) {\n    this[_a3] = \"ResourceMap\";\n    if (arg instanceof _ResourceMap) {\n      this.map = new Map(arg.map);\n      this.toKey = toKey !== null \u0026\u0026 toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;\n    } else if (isEntries(arg)) {\n      this.map = /* @__PURE__ */ new Map();\n      this.toKey = toKey !== null \u0026\u0026 toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;\n      for (const [resource, value] of arg) {\n        this.set(resource, value);\n      }\n    } else {\n      this.map = /* @__PURE__ */ new Map();\n      this.toKey = arg !== null \u0026\u0026 arg !== void 0 ? arg : _ResourceMap.defaultToKey;\n    }\n  }\n  set(resource, value) {\n    this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n    return this;\n  }\n  get(resource) {\n    var _c;\n    return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  has(resource) {\n    return this.map.has(this.toKey(resource));\n  }\n  get size() {\n    return this.map.size;\n  }\n  clear() {\n    this.map.clear();\n  }\n  delete(resource) {\n    return this.map.delete(this.toKey(resource));\n  }\n  forEach(clb, thisArg) {\n    if (typeof thisArg !== \"undefined\") {\n      clb = clb.bind(thisArg);\n    }\n    for (const [_, entry] of this.map) {\n      clb(entry.value, entry.uri, this);\n    }\n  }\n  *values() {\n    for (const entry of this.map.values()) {\n      yield entry.value;\n    }\n  }\n  *keys() {\n    for (const entry of this.map.values()) {\n      yield entry.uri;\n    }\n  }\n  *entries() {\n    for (const entry of this.map.values()) {\n      yield [entry.uri, entry.value];\n    }\n  }\n  *[(_a3 = Symbol.toStringTag, Symbol.iterator)]() {\n    for (const [, entry] of this.map) {\n      yield [entry.uri, entry.value];\n    }\n  }\n};\nResourceMap.defaultToKey = (resource) =\u003e resource.toString();\nvar LinkedMap = class {\n  constructor() {\n    this[_b] = \"LinkedMap\";\n    this._map = /* @__PURE__ */ new Map();\n    this._head = void 0;\n    this._tail = void 0;\n    this._size = 0;\n    this._state = 0;\n  }\n  clear() {\n    this._map.clear();\n    this._head = void 0;\n    this._tail = void 0;\n    this._size = 0;\n    this._state++;\n  }\n  isEmpty() {\n    return !this._head \u0026\u0026 !this._tail;\n  }\n  get size() {\n    return this._size;\n  }\n  get first() {\n    var _c;\n    return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  get last() {\n    var _c;\n    return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  get(key, touch = 0) {\n    const item = this._map.get(key);\n    if (!item) {\n      return void 0;\n    }\n    if (touch !== 0) {\n      this.touch(item, touch);\n    }\n    return item.value;\n  }\n  set(key, value, touch = 0) {\n    let item = this._map.get(key);\n    if (item) {\n      item.value = value;\n      if (touch !== 0) {\n        this.touch(item, touch);\n      }\n    } else {\n      item = { key, value, next: void 0, previous: void 0 };\n      switch (touch) {\n        case 0:\n          this.addItemLast(item);\n          break;\n        case 1:\n          this.addItemFirst(item);\n          break;\n        case 2:\n          this.addItemLast(item);\n          break;\n        default:\n          this.addItemLast(item);\n          break;\n      }\n      this._map.set(key, item);\n      this._size++;\n    }\n    return this;\n  }\n  delete(key) {\n    return !!this.remove(key);\n  }\n  remove(key) {\n    const item = this._map.get(key);\n    if (!item) {\n      return void 0;\n    }\n    this._map.delete(key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  shift() {\n    if (!this._head \u0026\u0026 !this._tail) {\n      return void 0;\n    }\n    if (!this._head || !this._tail) {\n      throw new Error(\"Invalid list\");\n    }\n    const item = this._head;\n    this._map.delete(item.key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  forEach(callbackfn, thisArg) {\n    const state = this._state;\n    let current = this._head;\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n      if (this._state !== state) {\n        throw new Error(`LinkedMap got modified during iteration.`);\n      }\n      current = current.next;\n    }\n  }\n  keys() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = { value: current.key, done: false };\n          current = current.next;\n          return result;\n        } else {\n          return { value: void 0, done: true };\n        }\n      }\n    };\n    return iterator;\n  }\n  values() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = { value: current.value, done: false };\n          current = current.next;\n          return result;\n        } else {\n          return { value: void 0, done: true };\n        }\n      }\n    };\n    return iterator;\n  }\n  entries() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = { value: [current.key, current.value], done: false };\n          current = current.next;\n          return result;\n        } else {\n          return { value: void 0, done: true };\n        }\n      }\n    };\n    return iterator;\n  }\n  [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.entries();\n  }\n  trimOld(newSize) {\n    if (newSize \u003e= this.size) {\n      return;\n    }\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n    let current = this._head;\n    let currentSize = this.size;\n    while (current \u0026\u0026 currentSize \u003e newSize) {\n      this._map.delete(current.key);\n      current = current.next;\n      currentSize--;\n    }\n    this._head = current;\n    this._size = currentSize;\n    if (current) {\n      current.previous = void 0;\n    }\n    this._state++;\n  }\n  addItemFirst(item) {\n    if (!this._head \u0026\u0026 !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error(\"Invalid list\");\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n    this._head = item;\n    this._state++;\n  }\n  addItemLast(item) {\n    if (!this._head \u0026\u0026 !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error(\"Invalid list\");\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n    this._tail = item;\n    this._state++;\n  }\n  removeItem(item) {\n    if (item === this._head \u0026\u0026 item === this._tail) {\n      this._head = void 0;\n      this._tail = void 0;\n    } else if (item === this._head) {\n      if (!item.next) {\n        throw new Error(\"Invalid list\");\n      }\n      item.next.previous = void 0;\n      this._head = item.next;\n    } else if (item === this._tail) {\n      if (!item.previous) {\n        throw new Error(\"Invalid list\");\n      }\n      item.previous.next = void 0;\n      this._tail = item.previous;\n    } else {\n      const next = item.next;\n      const previous = item.previous;\n      if (!next || !previous) {\n        throw new Error(\"Invalid list\");\n      }\n      next.previous = previous;\n      previous.next = next;\n    }\n    item.next = void 0;\n    item.previous = void 0;\n    this._state++;\n  }\n  touch(item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error(\"Invalid list\");\n    }\n    if (touch !== 1 \u0026\u0026 touch !== 2) {\n      return;\n    }\n    if (touch === 1) {\n      if (item === this._head) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      if (item === this._tail) {\n        previous.next = void 0;\n        this._tail = previous;\n      } else {\n        next.previous = previous;\n        previous.next = next;\n      }\n      item.previous = void 0;\n      item.next = this._head;\n      this._head.previous = item;\n      this._head = item;\n      this._state++;\n    } else if (touch === 2) {\n      if (item === this._tail) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      if (item === this._head) {\n        next.previous = void 0;\n        this._head = next;\n      } else {\n        next.previous = previous;\n        previous.next = next;\n      }\n      item.next = void 0;\n      item.previous = this._tail;\n      this._tail.next = item;\n      this._tail = item;\n      this._state++;\n    }\n  }\n  toJSON() {\n    const data = [];\n    this.forEach((value, key) =\u003e {\n      data.push([key, value]);\n    });\n    return data;\n  }\n  fromJSON(data) {\n    this.clear();\n    for (const [key, value] of data) {\n      this.set(key, value);\n    }\n  }\n};\nvar SetMap = class {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map();\n  }\n  add(key, value) {\n    let values = this.map.get(key);\n    if (!values) {\n      values = /* @__PURE__ */ new Set();\n      this.map.set(key, values);\n    }\n    values.add(value);\n  }\n  delete(key, value) {\n    const values = this.map.get(key);\n    if (!values) {\n      return;\n    }\n    values.delete(value);\n    if (values.size === 0) {\n      this.map.delete(key);\n    }\n  }\n  forEach(key, fn) {\n    const values = this.map.get(key);\n    if (!values) {\n      return;\n    }\n    values.forEach(fn);\n  }\n  get(key) {\n    const values = this.map.get(key);\n    if (!values) {\n      return /* @__PURE__ */ new Set();\n    }\n    return values;\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js\nvar LinesSliceCharSequence = class {\n  constructor(lines, lineRange, considerWhitespaceChanges) {\n    this.lines = lines;\n    this.considerWhitespaceChanges = considerWhitespaceChanges;\n    this.elements = [];\n    this.firstCharOffsetByLine = [];\n    this.additionalOffsetByLine = [];\n    let trimFirstLineFully = false;\n    if (lineRange.start \u003e 0 \u0026\u0026 lineRange.endExclusive \u003e= lines.length) {\n      lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n      trimFirstLineFully = true;\n    }\n    this.lineRange = lineRange;\n    this.firstCharOffsetByLine[0] = 0;\n    for (let i = this.lineRange.start; i \u003c this.lineRange.endExclusive; i++) {\n      let line = lines[i];\n      let offset = 0;\n      if (trimFirstLineFully) {\n        offset = line.length;\n        line = \"\";\n        trimFirstLineFully = false;\n      } else if (!considerWhitespaceChanges) {\n        const trimmedStartLine = line.trimStart();\n        offset = line.length - trimmedStartLine.length;\n        line = trimmedStartLine.trimEnd();\n      }\n      this.additionalOffsetByLine.push(offset);\n      for (let i2 = 0; i2 \u003c line.length; i2++) {\n        this.elements.push(line.charCodeAt(i2));\n      }\n      if (i \u003c lines.length - 1) {\n        this.elements.push(\"\\n\".charCodeAt(0));\n        this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n      }\n    }\n    this.additionalOffsetByLine.push(0);\n  }\n  toString() {\n    return `Slice: \"${this.text}\"`;\n  }\n  get text() {\n    return this.getText(new OffsetRange(0, this.length));\n  }\n  getText(range) {\n    return this.elements.slice(range.start, range.endExclusive).map((e) =\u003e String.fromCharCode(e)).join(\"\");\n  }\n  getElement(offset) {\n    return this.elements[offset];\n  }\n  get length() {\n    return this.elements.length;\n  }\n  getBoundaryScore(length) {\n    const prevCategory = getCategory(length \u003e 0 ? this.elements[length - 1] : -1);\n    const nextCategory = getCategory(length \u003c this.elements.length ? this.elements[length] : -1);\n    if (prevCategory === 7 \u0026\u0026 nextCategory === 8) {\n      return 0;\n    }\n    let score2 = 0;\n    if (prevCategory !== nextCategory) {\n      score2 += 10;\n      if (prevCategory === 0 \u0026\u0026 nextCategory === 1) {\n        score2 += 1;\n      }\n    }\n    score2 += getCategoryBoundaryScore(prevCategory);\n    score2 += getCategoryBoundaryScore(nextCategory);\n    return score2;\n  }\n  translateOffset(offset) {\n    if (this.lineRange.isEmpty) {\n      return new Position(this.lineRange.start + 1, 1);\n    }\n    const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) =\u003e value \u003c= offset);\n    return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n  }\n  translateRange(range) {\n    return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n  }\n  /**\n   * Finds the word that contains the character at the given offset\n   */\n  findWordContaining(offset) {\n    if (offset \u003c 0 || offset \u003e= this.elements.length) {\n      return void 0;\n    }\n    if (!isWordChar(this.elements[offset])) {\n      return void 0;\n    }\n    let start = offset;\n    while (start \u003e 0 \u0026\u0026 isWordChar(this.elements[start - 1])) {\n      start--;\n    }\n    let end = offset;\n    while (end \u003c this.elements.length \u0026\u0026 isWordChar(this.elements[end])) {\n      end++;\n    }\n    return new OffsetRange(start, end);\n  }\n  countLinesIn(range) {\n    return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n  }\n  isStronglyEqual(offset1, offset2) {\n    return this.elements[offset1] === this.elements[offset2];\n  }\n  extendToFullLines(range) {\n    var _a4, _b2;\n    const start = (_a4 = findLastMonotonous(this.firstCharOffsetByLine, (x) =\u003e x \u003c= range.start)) !== null \u0026\u0026 _a4 !== void 0 ? _a4 : 0;\n    const end = (_b2 = findFirstMonotonous(this.firstCharOffsetByLine, (x) =\u003e range.endExclusive \u003c= x)) !== null \u0026\u0026 _b2 !== void 0 ? _b2 : this.elements.length;\n    return new OffsetRange(start, end);\n  }\n};\nfunction isWordChar(charCode) {\n  return charCode \u003e= 97 \u0026\u0026 charCode \u003c= 122 || charCode \u003e= 65 \u0026\u0026 charCode \u003c= 90 || charCode \u003e= 48 \u0026\u0026 charCode \u003c= 57;\n}\nvar score = {\n  [\n    0\n    /* CharBoundaryCategory.WordLower */\n  ]: 0,\n  [\n    1\n    /* CharBoundaryCategory.WordUpper */\n  ]: 0,\n  [\n    2\n    /* CharBoundaryCategory.WordNumber */\n  ]: 0,\n  [\n    3\n    /* CharBoundaryCategory.End */\n  ]: 10,\n  [\n    4\n    /* CharBoundaryCategory.Other */\n  ]: 2,\n  [\n    5\n    /* CharBoundaryCategory.Separator */\n  ]: 3,\n  [\n    6\n    /* CharBoundaryCategory.Space */\n  ]: 3,\n  [\n    7\n    /* CharBoundaryCategory.LineBreakCR */\n  ]: 10,\n  [\n    8\n    /* CharBoundaryCategory.LineBreakLF */\n  ]: 10\n};\nfunction getCategoryBoundaryScore(category) {\n  return score[category];\n}\nfunction getCategory(charCode) {\n  if (charCode === 10) {\n    return 8;\n  } else if (charCode === 13) {\n    return 7;\n  } else if (isSpace(charCode)) {\n    return 6;\n  } else if (charCode \u003e= 97 \u0026\u0026 charCode \u003c= 122) {\n    return 0;\n  } else if (charCode \u003e= 65 \u0026\u0026 charCode \u003c= 90) {\n    return 1;\n  } else if (charCode \u003e= 48 \u0026\u0026 charCode \u003c= 57) {\n    return 2;\n  } else if (charCode === -1) {\n    return 3;\n  } else if (charCode === 44 || charCode === 59) {\n    return 5;\n  } else {\n    return 4;\n  }\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js\nfunction computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n  let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n  if (!timeout.isValid()) {\n    return [];\n  }\n  const filteredChanges = changes.filter((c) =\u003e !excludedChanges.has(c));\n  const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n  pushMany(moves, unchangedMoves);\n  moves = joinCloseConsecutiveMoves(moves);\n  moves = moves.filter((current) =\u003e {\n    const lines = current.original.toOffsetRange().slice(originalLines).map((l) =\u003e l.trim());\n    const originalText = lines.join(\"\\n\");\n    return originalText.length \u003e= 15 \u0026\u0026 countWhere(lines, (l) =\u003e l.length \u003e= 2) \u003e= 2;\n  });\n  moves = removeMovesInSameDiff(changes, moves);\n  return moves;\n}\nfunction countWhere(arr, predicate) {\n  let count = 0;\n  for (const t of arr) {\n    if (predicate(t)) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n  const moves = [];\n  const deletions = changes.filter((c) =\u003e c.modified.isEmpty \u0026\u0026 c.original.length \u003e= 3).map((d) =\u003e new LineRangeFragment(d.original, originalLines, d));\n  const insertions = new Set(changes.filter((c) =\u003e c.original.isEmpty \u0026\u0026 c.modified.length \u003e= 3).map((d) =\u003e new LineRangeFragment(d.modified, modifiedLines, d)));\n  const excludedChanges = /* @__PURE__ */ new Set();\n  for (const deletion of deletions) {\n    let highestSimilarity = -1;\n    let best;\n    for (const insertion of insertions) {\n      const similarity = deletion.computeSimilarity(insertion);\n      if (similarity \u003e highestSimilarity) {\n        highestSimilarity = similarity;\n        best = insertion;\n      }\n    }\n    if (highestSimilarity \u003e 0.9 \u0026\u0026 best) {\n      insertions.delete(best);\n      moves.push(new LineRangeMapping(deletion.range, best.range));\n      excludedChanges.add(deletion.source);\n      excludedChanges.add(best.source);\n    }\n    if (!timeout.isValid()) {\n      return { moves, excludedChanges };\n    }\n  }\n  return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n  const moves = [];\n  const original3LineHashes = new SetMap();\n  for (const change of changes) {\n    for (let i = change.original.startLineNumber; i \u003c change.original.endLineNumberExclusive - 2; i++) {\n      const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n      original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n    }\n  }\n  const possibleMappings = [];\n  changes.sort(compareBy((c) =\u003e c.modified.startLineNumber, numberComparator));\n  for (const change of changes) {\n    let lastMappings = [];\n    for (let i = change.modified.startLineNumber; i \u003c change.modified.endLineNumberExclusive - 2; i++) {\n      const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n      const currentModifiedRange = new LineRange(i, i + 3);\n      const nextMappings = [];\n      original3LineHashes.forEach(key, ({ range }) =\u003e {\n        for (const lastMapping of lastMappings) {\n          if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive \u0026\u0026 lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n            lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n            lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n            nextMappings.push(lastMapping);\n            return;\n          }\n        }\n        const mapping = {\n          modifiedLineRange: currentModifiedRange,\n          originalLineRange: range\n        };\n        possibleMappings.push(mapping);\n        nextMappings.push(mapping);\n      });\n      lastMappings = nextMappings;\n    }\n    if (!timeout.isValid()) {\n      return [];\n    }\n  }\n  possibleMappings.sort(reverseOrder(compareBy((m) =\u003e m.modifiedLineRange.length, numberComparator)));\n  const modifiedSet = new LineRangeSet();\n  const originalSet = new LineRangeSet();\n  for (const mapping of possibleMappings) {\n    const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n    const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n    const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n    const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n    for (const s of modifiedIntersectedSections.ranges) {\n      if (s.length \u003c 3) {\n        continue;\n      }\n      const modifiedLineRange = s;\n      const originalLineRange = s.delta(-diffOrigToMod);\n      moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n      modifiedSet.addRange(modifiedLineRange);\n      originalSet.addRange(originalLineRange);\n    }\n  }\n  moves.sort(compareBy((m) =\u003e m.original.startLineNumber, numberComparator));\n  const monotonousChanges = new MonotonousArray(changes);\n  for (let i = 0; i \u003c moves.length; i++) {\n    const move = moves[i];\n    const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) =\u003e c.original.startLineNumber \u003c= move.original.startLineNumber);\n    const firstTouchingChangeMod = findLastMonotonous(changes, (c) =\u003e c.modified.startLineNumber \u003c= move.modified.startLineNumber);\n    const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n    const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) =\u003e c.original.startLineNumber \u003c move.original.endLineNumberExclusive);\n    const lastTouchingChangeMod = findLastMonotonous(changes, (c) =\u003e c.modified.startLineNumber \u003c move.modified.endLineNumberExclusive);\n    const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n    let extendToTop;\n    for (extendToTop = 0; extendToTop \u003c linesAbove; extendToTop++) {\n      const origLine = move.original.startLineNumber - extendToTop - 1;\n      const modLine = move.modified.startLineNumber - extendToTop - 1;\n      if (origLine \u003e originalLines.length || modLine \u003e modifiedLines.length) {\n        break;\n      }\n      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n        break;\n      }\n      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n        break;\n      }\n    }\n    if (extendToTop \u003e 0) {\n      originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n      modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n    }\n    let extendToBottom;\n    for (extendToBottom = 0; extendToBottom \u003c linesBelow; extendToBottom++) {\n      const origLine = move.original.endLineNumberExclusive + extendToBottom;\n      const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n      if (origLine \u003e originalLines.length || modLine \u003e modifiedLines.length) {\n        break;\n      }\n      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n        break;\n      }\n      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n        break;\n      }\n    }\n    if (extendToBottom \u003e 0) {\n      originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n      modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n    }\n    if (extendToTop \u003e 0 || extendToBottom \u003e 0) {\n      moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n    }\n  }\n  return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n  if (line1.trim() === line2.trim()) {\n    return true;\n  }\n  if (line1.length \u003e 300 \u0026\u0026 line2.length \u003e 300) {\n    return false;\n  }\n  const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);\n  let commonNonSpaceCharCount = 0;\n  const inverted = SequenceDiff.invert(result.diffs, line1.length);\n  for (const seq of inverted) {\n    seq.seq1Range.forEach((idx) =\u003e {\n      if (!isSpace(line1.charCodeAt(idx))) {\n        commonNonSpaceCharCount++;\n      }\n    });\n  }\n  function countNonWsChars(str) {\n    let count = 0;\n    for (let i = 0; i \u003c line1.length; i++) {\n      if (!isSpace(str.charCodeAt(i))) {\n        count++;\n      }\n    }\n    return count;\n  }\n  const longerLineLength = countNonWsChars(line1.length \u003e line2.length ? line1 : line2);\n  const r = commonNonSpaceCharCount / longerLineLength \u003e 0.6 \u0026\u0026 longerLineLength \u003e 10;\n  return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n  if (moves.length === 0) {\n    return moves;\n  }\n  moves.sort(compareBy((m) =\u003e m.original.startLineNumber, numberComparator));\n  const result = [moves[0]];\n  for (let i = 1; i \u003c moves.length; i++) {\n    const last = result[result.length - 1];\n    const current = moves[i];\n    const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n    const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n    const currentMoveAfterLast = originalDist \u003e= 0 \u0026\u0026 modifiedDist \u003e= 0;\n    if (currentMoveAfterLast \u0026\u0026 originalDist + modifiedDist \u003c= 2) {\n      result[result.length - 1] = last.join(current);\n      continue;\n    }\n    result.push(current);\n  }\n  return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n  const changesMonotonous = new MonotonousArray(changes);\n  moves = moves.filter((m) =\u003e {\n    const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous((c) =\u003e c.original.startLineNumber \u003c m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n    const diffBeforeEndOfMoveModified = findLastMonotonous(changes, (c) =\u003e c.modified.startLineNumber \u003c m.modified.endLineNumberExclusive);\n    const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n    return differentDiffs;\n  });\n  return moves;\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js\nfunction optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  let result = sequenceDiffs;\n  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n  result = shiftSequenceDiffs(sequence1, sequence2, result);\n  return result;\n}\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n  if (sequenceDiffs.length === 0) {\n    return sequenceDiffs;\n  }\n  const result = [];\n  result.push(sequenceDiffs[0]);\n  for (let i = 1; i \u003c sequenceDiffs.length; i++) {\n    const prevResult = result[result.length - 1];\n    let cur = sequenceDiffs[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n      let d;\n      for (d = 1; d \u003c= length; d++) {\n        if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n          break;\n        }\n      }\n      d--;\n      if (d === length) {\n        result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n        continue;\n      }\n      cur = cur.delta(-d);\n    }\n    result.push(cur);\n  }\n  const result2 = [];\n  for (let i = 0; i \u003c result.length - 1; i++) {\n    const nextResult = result[i + 1];\n    let cur = result[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n      let d;\n      for (d = 0; d \u003c length; d++) {\n        if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) || !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n          break;\n        }\n      }\n      if (d === length) {\n        result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n        continue;\n      }\n      if (d \u003e 0) {\n        cur = cur.delta(d);\n      }\n    }\n    result2.push(cur);\n  }\n  if (result.length \u003e 0) {\n    result2.push(result[result.length - 1]);\n  }\n  return result2;\n}\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n    return sequenceDiffs;\n  }\n  for (let i = 0; i \u003c sequenceDiffs.length; i++) {\n    const prevDiff = i \u003e 0 ? sequenceDiffs[i - 1] : void 0;\n    const diff = sequenceDiffs[i];\n    const nextDiff = i + 1 \u003c sequenceDiffs.length ? sequenceDiffs[i + 1] : void 0;\n    const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);\n    const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);\n    if (diff.seq1Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n    } else if (diff.seq2Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n    }\n  }\n  return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n  const maxShiftLimit = 100;\n  let deltaBefore = 1;\n  while (diff.seq1Range.start - deltaBefore \u003e= seq1ValidRange.start \u0026\u0026 diff.seq2Range.start - deltaBefore \u003e= seq2ValidRange.start \u0026\u0026 sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) \u0026\u0026 deltaBefore \u003c maxShiftLimit) {\n    deltaBefore++;\n  }\n  deltaBefore--;\n  let deltaAfter = 0;\n  while (diff.seq1Range.start + deltaAfter \u003c seq1ValidRange.endExclusive \u0026\u0026 diff.seq2Range.endExclusive + deltaAfter \u003c seq2ValidRange.endExclusive \u0026\u0026 sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) \u0026\u0026 deltaAfter \u003c maxShiftLimit) {\n    deltaAfter++;\n  }\n  if (deltaBefore === 0 \u0026\u0026 deltaAfter === 0) {\n    return diff;\n  }\n  let bestDelta = 0;\n  let bestScore = -1;\n  for (let delta = -deltaBefore; delta \u003c= deltaAfter; delta++) {\n    const seq2OffsetStart = diff.seq2Range.start + delta;\n    const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n    const seq1Offset = diff.seq1Range.start + delta;\n    const score2 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n    if (score2 \u003e bestScore) {\n      bestScore = score2;\n      bestDelta = delta;\n    }\n  }\n  return diff.delta(bestDelta);\n}\nfunction removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n  const result = [];\n  for (const s of sequenceDiffs) {\n    const last = result[result.length - 1];\n    if (!last) {\n      result.push(s);\n      continue;\n    }\n    if (s.seq1Range.start - last.seq1Range.endExclusive \u003c= 2 || s.seq2Range.start - last.seq2Range.endExclusive \u003c= 2) {\n      result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n    } else {\n      result.push(s);\n    }\n  }\n  return result;\n}\nfunction extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n  const additional = [];\n  let lastModifiedWord = void 0;\n  function maybePushWordToAdditional() {\n    if (!lastModifiedWord) {\n      return;\n    }\n    const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n    const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n    if (originalLength1 !== originalLength2) {\n    }\n    if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) \u003e originalLength1) {\n      additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n    }\n    lastModifiedWord = void 0;\n  }\n  for (const s of sequenceDiffs) {\n    let processWord = function(s1Range, s2Range) {\n      var _a4, _b2, _c, _d;\n      if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n        if (lastModifiedWord \u0026\u0026 !(lastModifiedWord.s1Range.endExclusive \u003c s1Range.start \u0026\u0026 lastModifiedWord.s2Range.endExclusive \u003c s2Range.start)) {\n          const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n          const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n          lastModifiedWord.deleted += (_a4 = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null \u0026\u0026 _a4 !== void 0 ? _a4 : 0;\n          lastModifiedWord.added += (_b2 = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null \u0026\u0026 _b2 !== void 0 ? _b2 : 0;\n          lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n          lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n        } else {\n          maybePushWordToAdditional();\n          lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range, s2Range };\n        }\n      }\n      const changedS1 = s1Range.intersect(s.seq1Range);\n      const changedS2 = s2Range.intersect(s.seq2Range);\n      lastModifiedWord.count++;\n      lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null \u0026\u0026 _c !== void 0 ? _c : 0;\n      lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null \u0026\u0026 _d !== void 0 ? _d : 0;\n    };\n    const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n    const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n    const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n    const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n    if (w1Before \u0026\u0026 w1After \u0026\u0026 w2Before \u0026\u0026 w2After \u0026\u0026 w1Before.equals(w1After) \u0026\u0026 w2Before.equals(w2After)) {\n      processWord(w1Before, w2Before);\n    } else {\n      if (w1Before \u0026\u0026 w2Before) {\n        processWord(w1Before, w2Before);\n      }\n      if (w1After \u0026\u0026 w2After) {\n        processWord(w1After, w2After);\n      }\n    }\n  }\n  maybePushWordToAdditional();\n  const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n  return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n  const result = [];\n  while (sequenceDiffs1.length \u003e 0 || sequenceDiffs2.length \u003e 0) {\n    const sd1 = sequenceDiffs1[0];\n    const sd2 = sequenceDiffs2[0];\n    let next;\n    if (sd1 \u0026\u0026 (!sd2 || sd1.seq1Range.start \u003c sd2.seq1Range.start)) {\n      next = sequenceDiffs1.shift();\n    } else {\n      next = sequenceDiffs2.shift();\n    }\n    if (result.length \u003e 0 \u0026\u0026 result[result.length - 1].seq1Range.endExclusive \u003e= next.seq1Range.start) {\n      result[result.length - 1] = result[result.length - 1].join(next);\n    } else {\n      result.push(next);\n    }\n  }\n  return result;\n}\nfunction removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n  let diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  let counter = 0;\n  let shouldRepeat;\n  do {\n    shouldRepeat = false;\n    const result = [\n      diffs[0]\n    ];\n    for (let i = 1; i \u003c diffs.length; i++) {\n      let shouldJoinDiffs = function(before, after) {\n        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        const unchangedText = sequence1.getText(unchangedRange);\n        const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, \"\");\n        if (unchangedTextWithoutWs.length \u003c= 4 \u0026\u0026 (before.seq1Range.length + before.seq2Range.length \u003e 5 || after.seq1Range.length + after.seq2Range.length \u003e 5)) {\n          return true;\n        }\n        return false;\n      };\n      const cur = diffs[i];\n      const lastResult = result[result.length - 1];\n      const shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    }\n    diffs = result;\n  } while (counter++ \u003c 10 \u0026\u0026 shouldRepeat);\n  return diffs;\n}\nfunction removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n  let diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  let counter = 0;\n  let shouldRepeat;\n  do {\n    shouldRepeat = false;\n    const result = [\n      diffs[0]\n    ];\n    for (let i = 1; i \u003c diffs.length; i++) {\n      let shouldJoinDiffs = function(before, after) {\n        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n        if (unchangedLineCount \u003e 5 || unchangedRange.length \u003e 500) {\n          return false;\n        }\n        const unchangedText = sequence1.getText(unchangedRange).trim();\n        if (unchangedText.length \u003e 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length \u003e 1) {\n          return false;\n        }\n        const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n        const beforeSeq1Length = before.seq1Range.length;\n        const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n        const beforeSeq2Length = before.seq2Range.length;\n        const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n        const afterSeq1Length = after.seq1Range.length;\n        const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n        const afterSeq2Length = after.seq2Range.length;\n        const max = 2 * 40 + 50;\n        function cap(v) {\n          return Math.min(v, max);\n        }\n        if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) \u003e (max ** 1.5) ** 1.5 * 1.3) {\n          return true;\n        }\n        return false;\n      };\n      const cur = diffs[i];\n      const lastResult = result[result.length - 1];\n      const shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    }\n    diffs = result;\n  } while (counter++ \u003c 10 \u0026\u0026 shouldRepeat);\n  const newDiffs = [];\n  forEachWithNeighbors(diffs, (prev, cur, next) =\u003e {\n    let newDiff = cur;\n    function shouldMarkAsChanged(text) {\n      return text.length \u003e 0 \u0026\u0026 text.trim().length \u003c= 3 \u0026\u0026 cur.seq1Range.length + cur.seq2Range.length \u003e 100;\n    }\n    const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n    const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n    if (shouldMarkAsChanged(prefix)) {\n      newDiff = newDiff.deltaStart(-prefix.length);\n    }\n    const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n    if (shouldMarkAsChanged(suffix)) {\n      newDiff = newDiff.deltaEnd(suffix.length);\n    }\n    const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n    const result = newDiff.intersect(availableSpace);\n    newDiffs.push(result);\n  });\n  return newDiffs;\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js\nvar LineSequence2 = class {\n  constructor(trimmedHash, lines) {\n    this.trimmedHash = trimmedHash;\n    this.lines = lines;\n  }\n  getElement(offset) {\n    return this.trimmedHash[offset];\n  }\n  get length() {\n    return this.trimmedHash.length;\n  }\n  getBoundaryScore(length) {\n    const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n    const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n    return 1e3 - (indentationBefore + indentationAfter);\n  }\n  getText(range) {\n    return this.lines.slice(range.start, range.endExclusive).join(\"\\n\");\n  }\n  isStronglyEqual(offset1, offset2) {\n    return this.lines[offset1] === this.lines[offset2];\n  }\n};\nfunction getIndentation(str) {\n  let i = 0;\n  while (i \u003c str.length \u0026\u0026 (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {\n    i++;\n  }\n  return i;\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js\nvar DefaultLinesDiffComputer = class {\n  constructor() {\n    this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n    this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  }\n  computeDiff(originalLines, modifiedLines, options) {\n    if (originalLines.length \u003c= 1 \u0026\u0026 equals(originalLines, modifiedLines, (a2, b) =\u003e a2 === b)) {\n      return new LinesDiff([], [], false);\n    }\n    if (originalLines.length === 1 \u0026\u0026 originalLines[0].length === 0 || modifiedLines.length === 1 \u0026\u0026 modifiedLines[0].length === 0) {\n      return new LinesDiff([\n        new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n          new RangeMapping(new Range(1, 1, originalLines.length, originalLines[0].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))\n        ])\n      ], [], false);\n    }\n    const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n    const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n    const perfectHashes = /* @__PURE__ */ new Map();\n    function getOrCreateHash(text) {\n      let hash = perfectHashes.get(text);\n      if (hash === void 0) {\n        hash = perfectHashes.size;\n        perfectHashes.set(text, hash);\n      }\n      return hash;\n    }\n    const originalLinesHashes = originalLines.map((l) =\u003e getOrCreateHash(l.trim()));\n    const modifiedLinesHashes = modifiedLines.map((l) =\u003e getOrCreateHash(l.trim()));\n    const sequence1 = new LineSequence2(originalLinesHashes, originalLines);\n    const sequence2 = new LineSequence2(modifiedLinesHashes, modifiedLines);\n    const lineAlignmentResult = (() =\u003e {\n      if (sequence1.length + sequence2.length \u003c 1700) {\n        return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) =\u003e originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);\n      }\n      return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n    })();\n    let lineAlignments = lineAlignmentResult.diffs;\n    let hitTimeout = lineAlignmentResult.hitTimeout;\n    lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n    lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n    const alignments = [];\n    const scanForWhitespaceChanges = (equalLinesCount) =\u003e {\n      if (!considerWhitespaceChanges) {\n        return;\n      }\n      for (let i = 0; i \u003c equalLinesCount; i++) {\n        const seq1Offset = seq1LastStart + i;\n        const seq2Offset = seq2LastStart + i;\n        if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n          const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n          for (const a2 of characterDiffs.mappings) {\n            alignments.push(a2);\n          }\n          if (characterDiffs.hitTimeout) {\n            hitTimeout = true;\n          }\n        }\n      }\n    };\n    let seq1LastStart = 0;\n    let seq2LastStart = 0;\n    for (const diff of lineAlignments) {\n      assertFn(() =\u003e diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n      const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n      scanForWhitespaceChanges(equalLinesCount);\n      seq1LastStart = diff.seq1Range.endExclusive;\n      seq2LastStart = diff.seq2Range.endExclusive;\n      const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n      if (characterDiffs.hitTimeout) {\n        hitTimeout = true;\n      }\n      for (const a2 of characterDiffs.mappings) {\n        alignments.push(a2);\n      }\n    }\n    scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n    const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n    let moves = [];\n    if (options.computeMoves) {\n      moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n    }\n    assertFn(() =\u003e {\n      function validatePosition(pos, lines) {\n        if (pos.lineNumber \u003c 1 || pos.lineNumber \u003e lines.length) {\n          return false;\n        }\n        const line = lines[pos.lineNumber - 1];\n        if (pos.column \u003c 1 || pos.column \u003e line.length + 1) {\n          return false;\n        }\n        return true;\n      }\n      function validateRange(range, lines) {\n        if (range.startLineNumber \u003c 1 || range.startLineNumber \u003e lines.length + 1) {\n          return false;\n        }\n        if (range.endLineNumberExclusive \u003c 1 || range.endLineNumberExclusive \u003e lines.length + 1) {\n          return false;\n        }\n        return true;\n      }\n      for (const c of changes) {\n        if (!c.innerChanges) {\n          return false;\n        }\n        for (const ic of c.innerChanges) {\n          const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) \u0026\u0026 validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) \u0026\u0026 validatePosition(ic.originalRange.getStartPosition(), originalLines) \u0026\u0026 validatePosition(ic.originalRange.getEndPosition(), originalLines);\n          if (!valid) {\n            return false;\n          }\n        }\n        if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n          return false;\n        }\n      }\n      return true;\n    });\n    return new LinesDiff(changes, moves, hitTimeout);\n  }\n  computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n    const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n    const movesWithDiffs = moves.map((m) =\u003e {\n      const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n      const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n      return new MovedText(m, mappings);\n    });\n    return movesWithDiffs;\n  }\n  refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n    const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\n    const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n    const diffResult = slice1.length + slice2.length \u003c 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n    let diffs = diffResult.diffs;\n    diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n    diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n    diffs = removeShortMatches(slice1, slice2, diffs);\n    diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n    const result = diffs.map((d) =\u003e new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n    return {\n      mappings: result,\n      hitTimeout: diffResult.hitTimeout\n    };\n  }\n};\nfunction lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n  const changes = [];\n  for (const g of groupAdjacentBy(alignments.map((a2) =\u003e getLineRangeMapping(a2, originalLines, modifiedLines)), (a1, a2) =\u003e a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified))) {\n    const first = g[0];\n    const last = g[g.length - 1];\n    changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map((a2) =\u003e a2.innerChanges[0])));\n  }\n  assertFn(() =\u003e {\n    if (!dontAssertStartLine) {\n      if (changes.length \u003e 0 \u0026\u0026 changes[0].original.startLineNumber !== changes[0].modified.startLineNumber) {\n        return false;\n      }\n    }\n    return checkAdjacentItems(changes, (m1, m2) =\u003e m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive \u0026\u0026 // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n    m1.original.endLineNumberExclusive \u003c m2.original.startLineNumber \u0026\u0026 m1.modified.endLineNumberExclusive \u003c m2.modified.startLineNumber);\n  });\n  return changes;\n}\nfunction getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n  let lineStartDelta = 0;\n  let lineEndDelta = 0;\n  if (rangeMapping.modifiedRange.endColumn === 1 \u0026\u0026 rangeMapping.originalRange.endColumn === 1 \u0026\u0026 rangeMapping.originalRange.startLineNumber + lineStartDelta \u003c= rangeMapping.originalRange.endLineNumber \u0026\u0026 rangeMapping.modifiedRange.startLineNumber + lineStartDelta \u003c= rangeMapping.modifiedRange.endLineNumber) {\n    lineEndDelta = -1;\n  }\n  if (rangeMapping.modifiedRange.startColumn - 1 \u003e= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length \u0026\u0026 rangeMapping.originalRange.startColumn - 1 \u003e= originalLines[rangeMapping.originalRange.startLineNumber - 1].length \u0026\u0026 rangeMapping.originalRange.startLineNumber \u003c= rangeMapping.originalRange.endLineNumber + lineEndDelta \u0026\u0026 rangeMapping.modifiedRange.startLineNumber \u003c= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n    lineStartDelta = 1;\n  }\n  const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n  const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n  return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js\nvar linesDiffComputers = {\n  getLegacy: () =\u003e new LegacyLinesDiffComputer(),\n  getDefault: () =\u003e new DefaultLinesDiffComputer()\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/base/common/color.js\nfunction roundFloat(number, decimalPoints) {\n  const decimal = Math.pow(10, decimalPoints);\n  return Math.round(number * decimal) / decimal;\n}\nvar RGBA = class {\n  constructor(r, g, b, a2 = 1) {\n    this._rgbaBrand = void 0;\n    this.r = Math.min(255, Math.max(0, r)) | 0;\n    this.g = Math.min(255, Math.max(0, g)) | 0;\n    this.b = Math.min(255, Math.max(0, b)) | 0;\n    this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);\n  }\n  static equals(a2, b) {\n    return a2.r === b.r \u0026\u0026 a2.g === b.g \u0026\u0026 a2.b === b.b \u0026\u0026 a2.a === b.a;\n  }\n};\nvar HSLA = class _HSLA {\n  constructor(h, s, l, a2) {\n    this._hslaBrand = void 0;\n    this.h = Math.max(Math.min(360, h), 0) | 0;\n    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n    this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);\n    this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);\n  }\n  static equals(a2, b) {\n    return a2.h === b.h \u0026\u0026 a2.s === b.s \u0026\u0026 a2.l === b.l \u0026\u0026 a2.a === b.a;\n  }\n  /**\n   * Converts an RGB color value to HSL. Conversion formula\n   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n   * Assumes r, g, and b are contained in the set [0, 255] and\n   * returns h in the set [0, 360], s, and l in the set [0, 1].\n   */\n  static fromRGBA(rgba) {\n    const r = rgba.r / 255;\n    const g = rgba.g / 255;\n    const b = rgba.b / 255;\n    const a2 = rgba.a;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h = 0;\n    let s = 0;\n    const l = (min + max) / 2;\n    const chroma = max - min;\n    if (chroma \u003e 0) {\n      s = Math.min(l \u003c= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);\n      switch (max) {\n        case r:\n          h = (g - b) / chroma + (g \u003c b ? 6 : 0);\n          break;\n        case g:\n          h = (b - r) / chroma + 2;\n          break;\n        case b:\n          h = (r - g) / chroma + 4;\n          break;\n      }\n      h *= 60;\n      h = Math.round(h);\n    }\n    return new _HSLA(h, s, l, a2);\n  }\n  static _hue2rgb(p, q, t) {\n    if (t \u003c 0) {\n      t += 1;\n    }\n    if (t \u003e 1) {\n      t -= 1;\n    }\n    if (t \u003c 1 / 6) {\n      return p + (q - p) * 6 * t;\n    }\n    if (t \u003c 1 / 2) {\n      return q;\n    }\n    if (t \u003c 2 / 3) {\n      return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n  }\n  /**\n   * Converts an HSL color value to RGB. Conversion formula\n   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and\n   * returns r, g, and b in the set [0, 255].\n   */\n  static toRGBA(hsla) {\n    const h = hsla.h / 360;\n    const { s, l, a: a2 } = hsla;\n    let r, g, b;\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      const q = l \u003c 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = _HSLA._hue2rgb(p, q, h + 1 / 3);\n      g = _HSLA._hue2rgb(p, q, h);\n      b = _HSLA._hue2rgb(p, q, h - 1 / 3);\n    }\n    return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a2);\n  }\n};\nvar HSVA = class _HSVA {\n  constructor(h, s, v, a2) {\n    this._hsvaBrand = void 0;\n    this.h = Math.max(Math.min(360, h), 0) | 0;\n    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n    this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);\n    this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);\n  }\n  static equals(a2, b) {\n    return a2.h === b.h \u0026\u0026 a2.s === b.s \u0026\u0026 a2.v === b.v \u0026\u0026 a2.a === b.a;\n  }\n  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm\n  static fromRGBA(rgba) {\n    const r = rgba.r / 255;\n    const g = rgba.g / 255;\n    const b = rgba.b / 255;\n    const cmax = Math.max(r, g, b);\n    const cmin = Math.min(r, g, b);\n    const delta = cmax - cmin;\n    const s = cmax === 0 ? 0 : delta / cmax;\n    let m;\n    if (delta === 0) {\n      m = 0;\n    } else if (cmax === r) {\n      m = ((g - b) / delta % 6 + 6) % 6;\n    } else if (cmax === g) {\n      m = (b - r) / delta + 2;\n    } else {\n      m = (r - g) / delta + 4;\n    }\n    return new _HSVA(Math.round(m * 60), s, cmax, rgba.a);\n  }\n  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm\n  static toRGBA(hsva) {\n    const { h, s, v, a: a2 } = hsva;\n    const c = v * s;\n    const x = c * (1 - Math.abs(h / 60 % 2 - 1));\n    const m = v - c;\n    let [r, g, b] = [0, 0, 0];\n    if (h \u003c 60) {\n      r = c;\n      g = x;\n    } else if (h \u003c 120) {\n      r = x;\n      g = c;\n    } else if (h \u003c 180) {\n      g = c;\n      b = x;\n    } else if (h \u003c 240) {\n      g = x;\n      b = c;\n    } else if (h \u003c 300) {\n      r = x;\n      b = c;\n    } else if (h \u003c= 360) {\n      r = c;\n      b = x;\n    }\n    r = Math.round((r + m) * 255);\n    g = Math.round((g + m) * 255);\n    b = Math.round((b + m) * 255);\n    return new RGBA(r, g, b, a2);\n  }\n};\nvar Color = class _Color {\n  static fromHex(hex) {\n    return _Color.Format.CSS.parseHex(hex) || _Color.red;\n  }\n  static equals(a2, b) {\n    if (!a2 \u0026\u0026 !b) {\n      return true;\n    }\n    if (!a2 || !b) {\n      return false;\n    }\n    return a2.equals(b);\n  }\n  get hsla() {\n    if (this._hsla) {\n      return this._hsla;\n    } else {\n      return HSLA.fromRGBA(this.rgba);\n    }\n  }\n  get hsva() {\n    if (this._hsva) {\n      return this._hsva;\n    }\n    return HSVA.fromRGBA(this.rgba);\n  }\n  constructor(arg) {\n    if (!arg) {\n      throw new Error(\"Color needs a value\");\n    } else if (arg instanceof RGBA) {\n      this.rgba = arg;\n    } else if (arg instanceof HSLA) {\n      this._hsla = arg;\n      this.rgba = HSLA.toRGBA(arg);\n    } else if (arg instanceof HSVA) {\n      this._hsva = arg;\n      this.rgba = HSVA.toRGBA(arg);\n    } else {\n      throw new Error(\"Invalid color ctor argument\");\n    }\n  }\n  equals(other) {\n    return !!other \u0026\u0026 RGBA.equals(this.rgba, other.rgba) \u0026\u0026 HSLA.equals(this.hsla, other.hsla) \u0026\u0026 HSVA.equals(this.hsva, other.hsva);\n  }\n  /**\n   * http://www.w3.org/TR/WCAG20/#relativeluminancedef\n   * Returns the number in the set [0, 1]. O =\u003e Darkest Black. 1 =\u003e Lightest white.\n   */\n  getRelativeLuminance() {\n    const R = _Color._relativeLuminanceForComponent(this.rgba.r);\n    const G = _Color._relativeLuminanceForComponent(this.rgba.g);\n    const B = _Color._relativeLuminanceForComponent(this.rgba.b);\n    const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;\n    return roundFloat(luminance, 4);\n  }\n  static _relativeLuminanceForComponent(color) {\n    const c = color / 255;\n    return c \u003c= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);\n  }\n  /**\n   *\thttp://24ways.org/2010/calculating-color-contrast\n   *  Return 'true' if lighter color otherwise 'false'\n   */\n  isLighter() {\n    const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;\n    return yiq \u003e= 128;\n  }\n  isLighterThan(another) {\n    const lum1 = this.getRelativeLuminance();\n    const lum2 = another.getRelativeLuminance();\n    return lum1 \u003e lum2;\n  }\n  isDarkerThan(another) {\n    const lum1 = this.getRelativeLuminance();\n    const lum2 = another.getRelativeLuminance();\n    return lum1 \u003c lum2;\n  }\n  lighten(factor) {\n    return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));\n  }\n  darken(factor) {\n    return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));\n  }\n  transparent(factor) {\n    const { r, g, b, a: a2 } = this.rgba;\n    return new _Color(new RGBA(r, g, b, a2 * factor));\n  }\n  isTransparent() {\n    return this.rgba.a === 0;\n  }\n  isOpaque() {\n    return this.rgba.a === 1;\n  }\n  opposite() {\n    return new _Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));\n  }\n  makeOpaque(opaqueBackground) {\n    if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {\n      return this;\n    }\n    const { r, g, b, a: a2 } = this.rgba;\n    return new _Color(new RGBA(opaqueBackground.rgba.r - a2 * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a2 * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a2 * (opaqueBackground.rgba.b - b), 1));\n  }\n  toString() {\n    if (!this._toString) {\n      this._toString = _Color.Format.CSS.format(this);\n    }\n    return this._toString;\n  }\n  static getLighterColor(of, relative2, factor) {\n    if (of.isLighterThan(relative2)) {\n      return of;\n    }\n    factor = factor ? factor : 0.5;\n    const lum1 = of.getRelativeLuminance();\n    const lum2 = relative2.getRelativeLuminance();\n    factor = factor * (lum2 - lum1) / lum2;\n    return of.lighten(factor);\n  }\n  static getDarkerColor(of, relative2, factor) {\n    if (of.isDarkerThan(relative2)) {\n      return of;\n    }\n    factor = factor ? factor : 0.5;\n    const lum1 = of.getRelativeLuminance();\n    const lum2 = relative2.getRelativeLuminance();\n    factor = factor * (lum1 - lum2) / lum1;\n    return of.darken(factor);\n  }\n};\nColor.white = new Color(new RGBA(255, 255, 255, 1));\nColor.black = new Color(new RGBA(0, 0, 0, 1));\nColor.red = new Color(new RGBA(255, 0, 0, 1));\nColor.blue = new Color(new RGBA(0, 0, 255, 1));\nColor.green = new Color(new RGBA(0, 255, 0, 1));\nColor.cyan = new Color(new RGBA(0, 255, 255, 1));\nColor.lightgrey = new Color(new RGBA(211, 211, 211, 1));\nColor.transparent = new Color(new RGBA(0, 0, 0, 0));\n(function(Color3) {\n  let Format;\n  (function(Format2) {\n    let CSS;\n    (function(CSS2) {\n      function formatRGB(color) {\n        if (color.rgba.a === 1) {\n          return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;\n        }\n        return Color3.Format.CSS.formatRGBA(color);\n      }\n      CSS2.formatRGB = formatRGB;\n      function formatRGBA(color) {\n        return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;\n      }\n      CSS2.formatRGBA = formatRGBA;\n      function formatHSL(color) {\n        if (color.hsla.a === 1) {\n          return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;\n        }\n        return Color3.Format.CSS.formatHSLA(color);\n      }\n      CSS2.formatHSL = formatHSL;\n      function formatHSLA(color) {\n        return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;\n      }\n      CSS2.formatHSLA = formatHSLA;\n      function _toTwoDigitHex(n) {\n        const r = n.toString(16);\n        return r.length !== 2 ? \"0\" + r : r;\n      }\n      function formatHex(color) {\n        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;\n      }\n      CSS2.formatHex = formatHex;\n      function formatHexA(color, compact = false) {\n        if (compact \u0026\u0026 color.rgba.a === 1) {\n          return Color3.Format.CSS.formatHex(color);\n        }\n        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;\n      }\n      CSS2.formatHexA = formatHexA;\n      function format4(color) {\n        if (color.isOpaque()) {\n          return Color3.Format.CSS.formatHex(color);\n        }\n        return Color3.Format.CSS.formatRGBA(color);\n      }\n      CSS2.format = format4;\n      function parseHex(hex) {\n        const length = hex.length;\n        if (length === 0) {\n          return null;\n        }\n        if (hex.charCodeAt(0) !== 35) {\n          return null;\n        }\n        if (length === 7) {\n          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n          return new Color3(new RGBA(r, g, b, 1));\n        }\n        if (length === 9) {\n          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n          const a2 = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));\n          return new Color3(new RGBA(r, g, b, a2 / 255));\n        }\n        if (length === 4) {\n          const r = _parseHexDigit(hex.charCodeAt(1));\n          const g = _parseHexDigit(hex.charCodeAt(2));\n          const b = _parseHexDigit(hex.charCodeAt(3));\n          return new Color3(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));\n        }\n        if (length === 5) {\n          const r = _parseHexDigit(hex.charCodeAt(1));\n          const g = _parseHexDigit(hex.charCodeAt(2));\n          const b = _parseHexDigit(hex.charCodeAt(3));\n          const a2 = _parseHexDigit(hex.charCodeAt(4));\n          return new Color3(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a2 + a2) / 255));\n        }\n        return null;\n      }\n      CSS2.parseHex = parseHex;\n      function _parseHexDigit(charCode) {\n        switch (charCode) {\n          case 48:\n            return 0;\n          case 49:\n            return 1;\n          case 50:\n            return 2;\n          case 51:\n            return 3;\n          case 52:\n            return 4;\n          case 53:\n            return 5;\n          case 54:\n            return 6;\n          case 55:\n            return 7;\n          case 56:\n            return 8;\n          case 57:\n            return 9;\n          case 97:\n            return 10;\n          case 65:\n            return 10;\n          case 98:\n            return 11;\n          case 66:\n            return 11;\n          case 99:\n            return 12;\n          case 67:\n            return 12;\n          case 100:\n            return 13;\n          case 68:\n            return 13;\n          case 101:\n            return 14;\n          case 69:\n            return 14;\n          case 102:\n            return 15;\n          case 70:\n            return 15;\n        }\n        return 0;\n      }\n    })(CSS = Format2.CSS || (Format2.CSS = {}));\n  })(Format = Color3.Format || (Color3.Format = {}));\n})(Color || (Color = {}));\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js\nfunction _parseCaptureGroups(captureGroups) {\n  const values = [];\n  for (const captureGroup of captureGroups) {\n    const parsedNumber = Number(captureGroup);\n    if (parsedNumber || parsedNumber === 0 \u0026\u0026 captureGroup.replace(/\\s/g, \"\") !== \"\") {\n      values.push(parsedNumber);\n    }\n  }\n  return values;\n}\nfunction _toIColor(r, g, b, a2) {\n  return {\n    red: r / 255,\n    blue: b / 255,\n    green: g / 255,\n    alpha: a2\n  };\n}\nfunction _findRange(model, match) {\n  const index = match.index;\n  const length = match[0].length;\n  if (!index) {\n    return;\n  }\n  const startPosition = model.positionAt(index);\n  const range = {\n    startLineNumber: startPosition.lineNumber,\n    startColumn: startPosition.column,\n    endLineNumber: startPosition.lineNumber,\n    endColumn: startPosition.column + length\n  };\n  return range;\n}\nfunction _findHexColorInformation(range, hexValue) {\n  if (!range) {\n    return;\n  }\n  const parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n  if (!parsedHexColor) {\n    return;\n  }\n  return {\n    range,\n    color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n  };\n}\nfunction _findRGBColorInformation(range, matches, isAlpha) {\n  if (!range || matches.length !== 1) {\n    return;\n  }\n  const match = matches[0];\n  const captureGroups = match.values();\n  const parsedRegex = _parseCaptureGroups(captureGroups);\n  return {\n    range,\n    color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n  };\n}\nfunction _findHSLColorInformation(range, matches, isAlpha) {\n  if (!range || matches.length !== 1) {\n    return;\n  }\n  const match = matches[0];\n  const captureGroups = match.values();\n  const parsedRegex = _parseCaptureGroups(captureGroups);\n  const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\n  return {\n    range,\n    color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n  };\n}\nfunction _findMatches(model, regex) {\n  if (typeof model === \"string\") {\n    return [...model.matchAll(regex)];\n  } else {\n    return model.findMatches(regex);\n  }\n}\nfunction computeColors(model) {\n  const result = [];\n  const initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|(#)([A-Fa-f0-9]{3})\\b|(#)([A-Fa-f0-9]{4})\\b|(#)([A-Fa-f0-9]{6})\\b|(#)([A-Fa-f0-9]{8})\\b/gm;\n  const initialValidationMatches = _findMatches(model, initialValidationRegex);\n  if (initialValidationMatches.length \u003e 0) {\n    for (const initialMatch of initialValidationMatches) {\n      const initialCaptureGroups = initialMatch.filter((captureGroup) =\u003e captureGroup !== void 0);\n      const colorScheme = initialCaptureGroups[1];\n      const colorParameters = initialCaptureGroups[2];\n      if (!colorParameters) {\n        continue;\n      }\n      let colorInformation;\n      if (colorScheme === \"rgb\") {\n        const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n        colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n      } else if (colorScheme === \"rgba\") {\n        const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n        colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n      } else if (colorScheme === \"hsl\") {\n        const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n        colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n      } else if (colorScheme === \"hsla\") {\n        const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n        colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n      } else if (colorScheme === \"#\") {\n        colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n      }\n      if (colorInformation) {\n        result.push(colorInformation);\n      }\n    }\n  }\n  return result;\n}\nfunction computeDefaultDocumentColors(model) {\n  if (!model || typeof model.getValue !== \"function\" || typeof model.positionAt !== \"function\") {\n    return [];\n  }\n  return computeColors(model);\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js\nvar MirrorModel = class extends MirrorTextModel {\n  get uri() {\n    return this._uri;\n  }\n  get eol() {\n    return this._eol;\n  }\n  getValue() {\n    return this.getText();\n  }\n  findMatches(regex) {\n    const matches = [];\n    for (let i = 0; i \u003c this._lines.length; i++) {\n      const line = this._lines[i];\n      const offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n      const iteratorOverMatches = line.matchAll(regex);\n      for (const match of iteratorOverMatches) {\n        if (match.index || match.index === 0) {\n          match.index = match.index + offsetToAdd;\n        }\n        matches.push(match);\n      }\n    }\n    return matches;\n  }\n  getLinesContent() {\n    return this._lines.slice(0);\n  }\n  getLineCount() {\n    return this._lines.length;\n  }\n  getLineContent(lineNumber) {\n    return this._lines[lineNumber - 1];\n  }\n  getWordAtPosition(position, wordDefinition) {\n    const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n    if (wordAtText) {\n      return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n    }\n    return null;\n  }\n  words(wordDefinition) {\n    const lines = this._lines;\n    const wordenize = this._wordenize.bind(this);\n    let lineNumber = 0;\n    let lineText = \"\";\n    let wordRangesIdx = 0;\n    let wordRanges = [];\n    return {\n      *[Symbol.iterator]() {\n        while (true) {\n          if (wordRangesIdx \u003c wordRanges.length) {\n            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n            wordRangesIdx += 1;\n            yield value;\n          } else {\n            if (lineNumber \u003c lines.length) {\n              lineText = lines[lineNumber];\n              wordRanges = wordenize(lineText, wordDefinition);\n              wordRangesIdx = 0;\n              lineNumber += 1;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    };\n  }\n  getLineWords(lineNumber, wordDefinition) {\n    const content = this._lines[lineNumber - 1];\n    const ranges = this._wordenize(content, wordDefinition);\n    const words = [];\n    for (const range of ranges) {\n      words.push({\n        word: content.substring(range.start, range.end),\n        startColumn: range.start + 1,\n        endColumn: range.end + 1\n      });\n    }\n    return words;\n  }\n  _wordenize(content, wordDefinition) {\n    const result = [];\n    let match;\n    wordDefinition.lastIndex = 0;\n    while (match = wordDefinition.exec(content)) {\n      if (match[0].length === 0) {\n        break;\n      }\n      result.push({ start: match.index, end: match.index + match[0].length });\n    }\n    return result;\n  }\n  getValueInRange(range) {\n    range = this._validateRange(range);\n    if (range.startLineNumber === range.endLineNumber) {\n      return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n    }\n    const lineEnding = this._eol;\n    const startLineIndex = range.startLineNumber - 1;\n    const endLineIndex = range.endLineNumber - 1;\n    const resultLines = [];\n    resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n    for (let i = startLineIndex + 1; i \u003c endLineIndex; i++) {\n      resultLines.push(this._lines[i]);\n    }\n    resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n    return resultLines.join(lineEnding);\n  }\n  offsetAt(position) {\n    position = this._validatePosition(position);\n    this._ensureLineStarts();\n    return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n  }\n  positionAt(offset) {\n    offset = Math.floor(offset);\n    offset = Math.max(0, offset);\n    this._ensureLineStarts();\n    const out = this._lineStarts.getIndexOf(offset);\n    const lineLength = this._lines[out.index].length;\n    return {\n      lineNumber: 1 + out.index,\n      column: 1 + Math.min(out.remainder, lineLength)\n    };\n  }\n  _validateRange(range) {\n    const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n    const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n    if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {\n      return {\n        startLineNumber: start.lineNumber,\n        startColumn: start.column,\n        endLineNumber: end.lineNumber,\n        endColumn: end.column\n      };\n    }\n    return range;\n  }\n  _validatePosition(position) {\n    if (!Position.isIPosition(position)) {\n      throw new Error(\"bad position\");\n    }\n    let { lineNumber, column } = position;\n    let hasChanged = false;\n    if (lineNumber \u003c 1) {\n      lineNumber = 1;\n      column = 1;\n      hasChanged = true;\n    } else if (lineNumber \u003e this._lines.length) {\n      lineNumber = this._lines.length;\n      column = this._lines[lineNumber - 1].length + 1;\n      hasChanged = true;\n    } else {\n      const maxCharacter = this._lines[lineNumber - 1].length + 1;\n      if (column \u003c 1) {\n        column = 1;\n        hasChanged = true;\n      } else if (column \u003e maxCharacter) {\n        column = maxCharacter;\n        hasChanged = true;\n      }\n    }\n    if (!hasChanged) {\n      return position;\n    } else {\n      return { lineNumber, column };\n    }\n  }\n};\nvar EditorSimpleWorker = class _EditorSimpleWorker {\n  constructor(host, foreignModuleFactory) {\n    this._host = host;\n    this._models = /* @__PURE__ */ Object.create(null);\n    this._foreignModuleFactory = foreignModuleFactory;\n    this._foreignModule = null;\n  }\n  dispose() {\n    this._models = /* @__PURE__ */ Object.create(null);\n  }\n  _getModel(uri) {\n    return this._models[uri];\n  }\n  _getModels() {\n    const all = [];\n    Object.keys(this._models).forEach((key) =\u003e all.push(this._models[key]));\n    return all;\n  }\n  acceptNewModel(data) {\n    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n  }\n  acceptModelChanged(strURL, e) {\n    if (!this._models[strURL]) {\n      return;\n    }\n    const model = this._models[strURL];\n    model.onEvents(e);\n  }\n  acceptRemovedModel(strURL) {\n    if (!this._models[strURL]) {\n      return;\n    }\n    delete this._models[strURL];\n  }\n  async computeUnicodeHighlights(url, options, range) {\n    const model = this._getModel(url);\n    if (!model) {\n      return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n    }\n    return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n  }\n  // ---- BEGIN diff --------------------------------------------------------------------------\n  async computeDiff(originalUrl, modifiedUrl, options, algorithm) {\n    const original = this._getModel(originalUrl);\n    const modified = this._getModel(modifiedUrl);\n    if (!original || !modified) {\n      return null;\n    }\n    return _EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n  }\n  static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\n    const diffAlgorithm = algorithm === \"advanced\" ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n    const originalLines = originalTextModel.getLinesContent();\n    const modifiedLines = modifiedTextModel.getLinesContent();\n    const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n    const identical = result.changes.length \u003e 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);\n    function getLineChanges(changes) {\n      return changes.map((m) =\u003e {\n        var _a4;\n        return [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a4 = m.innerChanges) === null || _a4 === void 0 ? void 0 : _a4.map((m2) =\u003e [\n          m2.originalRange.startLineNumber,\n          m2.originalRange.startColumn,\n          m2.originalRange.endLineNumber,\n          m2.originalRange.endColumn,\n          m2.modifiedRange.startLineNumber,\n          m2.modifiedRange.startColumn,\n          m2.modifiedRange.endLineNumber,\n          m2.modifiedRange.endColumn\n        ])];\n      });\n    }\n    return {\n      identical,\n      quitEarly: result.hitTimeout,\n      changes: getLineChanges(result.changes),\n      moves: result.moves.map((m) =\u003e [\n        m.lineRangeMapping.original.startLineNumber,\n        m.lineRangeMapping.original.endLineNumberExclusive,\n        m.lineRangeMapping.modified.startLineNumber,\n        m.lineRangeMapping.modified.endLineNumberExclusive,\n        getLineChanges(m.changes)\n      ])\n    };\n  }\n  static _modelsAreIdentical(original, modified) {\n    const originalLineCount = original.getLineCount();\n    const modifiedLineCount = modified.getLineCount();\n    if (originalLineCount !== modifiedLineCount) {\n      return false;\n    }\n    for (let line = 1; line \u003c= originalLineCount; line++) {\n      const originalLine = original.getLineContent(line);\n      const modifiedLine = modified.getLineContent(line);\n      if (originalLine !== modifiedLine) {\n        return false;\n      }\n    }\n    return true;\n  }\n  async computeMoreMinimalEdits(modelUrl, edits, pretty) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return edits;\n    }\n    const result = [];\n    let lastEol = void 0;\n    edits = edits.slice(0).sort((a2, b) =\u003e {\n      if (a2.range \u0026\u0026 b.range) {\n        return Range.compareRangesUsingStarts(a2.range, b.range);\n      }\n      const aRng = a2.range ? 0 : 1;\n      const bRng = b.range ? 0 : 1;\n      return aRng - bRng;\n    });\n    let writeIndex = 0;\n    for (let readIndex = 1; readIndex \u003c edits.length; readIndex++) {\n      if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n        edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n        edits[writeIndex].text += edits[readIndex].text;\n      } else {\n        writeIndex++;\n        edits[writeIndex] = edits[readIndex];\n      }\n    }\n    edits.length = writeIndex + 1;\n    for (let { range, text, eol } of edits) {\n      if (typeof eol === \"number\") {\n        lastEol = eol;\n      }\n      if (Range.isEmpty(range) \u0026\u0026 !text) {\n        continue;\n      }\n      const original = model.getValueInRange(range);\n      text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n      if (original === text) {\n        continue;\n      }\n      if (Math.max(text.length, original.length) \u003e _EditorSimpleWorker._diffLimit) {\n        result.push({ range, text });\n        continue;\n      }\n      const changes = stringDiff(original, text, pretty);\n      const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n      for (const change of changes) {\n        const start = model.positionAt(editOffset + change.originalStart);\n        const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n        const newEdit = {\n          text: text.substr(change.modifiedStart, change.modifiedLength),\n          range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n        };\n        if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n          result.push(newEdit);\n        }\n      }\n    }\n    if (typeof lastEol === \"number\") {\n      result.push({ eol: lastEol, text: \"\", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n    }\n    return result;\n  }\n  // ---- END minimal edits ---------------------------------------------------------------\n  async computeLinks(modelUrl) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return null;\n    }\n    return computeLinks(model);\n  }\n  // --- BEGIN default document colors -----------------------------------------------------------\n  async computeDefaultDocumentColors(modelUrl) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return null;\n    }\n    return computeDefaultDocumentColors(model);\n  }\n  async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n    const sw = new StopWatch();\n    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n    const seen = /* @__PURE__ */ new Set();\n    outer:\n      for (const url of modelUrls) {\n        const model = this._getModel(url);\n        if (!model) {\n          continue;\n        }\n        for (const word of model.words(wordDefRegExp)) {\n          if (word === leadingWord || !isNaN(Number(word))) {\n            continue;\n          }\n          seen.add(word);\n          if (seen.size \u003e _EditorSimpleWorker._suggestionsLimit) {\n            break outer;\n          }\n        }\n      }\n    return { words: Array.from(seen), duration: sw.elapsed() };\n  }\n  // ---- END suggest --------------------------------------------------------------------------\n  //#region -- word ranges --\n  async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return /* @__PURE__ */ Object.create(null);\n    }\n    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n    const result = /* @__PURE__ */ Object.create(null);\n    for (let line = range.startLineNumber; line \u003c range.endLineNumber; line++) {\n      const words = model.getLineWords(line, wordDefRegExp);\n      for (const word of words) {\n        if (!isNaN(Number(word.word))) {\n          continue;\n        }\n        let array = result[word.word];\n        if (!array) {\n          array = [];\n          result[word.word] = array;\n        }\n        array.push({\n          startLineNumber: line,\n          startColumn: word.startColumn,\n          endLineNumber: line,\n          endColumn: word.endColumn\n        });\n      }\n    }\n    return result;\n  }\n  //#endregion\n  async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n    const model = this._getModel(modelUrl);\n    if (!model) {\n      return null;\n    }\n    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n    if (range.startColumn === range.endColumn) {\n      range = {\n        startLineNumber: range.startLineNumber,\n        startColumn: range.startColumn,\n        endLineNumber: range.endLineNumber,\n        endColumn: range.endColumn + 1\n      };\n    }\n    const selectionText = model.getValueInRange(range);\n    const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n    if (!wordRange) {\n      return null;\n    }\n    const word = model.getValueInRange(wordRange);\n    const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n    return result;\n  }\n  // ---- BEGIN foreign module support --------------------------------------------------------------------------\n  loadForeignModule(moduleId, createData, foreignHostMethods) {\n    const proxyMethodRequest = (method, args) =\u003e {\n      return this._host.fhr(method, args);\n    };\n    const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n    const ctx = {\n      host: foreignHost,\n      getMirrorModels: () =\u003e {\n        return this._getModels();\n      }\n    };\n    if (this._foreignModuleFactory) {\n      this._foreignModule = this._foreignModuleFactory(ctx, createData);\n      return Promise.resolve(getAllMethodNames(this._foreignModule));\n    }\n    return Promise.reject(new Error(`Unexpected usage`));\n  }\n  // foreign method request\n  fmr(method, args) {\n    if (!this._foreignModule || typeof this._foreignModule[method] !== \"function\") {\n      return Promise.reject(new Error(\"Missing requestHandler or method: \" + method));\n    }\n    try {\n      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n};\nEditorSimpleWorker._diffLimit = 1e5;\nEditorSimpleWorker._suggestionsLimit = 1e4;\nif (typeof importScripts === \"function\") {\n  globalThis.monaco = createMonacoBaseAPI();\n}\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/editor/editor.worker.js\nvar initialized = false;\nfunction initialize(foreignModule) {\n  if (initialized) {\n    return;\n  }\n  initialized = true;\n  const simpleWorker = new SimpleWorkerServer((msg) =\u003e {\n    globalThis.postMessage(msg);\n  }, (host) =\u003e new EditorSimpleWorker(host, foreignModule));\n  globalThis.onmessage = (e) =\u003e {\n    simpleWorker.onmessage(e.data);\n  };\n}\nglobalThis.onmessage = (e) =\u003e {\n  if (!initialized) {\n    initialize(null);\n  }\n};\n\n// ../esmd/npm/monaco-editor@0.45.0/node_modules/.pnpm/monaco-editor@0.45.0/node_modules/monaco-editor/esm/vs/language/json/json.worker.js\nfunction createScanner(text, ignoreTrivia) {\n  if (ignoreTrivia === void 0) {\n    ignoreTrivia = false;\n  }\n  var len = text.length;\n  var pos = 0, value = \"\", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;\n  function scanHexDigits(count, exact) {\n    var digits = 0;\n    var value2 = 0;\n    while (digits \u003c count || !exact) {\n      var ch = text.charCodeAt(pos);\n      if (ch \u003e= 48 \u0026\u0026 ch \u003c= 57) {\n        value2 = value2 * 16 + ch - 48;\n      } else if (ch \u003e= 65 \u0026\u0026 ch \u003c= 70) {\n        value2 = value2 * 16 + ch - 65 + 10;\n      } else if (ch \u003e= 97 \u0026\u0026 ch \u003c= 102) {\n        value2 = value2 * 16 + ch - 97 + 10;\n      } else {\n        break;\n      }\n      pos++;\n      digits++;\n    }\n    if (digits \u003c count) {\n      value2 = -1;\n    }\n    return value2;\n  }\n  function setPosition(newPosition) {\n    pos = newPosition;\n    value = \"\";\n    tokenOffset = 0;\n    token = 16;\n    scanError = 0;\n  }\n  function scanNumber() {\n    var start = pos;\n    if (text.charCodeAt(pos) === 48) {\n      pos++;\n    } else {\n      pos++;\n      while (pos \u003c text.length \u0026\u0026 isDigit(text.charCodeAt(pos))) {\n        pos++;\n      }\n    }\n    if (pos \u003c text.length \u0026\u0026 text.charCodeAt(pos) === 46) {\n      pos++;\n      if (pos \u003c text.length \u0026\u0026 isDigit(text.charCodeAt(pos))) {\n        pos++;\n        while (pos \u003c text.length \u0026\u0026 isDigit(text.charCodeAt(pos))) {\n          pos++;\n        }\n      } else {\n        scanError = 3;\n        return text.substring(start, pos);\n      }\n    }\n    var end = pos;\n    if (pos \u003c text.length \u0026\u0026 (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {\n      pos++;\n      if (pos \u003c text.length \u0026\u0026 text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {\n        pos++;\n      }\n      if (pos \u003c text.length \u0026\u0026 isDigit(text.charCodeAt(pos))) {\n        pos++;\n        while (pos \u003c text.length \u0026\u0026 isDigit(text.charCodeAt(pos))) {\n          pos++;\n        }\n        end = pos;\n      } else {\n        scanError = 3;\n      }\n    }\n    return text.substring(start, end);\n  }\n  function scanString() {\n    var result = \"\", start = pos;\n    while (true) {\n      if (pos \u003e= len) {\n        result += text.substring(start, pos);\n        scanError = 2;\n        break;\n      }\n      var ch = text.charCodeAt(pos);\n      if (ch === 34) {\n        result += text.substring(start, pos);\n        pos++;\n        break;\n      }\n      if (ch === 92) {\n        result += text.substring(start, pos);\n        pos++;\n        if (pos \u003e= len) {\n          scanError = 2;\n          break;\n        }\n        var ch2 = text.charCodeAt(pos++);\n        switch (ch2) {\n          case 34:\n            result += '\"';\n            break;\n          case 92:\n            result += \"\\\\\";\n            break;\n          case 47:\n            result += \"/\";\n            break;\n          case 98:\n            result += \"\\b\";\n            break;\n          case 102:\n            result += \"\\f\";\n            break;\n          case 110:\n            result += \"\\n\";\n            break;\n          case 114:\n            result += \"\\r\";\n            break;\n          case 116:\n            result += \"\t\";\n            break;\n          case 117:\n            var ch3 = scanHexDigits(4, true);\n            if (ch3 \u003e= 0) {\n              result += String.fromCharCode(ch3);\n            } else {\n              scanError = 4;\n            }\n            break;\n          default:\n            scanError = 5;\n        }\n        start = pos;\n        continue;\n      }\n      if (ch \u003e= 0 \u0026\u0026 ch \u003c= 31) {\n        if (isLineBreak(ch)) {\n          result += text.substring(start, pos);\n          scanError = 2;\n          break;\n        } else {\n          scanError = 6;\n        }\n      }\n      pos++;\n    }\n    return result;\n  }\n  function scanNext() {\n    value = \"\";\n    scanError = 0;\n    tokenOffset = pos;\n    lineStartOffset = lineNumber;\n    prevTokenLineStartOffset = tokenLineStartOffset;\n    if (pos \u003e= len) {\n      tokenOffset = len;\n      return token = 17;\n    }\n    var code = text.charCodeAt(pos);\n    if (isWhiteSpace(code)) {\n      do {\n        pos++;\n        value += String.fromCharCode(code);\n        code = text.charCodeAt(pos);\n      } while (isWhiteSpace(code));\n      return token = 15;\n    }\n    if (isLineBreak(code)) {\n      pos++;\n      value += String.fromCharCode(code);\n      if (code === 13 \u0026\u0026 text.charCodeAt(pos) === 10) {\n        pos++;\n        value += \"\\n\";\n      }\n      lineNumber++;\n      tokenLineStartOffset = pos;\n      return token = 14;\n    }\n    switch (code) {\n      case 123:\n        pos++;\n        return token = 1;\n      case 125:\n        pos++;\n        return token = 2;\n      case 91:\n        pos++;\n        return token = 3;\n      case 93:\n        pos++;\n        return token = 4;\n      case 58:\n        pos++;\n        return token = 6;\n      case 44:\n        pos++;\n        return token = 5;\n      case 34:\n        pos++;\n        value = scanString();\n        return token = 10;\n      case 47:\n        var start = pos - 1;\n        if (text.charCodeAt(pos + 1) === 47) {\n          pos += 2;\n          while (pos \u003c len) {\n            if (isLineBreak(text.charCodeAt(pos))) {\n              break;\n            }\n            pos++;\n          }\n          value = text.substring(start, pos);\n          return token = 12;\n        }\n        if (text.charCodeAt(pos + 1) === 42) {\n          pos += 2;\n          var safeLength = len - 1;\n          var commentClosed = false;\n          while (pos \u003c safeLength) {\n            var ch = text.charCodeAt(pos);\n            if (ch === 42 \u0026\u0026 text.charCodeAt(pos + 1) === 47) {\n              pos += 2;\n              commentClosed = true;\n              break;\n            }\n            pos++;\n            if (isLineBreak(ch)) {\n              if (ch === 13 \u0026\u0026 text.charCodeAt(pos) === 10) {\n                pos++;\n              }\n              lineNumber++;\n              tokenLineStartOffset = pos;\n            }\n          }\n          if (!commentClosed) {\n            pos++;\n            scanError = 1;\n          }\n          value = text.substring(start, pos);\n          return token = 13;\n        }\n        value += String.fromCharCode(code);\n        pos++;\n        return token = 16;\n      case 45:\n        value += String.fromCharCode(code);\n        pos++;\n        if (pos === len || !isDigit(text.charCodeAt(pos))) {\n          return token = 16;\n        }\n      case 48:\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        value += scanNumber();\n        return token = 11;\n      default:\n        while (pos \u003c len \u0026\u0026 isUnknownContentCharacter(code)) {\n          pos++;\n          code = text.charCodeAt(pos);\n        }\n        if (tokenOffset !== pos) {\n          value = text.substring(tokenOffset, pos);\n          switch (value) {\n            case \"true\":\n              return token = 8;\n            case \"false\":\n              return token = 9;\n            case \"null\":\n              return token = 7;\n          }\n          return token = 16;\n        }\n        value += String.fromCharCode(code);\n        pos++;\n        return token = 16;\n    }\n  }\n  function isUnknownContentCharacter(code) {\n    if (isWhiteSpace(code) || isLineBreak(code)) {\n      return false;\n    }\n    switch (code) {\n      case 125:\n      case 93:\n      case 123:\n      case 91:\n      case 34:\n      case 58:\n      case 44:\n      case 47:\n        return false;\n    }\n    return true;\n  }\n  function scanNextNonTrivia() {\n    var result;\n    do {\n      result = scanNext();\n    } while (result \u003e= 12 \u0026\u0026 result \u003c= 15);\n    return result;\n  }\n  return {\n    setPosition,\n    getPosition: function() {\n      return pos;\n    },\n    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n    getToken: function() {\n      return token;\n    },\n    getTokenValue: function() {\n      return value;\n    },\n    getTokenOffset: function() {\n      return tokenOffset;\n    },\n    getTokenLength: function() {\n      return pos - tokenOffset;\n    },\n    getTokenStartLine: function() {\n      return lineStartOffset;\n    },\n    getTokenStartCharacter: function() {\n      return tokenOffset - prevTokenLineStartOffset;\n    },\n    getTokenError: function() {\n      return scanError;\n    }\n  };\n}\nfunction isWhiteSpace(ch) {\n  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch \u003e= 8192 \u0026\u0026 ch \u003c= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;\n}\nfunction isLineBreak(ch) {\n  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;\n}\nfunction isDigit(ch) {\n  return ch \u003e= 48 \u0026\u0026 ch \u003c= 57;\n}\nfunction format(documentText, range, options) {\n  var initialIndentLevel;\n  var formatText;\n  var formatTextStart;\n  var rangeStart;\n  var rangeEnd;\n  if (range) {\n    rangeStart = range.offset;\n    rangeEnd = rangeStart + range.length;\n    formatTextStart = rangeStart;\n    while (formatTextStart \u003e 0 \u0026\u0026 !isEOL(documentText, formatTextStart - 1)) {\n      formatTextStart--;\n    }\n    var endOffset = rangeEnd;\n    while (endOffset \u003c documentText.length \u0026\u0026 !isEOL(documentText, endOffset)) {\n      endOffset++;\n    }\n    formatText = documentText.substring(formatTextStart, endOffset);\n    initialIndentLevel = computeIndentLevel(formatText, options);\n  } else {\n    formatText = documentText;\n    initialIndentLevel = 0;\n    formatTextStart = 0;\n    rangeStart = 0;\n    rangeEnd = documentText.length;\n  }\n  var eol = getEOL(options, documentText);\n  var lineBreak = false;\n  var indentLevel = 0;\n  var indentValue;\n  if (options.insertSpaces) {\n    indentValue = repeat(\" \", options.tabSize || 4);\n  } else {\n    indentValue = \"\t\";\n  }\n  var scanner = createScanner(formatText, false);\n  var hasError = false;\n  function newLineAndIndent() {\n    return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n  }\n  function scanNext() {\n    var token = scanner.scan();\n    lineBreak = false;\n    while (token === 15 || token === 14) {\n      lineBreak = lineBreak || token === 14;\n      token = scanner.scan();\n    }\n    hasError = token === 16 || scanner.getTokenError() !== 0;\n    return token;\n  }\n  var editOperations = [];\n  function addEdit(text, startOffset, endOffset2) {\n    if (!hasError \u0026\u0026 (!range || startOffset \u003c rangeEnd \u0026\u0026 endOffset2 \u003e rangeStart) \u0026\u0026 documentText.substring(startOffset, endOffset2) !== text) {\n      editOperations.push({ offset: startOffset, length: endOffset2 - startOffset, content: text });\n    }\n  }\n  var firstToken = scanNext();\n  if (firstToken !== 17) {\n    var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n    var initialIndent = repeat(indentValue, initialIndentLevel);\n    addEdit(initialIndent, formatTextStart, firstTokenStart);\n  }\n  while (firstToken !== 17) {\n    var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n    var secondToken = scanNext();\n    var replaceContent = \"\";\n    var needsLineBreak = false;\n    while (!lineBreak \u0026\u0026 (secondToken === 12 || secondToken === 13)) {\n      var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n      addEdit(\" \", firstTokenEnd, commentTokenStart);\n      firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n      needsLineBreak = secondToken === 12;\n      replaceContent = needsLineBreak ? newLineAndIndent() : \"\";\n      secondToken = scanNext();\n    }\n    if (secondToken === 2) {\n      if (firstToken !== 1) {\n        indentLevel--;\n        replaceContent = newLineAndIndent();\n      }\n    } else if (secondToken === 4) {\n      if (firstToken !== 3) {\n        indentLevel--;\n        replaceContent = newLineAndIndent();\n      }\n    } else {\n      switch (firstToken) {\n        case 3:\n        case 1:\n          indentLevel++;\n          replaceContent = newLineAndIndent();\n          break;\n        case 5:\n        case 12:\n          replaceContent = newLineAndIndent();\n          break;\n        case 13:\n          if (lineBreak) {\n            replaceContent = newLineAndIndent();\n          } else if (!needsLineBreak) {\n            replaceContent = \" \";\n          }\n          break;\n        case 6:\n          if (!needsLineBreak) {\n            replaceContent = \" \";\n          }\n          break;\n        case 10:\n          if (secondToken === 6) {\n            if (!needsLineBreak) {\n              replaceContent = \"\";\n            }\n            break;\n          }\n        case 7:\n        case 8:\n        case 9:\n        case 11:\n        case 2:\n        case 4:\n          if (secondToken === 12 || secondToken === 13) {\n            if (!needsLineBreak) {\n              replaceContent = \" \";\n            }\n          } else if (secondToken !== 5 \u0026\u0026 secondToken !== 17) {\n            hasError = true;\n          }\n          break;\n        case 16:\n          hasError = true;\n          break;\n      }\n      if (lineBreak \u0026\u0026 (secondToken === 12 || secondToken === 13)) {\n        replaceContent = newLineAndIndent();\n      }\n    }\n    if (secondToken === 17) {\n      replaceContent = options.insertFinalNewline ? eol : \"\";\n    }\n    var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n    addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n    firstToken = secondToken;\n  }\n  return editOperations;\n}\nfunction repeat(s, count) {\n  var result = \"\";\n  for (var i = 0; i \u003c count; i++) {\n    result += s;\n  }\n  return result;\n}\nfunction computeIndentLevel(content, options) {\n  var i = 0;\n  var nChars = 0;\n  var tabSize = options.tabSize || 4;\n  while (i \u003c content.length) {\n    var ch = content.charAt(i);\n    if (ch === \" \") {\n      nChars++;\n    } else if (ch === \"\t\") {\n      nChars += tabSize;\n    } else {\n      break;\n    }\n    i++;\n  }\n  return Math.floor(nChars / tabSize);\n}\nfunction getEOL(options, text) {\n  for (var i = 0; i \u003c text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch === \"\\r\") {\n      if (i + 1 \u003c text.length \u0026\u0026 text.charAt(i + 1) === \"\\n\") {\n        return \"\\r\\n\";\n      }\n      return \"\\r\";\n    } else if (ch === \"\\n\") {\n      return \"\\n\";\n    }\n  }\n  return options \u0026\u0026 options.eol || \"\\n\";\n}\nfunction isEOL(text, offset) {\n  return \"\\r\\n\".indexOf(text.charAt(offset)) !== -1;\n}\nvar ParseOptions;\n(function(ParseOptions2) {\n  ParseOptions2.DEFAULT = {\n    allowTrailingComma: false\n  };\n})(ParseOptions || (ParseOptions = {}));\nfunction parse(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n  var currentProperty = null;\n  var currentParent = [];\n  var previousParents = [];\n  function onValue(value) {\n    if (Array.isArray(currentParent)) {\n      currentParent.push(value);\n    } else if (currentProperty !== null) {\n      currentParent[currentProperty] = value;\n    }\n  }\n  var visitor = {\n    onObjectBegin: function() {\n      var object = {};\n      onValue(object);\n      previousParents.push(currentParent);\n      currentParent = object;\n      currentProperty = null;\n    },\n    onObjectProperty: function(name) {\n      currentProperty = name;\n    },\n    onObjectEnd: function() {\n      currentParent = previousParents.pop();\n    },\n    onArrayBegin: function() {\n      var array = [];\n      onValue(array);\n      previousParents.push(currentParent);\n      currentParent = array;\n      currentProperty = null;\n    },\n    onArrayEnd: function() {\n      currentParent = previousParents.pop();\n    },\n    onLiteralValue: onValue,\n    onError: function(error, offset, length) {\n      errors.push({ error, offset, length });\n    }\n  };\n  visit(text, visitor, options);\n  return currentParent[0];\n}\nfunction getNodePath(node) {\n  if (!node.parent || !node.parent.children) {\n    return [];\n  }\n  var path = getNodePath(node.parent);\n  if (node.parent.type === \"property\") {\n    var key = node.parent.children[0].value;\n    path.push(key);\n  } else if (node.parent.type === \"array\") {\n    var index = node.parent.children.indexOf(node);\n    if (index !== -1) {\n      path.push(index);\n    }\n  }\n  return path;\n}\nfunction getNodeValue(node) {\n  switch (node.type) {\n    case \"array\":\n      return node.children.map(getNodeValue);\n    case \"object\":\n      var obj = /* @__PURE__ */ Object.create(null);\n      for (var _i = 0, _a4 = node.children; _i \u003c _a4.length; _i++) {\n        var prop = _a4[_i];\n        var valueNode = prop.children[1];\n        if (valueNode) {\n          obj[prop.children[0].value] = getNodeValue(valueNode);\n        }\n      }\n      return obj;\n    case \"null\":\n    case \"string\":\n    case \"number\":\n    case \"boolean\":\n      return node.value;\n    default:\n      return void 0;\n  }\n}\nfunction contains(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n  return offset \u003e= node.offset \u0026\u0026 offset \u003c node.offset + node.length || includeRightBound \u0026\u0026 offset === node.offset + node.length;\n}\nfunction findNodeAtOffset(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n  if (contains(node, offset, includeRightBound)) {\n    var children = node.children;\n    if (Array.isArray(children)) {\n      for (var i = 0; i \u003c children.length \u0026\u0026 children[i].offset \u003c= offset; i++) {\n        var item = findNodeAtOffset(children[i], offset, includeRightBound);\n        if (item) {\n          return item;\n        }\n      }\n    }\n    return node;\n  }\n  return void 0;\n}\nfunction visit(text, visitor, options) {\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n  var _scanner = createScanner(text, false);\n  function toNoArgVisit(visitFunction) {\n    return visitFunction ? function() {\n      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function() {\n      return true;\n    };\n  }\n  function toOneArgVisit(visitFunction) {\n    return visitFunction ? function(arg) {\n      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function() {\n      return true;\n    };\n  }\n  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n  var disallowComments = options \u0026\u0026 options.disallowComments;\n  var allowTrailingComma = options \u0026\u0026 options.allowTrailingComma;\n  function scanNext() {\n    while (true) {\n      var token = _scanner.scan();\n      switch (_scanner.getTokenError()) {\n        case 4:\n          handleError(14);\n          break;\n        case 5:\n          handleError(15);\n          break;\n        case 3:\n          handleError(13);\n          break;\n        case 1:\n          if (!disallowComments) {\n            handleError(11);\n          }\n          break;\n        case 2:\n          handleError(12);\n          break;\n        case 6:\n          handleError(16);\n          break;\n      }\n      switch (token) {\n        case 12:\n        case 13:\n          if (disallowComments) {\n            handleError(10);\n          } else {\n            onComment();\n          }\n          break;\n        case 16:\n          handleError(1);\n          break;\n        case 15:\n        case 14:\n          break;\n        default:\n          return token;\n      }\n    }\n  }\n  function handleError(error, skipUntilAfter, skipUntil) {\n    if (skipUntilAfter === void 0) {\n      skipUntilAfter = [];\n    }\n    if (skipUntil === void 0) {\n      skipUntil = [];\n    }\n    onError(error);\n    if (skipUntilAfter.length + skipUntil.length \u003e 0) {\n      var token = _scanner.getToken();\n      while (token !== 17) {\n        if (skipUntilAfter.indexOf(token) !== -1) {\n          scanNext();\n          break;\n        } else if (skipUntil.indexOf(token) !== -1) {\n          break;\n        }\n        token = scanNext();\n      }\n    }\n  }\n  function parseString(isValue) {\n    var value = _scanner.getTokenValue();\n    if (isValue) {\n      onLiteralValue(value);\n    } else {\n      onObjectProperty(value);\n    }\n    scanNext();\n    return true;\n  }\n  function parseLiteral() {\n    switch (_scanner.getToken()) {\n      case 11:\n        var tokenValue = _scanner.getTokenValue();\n        var value = Number(tokenValue);\n        if (isNaN(value)) {\n          handleError(2);\n          value = 0;\n        }\n        onLiteralValue(value);\n        break;\n      case 7:\n        onLiteralValue(null);\n        break;\n      case 8:\n        onLiteralValue(true);\n        break;\n      case 9:\n        onLiteralValue(false);\n        break;\n      default:\n        return false;\n    }\n    scanNext();\n    return true;\n  }\n  function parseProperty() {\n    if (_scanner.getToken() !== 10) {\n      handleError(3, [], [2, 5]);\n      return false;\n    }\n    parseString(false);\n    if (_scanner.getToken() === 6) {\n      onSeparator(\":\");\n      scanNext();\n      if (!parseValue()) {\n        handleError(4, [], [2, 5]);\n      }\n    } else {\n      handleError(5, [], [2, 5]);\n    }\n    return true;\n  }\n  function parseObject() {\n    onObjectBegin();\n    scanNext();\n    var needsComma = false;\n    while (_scanner.getToken() !== 2 \u0026\u0026 _scanner.getToken() !== 17) {\n      if (_scanner.getToken() === 5) {\n        if (!needsComma) {\n          handleError(4, [], []);\n        }\n        onSeparator(\",\");\n        scanNext();\n        if (_scanner.getToken() === 2 \u0026\u0026 allowTrailingComma) {\n          break;\n        }\n      } else if (needsComma) {\n        handleError(6, [], []);\n      }\n      if (!parseProperty()) {\n        handleError(4, [], [2, 5]);\n      }\n      needsComma = true;\n    }\n    onObjectEnd();\n    if (_scanner.getToken() !== 2) {\n      handleError(7, [2], []);\n    } else {\n      scanNext();\n    }\n    return true;\n  }\n  function parseArray() {\n    onArrayBegin();\n    scanNext();\n    var needsComma = false;\n    while (_scanner.getToken() !== 4 \u0026\u0026 _scanner.getToken() !== 17) {\n      if (_scanner.getToken() === 5) {\n        if (!needsComma) {\n          handleError(4, [], []);\n        }\n        onSeparator(\",\");\n        scanNext();\n        if (_scanner.getToken() === 4 \u0026\u0026 allowTrailingComma) {\n          break;\n        }\n      } else if (needsComma) {\n        handleError(6, [], []);\n      }\n      if (!parseValue()) {\n        handleError(4, [], [4, 5]);\n      }\n      needsComma = true;\n    }\n    onArrayEnd();\n    if (_scanner.getToken() !== 4) {\n      handleError(8, [4], []);\n    } else {\n      scanNext();\n    }\n    return true;\n  }\n  function parseValue() {\n    switch (_scanner.getToken()) {\n      case 3:\n        return parseArray();\n      case 1:\n        return parseObject();\n      case 10:\n        return parseString(true);\n      default:\n        return parseLiteral();\n    }\n  }\n  scanNext();\n  if (_scanner.getToken() === 17) {\n    if (options.allowEmptyContent) {\n      return true;\n    }\n    handleError(4, [], []);\n    return false;\n  }\n  if (!parseValue()) {\n    handleError(4, [], []);\n    return false;\n  }\n  if (_scanner.getToken() !== 17) {\n    handleError(9, [], []);\n  }\n  return true;\n}\nvar createScanner2 = createScanner;\nvar parse2 = parse;\nvar findNodeAtOffset2 = findNodeAtOffset;\nvar getNodePath2 = getNodePath;\nvar getNodeValue2 = getNodeValue;\nfunction format2(documentText, range, options) {\n  return format(documentText, range, options);\n}\nfunction equals3(one, other) {\n  if (one === other) {\n    return true;\n  }\n  if (one === null || one === void 0 || other === null || other === void 0) {\n    return false;\n  }\n  if (typeof one !== typeof other) {\n    return false;\n  }\n  if (typeof one !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(one) !== Array.isArray(other)) {\n    return false;\n  }\n  var i, key;\n  if (Array.isArray(one)) {\n    if (one.length !== other.length) {\n      return false;\n    }\n    for (i = 0; i \u003c one.length; i++) {\n      if (!equals3(one[i], other[i])) {\n        return false;\n      }\n    }\n  } else {\n    var oneKeys = [];\n    for (key in one) {\n      oneKeys.push(key);\n    }\n    oneKeys.sort();\n    var otherKeys = [];\n    for (key in other) {\n      otherKeys.push(key);\n    }\n    otherKeys.sort();\n    if (!equals3(oneKeys, otherKeys)) {\n      return false;\n    }\n    for (i = 0; i \u003c oneKeys.length; i++) {\n      if (!equals3(one[oneKeys[i]], other[oneKeys[i]])) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction isNumber(val) {\n  return typeof val === \"number\";\n}\nfunction isDefined(val) {\n  return typeof val !== \"undefined\";\n}\nfunction isBoolean(val) {\n  return typeof val === \"boolean\";\n}\nfunction isString2(val) {\n  return typeof val === \"string\";\n}\nfunction startsWith(haystack, needle) {\n  if (haystack.length \u003c needle.length) {\n    return false;\n  }\n  for (var i = 0; i \u003c needle.length; i++) {\n    if (haystack[i] !== needle[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction endsWith(haystack, needle) {\n  var diff = haystack.length - needle.length;\n  if (diff \u003e 0) {\n    return haystack.lastIndexOf(needle) === diff;\n  } else if (diff === 0) {\n    return haystack === needle;\n  } else {\n    return false;\n  }\n}\nfunction extendedRegExp(pattern) {\n  var flags = \"\";\n  if (startsWith(pattern, \"(?i)\")) {\n    pattern = pattern.substring(4);\n    flags = \"i\";\n  }\n  try {\n    return new RegExp(pattern, flags + \"u\");\n  } catch (e) {\n    try {\n      return new RegExp(pattern, flags);\n    } catch (e2) {\n      return void 0;\n    }\n  }\n}\nvar integer;\n(function(integer2) {\n  integer2.MIN_VALUE = -2147483648;\n  integer2.MAX_VALUE = 2147483647;\n})(integer || (integer = {}));\nvar uinteger;\n(function(uinteger2) {\n  uinteger2.MIN_VALUE = 0;\n  uinteger2.MAX_VALUE = 2147483647;\n})(uinteger || (uinteger = {}));\nvar Position2;\n(function(Position22) {\n  function create(line, character) {\n    if (line === Number.MAX_VALUE) {\n      line = uinteger.MAX_VALUE;\n    }\n    if (character === Number.MAX_VALUE) {\n      character = uinteger.MAX_VALUE;\n    }\n    return { line, character };\n  }\n  Position22.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.objectLiteral(candidate) \u0026\u0026 Is.uinteger(candidate.line) \u0026\u0026 Is.uinteger(candidate.character);\n  }\n  Position22.is = is;\n})(Position2 || (Position2 = {}));\nvar Range2;\n(function(Range22) {\n  function create(one, two, three, four) {\n    if (Is.uinteger(one) \u0026\u0026 Is.uinteger(two) \u0026\u0026 Is.uinteger(three) \u0026\u0026 Is.uinteger(four)) {\n      return { start: Position2.create(one, two), end: Position2.create(three, four) };\n    } else if (Position2.is(one) \u0026\u0026 Position2.is(two)) {\n      return { start: one, end: two };\n    } else {\n      throw new Error(\"Range#create called with invalid arguments[\" + one + \", \" + two + \", \" + three + \", \" + four + \"]\");\n    }\n  }\n  Range22.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.objectLiteral(candidate) \u0026\u0026 Position2.is(candidate.start) \u0026\u0026 Position2.is(candidate.end);\n  }\n  Range22.is = is;\n})(Range2 || (Range2 = {}));\nvar Location;\n(function(Location2) {\n  function create(uri, range) {\n    return { uri, range };\n  }\n  Location2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Range2.is(candidate.range) \u0026\u0026 (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n  }\n  Location2.is = is;\n})(Location || (Location = {}));\nvar LocationLink;\n(function(LocationLink2) {\n  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n    return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\n  }\n  LocationLink2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Range2.is(candidate.targetRange) \u0026\u0026 Is.string(candidate.targetUri) \u0026\u0026 (Range2.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) \u0026\u0026 (Range2.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n  }\n  LocationLink2.is = is;\n})(LocationLink || (LocationLink = {}));\nvar Color2;\n(function(Color22) {\n  function create(red, green, blue, alpha) {\n    return {\n      red,\n      green,\n      blue,\n      alpha\n    };\n  }\n  Color22.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.numberRange(candidate.red, 0, 1) \u0026\u0026 Is.numberRange(candidate.green, 0, 1) \u0026\u0026 Is.numberRange(candidate.blue, 0, 1) \u0026\u0026 Is.numberRange(candidate.alpha, 0, 1);\n  }\n  Color22.is = is;\n})(Color2 || (Color2 = {}));\nvar ColorInformation;\n(function(ColorInformation2) {\n  function create(range, color) {\n    return {\n      range,\n      color\n    };\n  }\n  ColorInformation2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Range2.is(candidate.range) \u0026\u0026 Color2.is(candidate.color);\n  }\n  ColorInformation2.is = is;\n})(ColorInformation || (ColorInformation = {}));\nvar ColorPresentation;\n(function(ColorPresentation2) {\n  function create(label, textEdit, additionalTextEdits) {\n    return {\n      label,\n      textEdit,\n      additionalTextEdits\n    };\n  }\n  ColorPresentation2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.string(candidate.label) \u0026\u0026 (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) \u0026\u0026 (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n  }\n  ColorPresentation2.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\nvar FoldingRangeKind2;\n(function(FoldingRangeKind22) {\n  FoldingRangeKind22[\"Comment\"] = \"comment\";\n  FoldingRangeKind22[\"Imports\"] = \"imports\";\n  FoldingRangeKind22[\"Region\"] = \"region\";\n})(FoldingRangeKind2 || (FoldingRangeKind2 = {}));\nvar FoldingRange;\n(function(FoldingRange2) {\n  function create(startLine, endLine, startCharacter, endCharacter, kind) {\n    var result = {\n      startLine,\n      endLine\n    };\n    if (Is.defined(startCharacter)) {\n      result.startCharacter = startCharacter;\n    }\n    if (Is.defined(endCharacter)) {\n      result.endCharacter = endCharacter;\n    }\n    if (Is.defined(kind)) {\n      result.kind = kind;\n    }\n    return result;\n  }\n  FoldingRange2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.uinteger(candidate.startLine) \u0026\u0026 Is.uinteger(candidate.startLine) \u0026\u0026 (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) \u0026\u0026 (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) \u0026\u0026 (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n  }\n  FoldingRange2.is = is;\n})(FoldingRange || (FoldingRange = {}));\nvar DiagnosticRelatedInformation;\n(function(DiagnosticRelatedInformation2) {\n  function create(location, message) {\n    return {\n      location,\n      message\n    };\n  }\n  DiagnosticRelatedInformation2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Location.is(candidate.location) \u0026\u0026 Is.string(candidate.message);\n  }\n  DiagnosticRelatedInformation2.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\nvar DiagnosticSeverity;\n(function(DiagnosticSeverity2) {\n  DiagnosticSeverity2.Error = 1;\n  DiagnosticSeverity2.Warning = 2;\n  DiagnosticSeverity2.Information = 3;\n  DiagnosticSeverity2.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\nvar DiagnosticTag;\n(function(DiagnosticTag2) {\n  DiagnosticTag2.Unnecessary = 1;\n  DiagnosticTag2.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\nvar CodeDescription;\n(function(CodeDescription2) {\n  function is(value) {\n    var candidate = value;\n    return candidate !== void 0 \u0026\u0026 candidate !== null \u0026\u0026 Is.string(candidate.href);\n  }\n  CodeDescription2.is = is;\n})(CodeDescription || (CodeDescription = {}));\nvar Diagnostic;\n(function(Diagnostic2) {\n  function create(range, message, severity, code, source, relatedInformation) {\n    var result = { range, message };\n    if (Is.defined(severity)) {\n      result.severity = severity;\n    }\n    if (Is.defined(code)) {\n      result.code = code;\n    }\n    if (Is.defined(source)) {\n      result.source = source;\n    }\n    if (Is.defined(relatedInformation)) {\n      result.relatedInformation = relatedInformation;\n    }\n    return result;\n  }\n  Diagnostic2.create = create;\n  function is(value) {\n    var _a4;\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Range2.is(candidate.range) \u0026\u0026 Is.string(candidate.message) \u0026\u0026 (Is.number(candidate.severity) || Is.undefined(candidate.severity)) \u0026\u0026 (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) \u0026\u0026 (Is.undefined(candidate.codeDescription) || Is.string((_a4 = candidate.codeDescription) === null || _a4 === void 0 ? void 0 : _a4.href)) \u0026\u0026 (Is.string(candidate.source) || Is.undefined(candidate.source)) \u0026\u0026 (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n  }\n  Diagnostic2.is = is;\n})(Diagnostic || (Diagnostic = {}));\nvar Command2;\n(function(Command22) {\n  function create(title, command) {\n    var args = [];\n    for (var _i = 2; _i \u003c arguments.length; _i++) {\n      args[_i - 2] = arguments[_i];\n    }\n    var result = { title, command };\n    if (Is.defined(args) \u0026\u0026 args.length \u003e 0) {\n      result.arguments = args;\n    }\n    return result;\n  }\n  Command22.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Is.string(candidate.title) \u0026\u0026 Is.string(candidate.command);\n  }\n  Command22.is = is;\n})(Command2 || (Command2 = {}));\nvar TextEdit;\n(function(TextEdit2) {\n  function replace(range, newText) {\n    return { range, newText };\n  }\n  TextEdit2.replace = replace;\n  function insert(position, newText) {\n    return { range: { start: position, end: position }, newText };\n  }\n  TextEdit2.insert = insert;\n  function del(range) {\n    return { range, newText: \"\" };\n  }\n  TextEdit2.del = del;\n  function is(value) {\n    var candidate = value;\n    return Is.objectLiteral(candidate) \u0026\u0026 Is.string(candidate.newText) \u0026\u0026 Range2.is(candidate.range);\n  }\n  TextEdit2.is = is;\n})(TextEdit || (TextEdit = {}));\nvar ChangeAnnotation;\n(function(ChangeAnnotation2) {\n  function create(label, needsConfirmation, description2) {\n    var result = { label };\n    if (needsConfirmation !== void 0) {\n      result.needsConfirmation = needsConfirmation;\n    }\n    if (description2 !== void 0) {\n      result.description = description2;\n    }\n    return result;\n  }\n  ChangeAnnotation2.create = create;\n  function is(value) {\n    var candidate = value;\n    return candidate !== void 0 \u0026\u0026 Is.objectLiteral(candidate) \u0026\u0026 Is.string(candidate.label) \u0026\u0026 (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) \u0026\u0026 (Is.string(candidate.description) || candidate.description === void 0);\n  }\n  ChangeAnnotation2.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nvar ChangeAnnotationIdentifier;\n(function(ChangeAnnotationIdentifier2) {\n  function is(value) {\n    var candidate = value;\n    return typeof candidate === \"string\";\n  }\n  ChangeAnnotationIdentifier2.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nvar AnnotatedTextEdit;\n(function(AnnotatedTextEdit2) {\n  function replace(range, newText, annotation) {\n    return { range, newText, annotationId: annotation };\n  }\n  AnnotatedTextEdit2.replace = replace;\n  function insert(position, newText, annotation) {\n    return { range: { start: position, end: position }, newText, annotationId: annotation };\n  }\n  AnnotatedTextEdit2.insert = insert;\n  function del(range, annotation) {\n    return { range, newText: \"\", annotationId: annotation };\n  }\n  AnnotatedTextEdit2.del = del;\n  function is(value) {\n    var candidate = value;\n    return TextEdit.is(candidate) \u0026\u0026 (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  AnnotatedTextEdit2.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\nvar TextDocumentEdit;\n(function(TextDocumentEdit2) {\n  function create(textDocument, edits) {\n    return { textDocument, edits };\n  }\n  TextDocumentEdit2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) \u0026\u0026 Array.isArray(candidate.edits);\n  }\n  TextDocumentEdit2.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nvar CreateFile;\n(function(CreateFile2) {\n  function create(uri, options, annotation) {\n    var result = {\n      kind: \"create\",\n      uri\n    };\n    if (options !== void 0 \u0026\u0026 (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n      result.options = options;\n    }\n    if (annotation !== void 0) {\n      result.annotationId = annotation;\n    }\n    return result;\n  }\n  CreateFile2.create = create;\n  function is(value) {\n    var candidate = value;\n    return candidate \u0026\u0026 candidate.kind === \"create\" \u0026\u0026 Is.string(candidate.uri) \u0026\u0026 (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) \u0026\u0026 (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) \u0026\u0026 (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  CreateFile2.is = is;\n})(CreateFile || (CreateFile = {}));\nvar RenameFile;\n(function(RenameFile2) {\n  function create(oldUri, newUri, options, annotation) {\n    var result = {\n      kind: \"rename\",\n      oldUri,\n      newUri\n    };\n    if (options !== void 0 \u0026\u0026 (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n      result.options = options;\n    }\n    if (annotation !== void 0) {\n      result.annotationId = annotation;\n    }\n    return result;\n  }\n  RenameFile2.create = create;\n  function is(value) {\n    var candidate = value;\n    return candidate \u0026\u0026 candidate.kind === \"rename\" \u0026\u0026 Is.string(candidate.oldUri) \u0026\u0026 Is.string(candidate.newUri) \u0026\u0026 (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) \u0026\u0026 (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) \u0026\u0026 (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  RenameFile2.is = is;\n})(RenameFile || (RenameFile = {}));\nvar DeleteFile;\n(function(DeleteFile2) {\n  function create(uri, options, annotation) {\n    var result = {\n      kind: \"delete\",\n      uri\n    };\n    if (options !== void 0 \u0026\u0026 (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\n      result.options = options;\n    }\n    if (annotation !== void 0) {\n      result.annotationId = annotation;\n    }\n    return result;\n  }\n  DeleteFile2.create = create;\n  function is(value) {\n    var candidate = value;\n    return candidate \u0026\u0026 candidate.kind === \"delete\" \u0026\u0026 Is.string(candidate.uri) \u0026\u0026 (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) \u0026\u0026 (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) \u0026\u0026 (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  DeleteFile2.is = is;\n})(DeleteFile || (DeleteFile = {}));\nvar WorkspaceEdit;\n(function(WorkspaceEdit2) {\n  function is(value) {\n    var candidate = value;\n    return candidate \u0026\u0026 (candidate.changes !== void 0 || candidate.documentChanges !== void 0) \u0026\u0026 (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {\n      if (Is.string(change.kind)) {\n        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n      } else {\n        return TextDocumentEdit.is(change);\n      }\n    }));\n  }\n  WorkspaceEdit2.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nvar TextEditChangeImpl = function() {\n  function TextEditChangeImpl2(edits, changeAnnotations) {\n    this.edits = edits;\n    this.changeAnnotations = changeAnnotations;\n  }\n  TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {\n    var edit;\n    var id;\n    if (annotation === void 0) {\n      edit = TextEdit.insert(position, newText);\n    } else if (ChangeAnnotationIdentifier.is(annotation)) {\n      id = annotation;\n      edit = AnnotatedTextEdit.insert(position, newText, annotation);\n    } else {\n      this.assertChangeAnnotations(this.changeAnnotations);\n      id = this.changeAnnotations.manage(annotation);\n      edit = AnnotatedTextEdit.insert(position, newText, id);\n    }\n    this.edits.push(edit);\n    if (id !== void 0) {\n      return id;\n    }\n  };\n  TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {\n    var edit;\n    var id;\n    if (annotation === void 0) {\n      edit = TextEdit.replace(range, newText);\n    } else if (ChangeAnnotationIdentifier.is(annotation)) {\n      id = annotation;\n      edit = AnnotatedTextEdit.replace(range, newText, annotation);\n    } else {\n      this.assertChangeAnnotations(this.changeAnnotations);\n      id = this.changeAnnotations.manage(annotation);\n      edit = AnnotatedTextEdit.replace(range, newText, id);\n    }\n    this.edits.push(edit);\n    if (id !== void 0) {\n      return id;\n    }\n  };\n  TextEditChangeImpl2.prototype.delete = function(range, annotation) {\n    var edit;\n    var id;\n    if (annotation === void 0) {\n      edit = TextEdit.del(range);\n    } else if (ChangeAnnotationIdentifier.is(annotation)) {\n      id = annotation;\n      edit = AnnotatedTextEdit.del(range, annotation);\n    } else {\n      this.assertChangeAnnotations(this.changeAnnotations);\n      id = this.changeAnnotations.manage(annotation);\n      edit = AnnotatedTextEdit.del(range, id);\n    }\n    this.edits.push(edit);\n    if (id !== void 0) {\n      return id;\n    }\n  };\n  TextEditChangeImpl2.prototype.add = function(edit) {\n    this.edits.push(edit);\n  };\n  TextEditChangeImpl2.prototype.all = function() {\n    return this.edits;\n  };\n  TextEditChangeImpl2.prototype.clear = function() {\n    this.edits.splice(0, this.edits.length);\n  };\n  TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {\n    if (value === void 0) {\n      throw new Error(\"Text edit change is not configured to manage change annotations.\");\n    }\n  };\n  return TextEditChangeImpl2;\n}();\nvar ChangeAnnotations = function() {\n  function ChangeAnnotations2(annotations) {\n    this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;\n    this._counter = 0;\n    this._size = 0;\n  }\n  ChangeAnnotations2.prototype.all = function() {\n    return this._annotations;\n  };\n  Object.defineProperty(ChangeAnnotations2.prototype, \"size\", {\n    get: function() {\n      return this._size;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {\n    var id;\n    if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n      id = idOrAnnotation;\n    } else {\n      id = this.nextId();\n      annotation = idOrAnnotation;\n    }\n    if (this._annotations[id] !== void 0) {\n      throw new Error(\"Id \" + id + \" is already in use.\");\n    }\n    if (annotation === void 0) {\n      throw new Error(\"No annotation provided for id \" + id);\n    }\n    this._annotations[id] = annotation;\n    this._size++;\n    return id;\n  };\n  ChangeAnnotations2.prototype.nextId = function() {\n    this._counter++;\n    return this._counter.toString();\n  };\n  return ChangeAnnotations2;\n}();\nvar WorkspaceChange = function() {\n  function WorkspaceChange2(workspaceEdit) {\n    var _this = this;\n    this._textEditChanges = /* @__PURE__ */ Object.create(null);\n    if (workspaceEdit !== void 0) {\n      this._workspaceEdit = workspaceEdit;\n      if (workspaceEdit.documentChanges) {\n        this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n        workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        workspaceEdit.documentChanges.forEach(function(change) {\n          if (TextDocumentEdit.is(change)) {\n            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n            _this._textEditChanges[change.textDocument.uri] = textEditChange;\n          }\n        });\n      } else if (workspaceEdit.changes) {\n        Object.keys(workspaceEdit.changes).forEach(function(key) {\n          var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n          _this._textEditChanges[key] = textEditChange;\n        });\n      }\n    } else {\n      this._workspaceEdit = {};\n    }\n  }\n  Object.defineProperty(WorkspaceChange2.prototype, \"edit\", {\n    get: function() {\n      this.initDocumentChanges();\n      if (this._changeAnnotations !== void 0) {\n        if (this._changeAnnotations.size === 0) {\n          this._workspaceEdit.changeAnnotations = void 0;\n        } else {\n          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n      }\n      return this._workspaceEdit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  WorkspaceChange2.prototype.getTextEditChange = function(key) {\n    if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n      this.initDocumentChanges();\n      if (this._workspaceEdit.documentChanges === void 0) {\n        throw new Error(\"Workspace edit is not configured for document changes.\");\n      }\n      var textDocument = { uri: key.uri, version: key.version };\n      var result = this._textEditChanges[textDocument.uri];\n      if (!result) {\n        var edits = [];\n        var textDocumentEdit = {\n          textDocument,\n          edits\n        };\n        this._workspaceEdit.documentChanges.push(textDocumentEdit);\n        result = new TextEditChangeImpl(edits, this._changeAnnotations);\n        this._textEditChanges[textDocument.uri] = result;\n      }\n      return result;\n    } else {\n      this.initChanges();\n      if (this._workspaceEdit.changes === void 0) {\n        throw new Error(\"Workspace edit is not configured for normal text edit changes.\");\n      }\n      var result = this._textEditChanges[key];\n      if (!result) {\n        var edits = [];\n        this._workspaceEdit.changes[key] = edits;\n        result = new TextEditChangeImpl(edits);\n        this._textEditChanges[key] = result;\n      }\n      return result;\n    }\n  };\n  WorkspaceChange2.prototype.initDocumentChanges = function() {\n    if (this._workspaceEdit.documentChanges === void 0 \u0026\u0026 this._workspaceEdit.changes === void 0) {\n      this._changeAnnotations = new ChangeAnnotations();\n      this._workspaceEdit.documentChanges = [];\n      this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n    }\n  };\n  WorkspaceChange2.prototype.initChanges = function() {\n    if (this._workspaceEdit.documentChanges === void 0 \u0026\u0026 this._workspaceEdit.changes === void 0) {\n      this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);\n    }\n  };\n  WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {\n    this.initDocumentChanges();\n    if (this._workspaceEdit.documentChanges === void 0) {\n      throw new Error(\"Workspace edit is not configured for document changes.\");\n    }\n    var annotation;\n    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n      annotation = optionsOrAnnotation;\n    } else {\n      options = optionsOrAnnotation;\n    }\n    var operation;\n    var id;\n    if (annotation === void 0) {\n      operation = CreateFile.create(uri, options);\n    } else {\n      id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n      operation = CreateFile.create(uri, options, id);\n    }\n    this._workspaceEdit.documentChanges.push(operation);\n    if (id !== void 0) {\n      return id;\n    }\n  };\n  WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {\n    this.initDocumentChanges();\n    if (this._workspaceEdit.documentChanges === void 0) {\n      throw new Error(\"Workspace edit is not configured for document changes.\");\n    }\n    var annotation;\n    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n      annotation = optionsOrAnnotation;\n    } else {\n      options = optionsOrAnnotation;\n    }\n    var operation;\n    var id;\n    if (annotation === void 0) {\n      operation = RenameFile.create(oldUri, newUri, options);\n    } else {\n      id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n      operation = RenameFile.create(oldUri, newUri, options, id);\n    }\n    this._workspaceEdit.documentChanges.push(operation);\n    if (id !== void 0) {\n      return id;\n    }\n  };\n  WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {\n    this.initDocumentChanges();\n    if (this._workspaceEdit.documentChanges === void 0) {\n      throw new Error(\"Workspace edit is not configured for document changes.\");\n    }\n    var annotation;\n    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n      annotation = optionsOrAnnotation;\n    } else {\n      options = optionsOrAnnotation;\n    }\n    var operation;\n    var id;\n    if (annotation === void 0) {\n      operation = DeleteFile.create(uri, options);\n    } else {\n      id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n      operation = DeleteFile.create(uri, options, id);\n    }\n    this._workspaceEdit.documentChanges.push(operation);\n    if (id !== void 0) {\n      return id;\n    }\n  };\n  return WorkspaceChange2;\n}();\nvar TextDocumentIdentifier;\n(function(TextDocumentIdentifier2) {\n  function create(uri) {\n    return { uri };\n  }\n  TextDocumentIdentifier2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Is.string(candidate.uri);\n  }\n  TextDocumentIdentifier2.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\nvar VersionedTextDocumentIdentifier;\n(function(VersionedTextDocumentIdentifier2) {\n  function create(uri, version) {\n    return { uri, version };\n  }\n  VersionedTextDocumentIdentifier2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Is.string(candidate.uri) \u0026\u0026 Is.integer(candidate.version);\n  }\n  VersionedTextDocumentIdentifier2.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\nvar OptionalVersionedTextDocumentIdentifier;\n(function(OptionalVersionedTextDocumentIdentifier2) {\n  function create(uri, version) {\n    return { uri, version };\n  }\n  OptionalVersionedTextDocumentIdentifier2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Is.string(candidate.uri) \u0026\u0026 (candidate.version === null || Is.integer(candidate.version));\n  }\n  OptionalVersionedTextDocumentIdentifier2.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\nvar TextDocumentItem;\n(function(TextDocumentItem2) {\n  function create(uri, languageId, version, text) {\n    return { uri, languageId, version, text };\n  }\n  TextDocumentItem2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Is.string(candidate.uri) \u0026\u0026 Is.string(candidate.languageId) \u0026\u0026 Is.integer(candidate.version) \u0026\u0026 Is.string(candidate.text);\n  }\n  TextDocumentItem2.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\nvar MarkupKind;\n(function(MarkupKind2) {\n  MarkupKind2.PlainText = \"plaintext\";\n  MarkupKind2.Markdown = \"markdown\";\n})(MarkupKind || (MarkupKind = {}));\n(function(MarkupKind2) {\n  function is(value) {\n    var candidate = value;\n    return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;\n  }\n  MarkupKind2.is = is;\n})(MarkupKind || (MarkupKind = {}));\nvar MarkupContent;\n(function(MarkupContent2) {\n  function is(value) {\n    var candidate = value;\n    return Is.objectLiteral(value) \u0026\u0026 MarkupKind.is(candidate.kind) \u0026\u0026 Is.string(candidate.value);\n  }\n  MarkupContent2.is = is;\n})(MarkupContent || (MarkupContent = {}));\nvar CompletionItemKind2;\n(function(CompletionItemKind22) {\n  CompletionItemKind22.Text = 1;\n  CompletionItemKind22.Method = 2;\n  CompletionItemKind22.Function = 3;\n  CompletionItemKind22.Constructor = 4;\n  CompletionItemKind22.Field = 5;\n  CompletionItemKind22.Variable = 6;\n  CompletionItemKind22.Class = 7;\n  CompletionItemKind22.Interface = 8;\n  CompletionItemKind22.Module = 9;\n  CompletionItemKind22.Property = 10;\n  CompletionItemKind22.Unit = 11;\n  CompletionItemKind22.Value = 12;\n  CompletionItemKind22.Enum = 13;\n  CompletionItemKind22.Keyword = 14;\n  CompletionItemKind22.Snippet = 15;\n  CompletionItemKind22.Color = 16;\n  CompletionItemKind22.File = 17;\n  CompletionItemKind22.Reference = 18;\n  CompletionItemKind22.Folder = 19;\n  CompletionItemKind22.EnumMember = 20;\n  CompletionItemKind22.Constant = 21;\n  CompletionItemKind22.Struct = 22;\n  CompletionItemKind22.Event = 23;\n  CompletionItemKind22.Operator = 24;\n  CompletionItemKind22.TypeParameter = 25;\n})(CompletionItemKind2 || (CompletionItemKind2 = {}));\nvar InsertTextFormat;\n(function(InsertTextFormat2) {\n  InsertTextFormat2.PlainText = 1;\n  InsertTextFormat2.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\nvar CompletionItemTag2;\n(function(CompletionItemTag22) {\n  CompletionItemTag22.Deprecated = 1;\n})(CompletionItemTag2 || (CompletionItemTag2 = {}));\nvar InsertReplaceEdit;\n(function(InsertReplaceEdit2) {\n  function create(newText, insert, replace) {\n    return { newText, insert, replace };\n  }\n  InsertReplaceEdit2.create = create;\n  function is(value) {\n    var candidate = value;\n    return candidate \u0026\u0026 Is.string(candidate.newText) \u0026\u0026 Range2.is(candidate.insert) \u0026\u0026 Range2.is(candidate.replace);\n  }\n  InsertReplaceEdit2.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\nvar InsertTextMode;\n(function(InsertTextMode2) {\n  InsertTextMode2.asIs = 1;\n  InsertTextMode2.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nvar CompletionItem;\n(function(CompletionItem2) {\n  function create(label) {\n    return { label };\n  }\n  CompletionItem2.create = create;\n})(CompletionItem || (CompletionItem = {}));\nvar CompletionList;\n(function(CompletionList2) {\n  function create(items, isIncomplete) {\n    return { items: items ? items : [], isIncomplete: !!isIncomplete };\n  }\n  CompletionList2.create = create;\n})(CompletionList || (CompletionList = {}));\nvar MarkedString;\n(function(MarkedString2) {\n  function fromPlainText(plainText) {\n    return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$\u0026\");\n  }\n  MarkedString2.fromPlainText = fromPlainText;\n  function is(value) {\n    var candidate = value;\n    return Is.string(candidate) || Is.objectLiteral(candidate) \u0026\u0026 Is.string(candidate.language) \u0026\u0026 Is.string(candidate.value);\n  }\n  MarkedString2.is = is;\n})(MarkedString || (MarkedString = {}));\nvar Hover;\n(function(Hover2) {\n  function is(value) {\n    var candidate = value;\n    return !!candidate \u0026\u0026 Is.objectLiteral(candidate) \u0026\u0026 (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) \u0026\u0026 (value.range === void 0 || Range2.is(value.range));\n  }\n  Hover2.is = is;\n})(Hover || (Hover = {}));\nvar ParameterInformation;\n(function(ParameterInformation2) {\n  function create(label, documentation) {\n    return documentation ? { label, documentation } : { label };\n  }\n  ParameterInformation2.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\nvar SignatureInformation;\n(function(SignatureInformation2) {\n  function create(label, documentation) {\n    var parameters = [];\n    for (var _i = 2; _i \u003c arguments.length; _i++) {\n      parameters[_i - 2] = arguments[_i];\n    }\n    var result = { label };\n    if (Is.defined(documentation)) {\n      result.documentation = documentation;\n    }\n    if (Is.defined(parameters)) {\n      result.parameters = parameters;\n    } else {\n      result.parameters = [];\n    }\n    return result;\n  }\n  SignatureInformation2.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\nvar DocumentHighlightKind3;\n(function(DocumentHighlightKind22) {\n  DocumentHighlightKind22.Text = 1;\n  DocumentHighlightKind22.Read = 2;\n  DocumentHighlightKind22.Write = 3;\n})(DocumentHighlightKind3 || (DocumentHighlightKind3 = {}));\nvar DocumentHighlight;\n(function(DocumentHighlight2) {\n  function create(range, kind) {\n    var result = { range };\n    if (Is.number(kind)) {\n      result.kind = kind;\n    }\n    return result;\n  }\n  DocumentHighlight2.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\nvar SymbolKind2;\n(function(SymbolKind22) {\n  SymbolKind22.File = 1;\n  SymbolKind22.Module = 2;\n  SymbolKind22.Namespace = 3;\n  SymbolKind22.Package = 4;\n  SymbolKind22.Class = 5;\n  SymbolKind22.Method = 6;\n  SymbolKind22.Property = 7;\n  SymbolKind22.Field = 8;\n  SymbolKind22.Constructor = 9;\n  SymbolKind22.Enum = 10;\n  SymbolKind22.Interface = 11;\n  SymbolKind22.Function = 12;\n  SymbolKind22.Variable = 13;\n  SymbolKind22.Constant = 14;\n  SymbolKind22.String = 15;\n  SymbolKind22.Number = 16;\n  SymbolKind22.Boolean = 17;\n  SymbolKind22.Array = 18;\n  SymbolKind22.Object = 19;\n  SymbolKind22.Key = 20;\n  SymbolKind22.Null = 21;\n  SymbolKind22.EnumMember = 22;\n  SymbolKind22.Struct = 23;\n  SymbolKind22.Event = 24;\n  SymbolKind22.Operator = 25;\n  SymbolKind22.TypeParameter = 26;\n})(SymbolKind2 || (SymbolKind2 = {}));\nvar SymbolTag2;\n(function(SymbolTag22) {\n  SymbolTag22.Deprecated = 1;\n})(SymbolTag2 || (SymbolTag2 = {}));\nvar SymbolInformation;\n(function(SymbolInformation2) {\n  function create(name, kind, range, uri, containerName) {\n    var result = {\n      name,\n      kind,\n      location: { uri, range }\n    };\n    if (containerName) {\n      result.containerName = containerName;\n    }\n    return result;\n  }\n  SymbolInformation2.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nvar DocumentSymbol;\n(function(DocumentSymbol2) {\n  function create(name, detail, kind, range, selectionRange, children) {\n    var result = {\n      name,\n      detail,\n      kind,\n      range,\n      selectionRange\n    };\n    if (children !== void 0) {\n      result.children = children;\n    }\n    return result;\n  }\n  DocumentSymbol2.create = create;\n  function is(value) {\n    var candidate = value;\n    return candidate \u0026\u0026 Is.string(candidate.name) \u0026\u0026 Is.number(candidate.kind) \u0026\u0026 Range2.is(candidate.range) \u0026\u0026 Range2.is(candidate.selectionRange) \u0026\u0026 (candidate.detail === void 0 || Is.string(candidate.detail)) \u0026\u0026 (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) \u0026\u0026 (candidate.children === void 0 || Array.isArray(candidate.children)) \u0026\u0026 (candidate.tags === void 0 || Array.isArray(candidate.tags));\n  }\n  DocumentSymbol2.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\nvar CodeActionKind;\n(function(CodeActionKind2) {\n  CodeActionKind2.Empty = \"\";\n  CodeActionKind2.QuickFix = \"quickfix\";\n  CodeActionKind2.Refactor = \"refactor\";\n  CodeActionKind2.RefactorExtract = \"refactor.extract\";\n  CodeActionKind2.RefactorInline = \"refactor.inline\";\n  CodeActionKind2.RefactorRewrite = \"refactor.rewrite\";\n  CodeActionKind2.Source = \"source\";\n  CodeActionKind2.SourceOrganizeImports = \"source.organizeImports\";\n  CodeActionKind2.SourceFixAll = \"source.fixAll\";\n})(CodeActionKind || (CodeActionKind = {}));\nvar CodeActionContext;\n(function(CodeActionContext2) {\n  function create(diagnostics, only) {\n    var result = { diagnostics };\n    if (only !== void 0 \u0026\u0026 only !== null) {\n      result.only = only;\n    }\n    return result;\n  }\n  CodeActionContext2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Is.typedArray(candidate.diagnostics, Diagnostic.is) \u0026\u0026 (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));\n  }\n  CodeActionContext2.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nvar CodeAction;\n(function(CodeAction2) {\n  function create(title, kindOrCommandOrEdit, kind) {\n    var result = { title };\n    var checkKind = true;\n    if (typeof kindOrCommandOrEdit === \"string\") {\n      checkKind = false;\n      result.kind = kindOrCommandOrEdit;\n    } else if (Command2.is(kindOrCommandOrEdit)) {\n      result.command = kindOrCommandOrEdit;\n    } else {\n      result.edit = kindOrCommandOrEdit;\n    }\n    if (checkKind \u0026\u0026 kind !== void 0) {\n      result.kind = kind;\n    }\n    return result;\n  }\n  CodeAction2.create = create;\n  function is(value) {\n    var candidate = value;\n    return candidate \u0026\u0026 Is.string(candidate.title) \u0026\u0026 (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) \u0026\u0026 (candidate.kind === void 0 || Is.string(candidate.kind)) \u0026\u0026 (candidate.edit !== void 0 || candidate.command !== void 0) \u0026\u0026 (candidate.command === void 0 || Command2.is(candidate.command)) \u0026\u0026 (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) \u0026\u0026 (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\n  }\n  CodeAction2.is = is;\n})(CodeAction || (CodeAction = {}));\nvar CodeLens;\n(function(CodeLens2) {\n  function create(range, data) {\n    var result = { range };\n    if (Is.defined(data)) {\n      result.data = data;\n    }\n    return result;\n  }\n  CodeLens2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Range2.is(candidate.range) \u0026\u0026 (Is.undefined(candidate.command) || Command2.is(candidate.command));\n  }\n  CodeLens2.is = is;\n})(CodeLens || (CodeLens = {}));\nvar FormattingOptions;\n(function(FormattingOptions2) {\n  function create(tabSize, insertSpaces) {\n    return { tabSize, insertSpaces };\n  }\n  FormattingOptions2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Is.uinteger(candidate.tabSize) \u0026\u0026 Is.boolean(candidate.insertSpaces);\n  }\n  FormattingOptions2.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\nvar DocumentLink;\n(function(DocumentLink2) {\n  function create(range, target, data) {\n    return { range, target, data };\n  }\n  DocumentLink2.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Range2.is(candidate.range) \u0026\u0026 (Is.undefined(candidate.target) || Is.string(candidate.target));\n  }\n  DocumentLink2.is = is;\n})(DocumentLink || (DocumentLink = {}));\nvar SelectionRange;\n(function(SelectionRange2) {\n  function create(range, parent) {\n    return { range, parent };\n  }\n  SelectionRange2.create = create;\n  function is(value) {\n    var candidate = value;\n    return candidate !== void 0 \u0026\u0026 Range2.is(candidate.range) \u0026\u0026 (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));\n  }\n  SelectionRange2.is = is;\n})(SelectionRange || (SelectionRange = {}));\nvar TextDocument;\n(function(TextDocument3) {\n  function create(uri, languageId, version, content) {\n    return new FullTextDocument(uri, languageId, version, content);\n  }\n  TextDocument3.create = create;\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) \u0026\u0026 Is.string(candidate.uri) \u0026\u0026 (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) \u0026\u0026 Is.uinteger(candidate.lineCount) \u0026\u0026 Is.func(candidate.getText) \u0026\u0026 Is.func(candidate.positionAt) \u0026\u0026 Is.func(candidate.offsetAt) ? true : false;\n  }\n  TextDocument3.is = is;\n  function applyEdits(document2, edits) {\n    var text = document2.getText();\n    var sortedEdits = mergeSort2(edits, function(a2, b) {\n      var diff = a2.range.start.line - b.range.start.line;\n      if (diff === 0) {\n        return a2.range.start.character - b.range.start.character;\n      }\n      return diff;\n    });\n    var lastModifiedOffset = text.length;\n    for (var i = sortedEdits.length - 1; i \u003e= 0; i--) {\n      var e = sortedEdits[i];\n      var startOffset = document2.offsetAt(e.range.start);\n      var endOffset = document2.offsetAt(e.range.end);\n      if (endOffset \u003c= lastModifiedOffset) {\n        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n      } else {\n        throw new Error(\"Overlapping edit\");\n      }\n      lastModifiedOffset = startOffset;\n    }\n    return text;\n  }\n  TextDocument3.applyEdits = applyEdits;\n  function mergeSort2(data, compare) {\n    if (data.length \u003c= 1) {\n      return data;\n    }\n    var p = data.length / 2 | 0;\n    var left = data.slice(0, p);\n    var right = data.slice(p);\n    mergeSort2(left, compare);\n    mergeSort2(right, compare);\n    var leftIdx = 0;\n    var rightIdx = 0;\n    var i = 0;\n    while (leftIdx \u003c left.length \u0026\u0026 rightIdx \u003c right.length) {\n      var ret = compare(left[leftIdx], right[rightIdx]);\n      if (ret \u003c= 0) {\n        data[i++] = left[leftIdx++];\n      } else {\n        data[i++] = right[rightIdx++];\n      }\n    }\n    while (leftIdx \u003c left.length) {\n      data[i++] = left[leftIdx++];\n    }\n    while (rightIdx \u003c right.length) {\n      data[i++] = right[rightIdx++];\n    }\n    return data;\n  }\n})(TextDocument || (TextDocument = {}));\nvar FullTextDocument = function() {\n  function FullTextDocument3(uri, languageId, version, content) {\n    this._uri = uri;\n    this._languageId = languageId;\n    this._version = version;\n    this._content = content;\n    this._lineOffsets = void 0;\n  }\n  Object.defineProperty(FullTextDocument3.prototype, \"uri\", {\n    get: function() {\n      return this._uri;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FullTextDocument3.prototype, \"languageId\", {\n    get: function() {\n      return this._languageId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FullTextDocument3.prototype, \"version\", {\n    get: function() {\n      return this._version;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  FullTextDocument3.prototype.getText = function(range) {\n    if (range) {\n      var start = this.offsetAt(range.start);\n      var end = this.offsetAt(range.end);\n      return this._content.substring(start, end);\n    }\n    return this._content;\n  };\n  FullTextDocument3.prototype.update = function(event, version) {\n    this._content = event.text;\n    this._version = version;\n    this._lineOffsets = void 0;\n  };\n  FullTextDocument3.prototype.getLineOffsets = function() {\n    if (this._lineOffsets === void 0) {\n      var lineOffsets = [];\n      var text = this._content;\n      var isLineStart = true;\n      for (var i = 0; i \u003c text.length; i++) {\n        if (isLineStart) {\n          lineOffsets.push(i);\n          isLineStart = false;\n        }\n        var ch = text.charAt(i);\n        isLineStart = ch === \"\\r\" || ch === \"\\n\";\n        if (ch === \"\\r\" \u0026\u0026 i + 1 \u003c text.length \u0026\u0026 text.charAt(i + 1) === \"\\n\") {\n          i++;\n        }\n      }\n      if (isLineStart \u0026\u0026 text.length \u003e 0) {\n        lineOffsets.push(text.length);\n      }\n      this._lineOffsets = lineOffsets;\n    }\n    return this._lineOffsets;\n  };\n  FullTextDocument3.prototype.positionAt = function(offset) {\n    offset = Math.max(Math.min(offset, this._content.length), 0);\n    var lineOffsets = this.getLineOffsets();\n    var low = 0, high = lineOffsets.length;\n    if (high === 0) {\n      return Position2.create(0, offset);\n    }\n    while (low \u003c high) {\n      var mid = Math.floor((low + high) / 2);\n      if (lineOffsets[mid] \u003e offset) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    var line = low - 1;\n    return Position2.create(line, offset - lineOffsets[line]);\n  };\n  FullTextDocument3.prototype.offsetAt = function(position) {\n    var lineOffsets = this.getLineOffsets();\n    if (position.line \u003e= lineOffsets.length) {\n      return this._content.length;\n    } else if (position.line \u003c 0) {\n      return 0;\n    }\n    var lineOffset = lineOffsets[position.line];\n    var nextLineOffset = position.line + 1 \u003c lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n  };\n  Object.defineProperty(FullTextDocument3.prototype, \"lineCount\", {\n    get: function() {\n      return this.getLineOffsets().length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return FullTextDocument3;\n}();\nvar Is;\n(function(Is2) {\n  var toString = Object.prototype.toString;\n  function defined(value) {\n    return typeof value !== \"undefined\";\n  }\n  Is2.defined = defined;\n  function undefined2(value) {\n    return typeof value === \"undefined\";\n  }\n  Is2.undefined = undefined2;\n  function boolean(value) {\n    return value === true || value === false;\n  }\n  Is2.boolean = boolean;\n  function string(value) {\n    return toString.call(value) === \"[object String]\";\n  }\n  Is2.string = string;\n  function number(value) {\n    return toString.call(value) === \"[object Number]\";\n  }\n  Is2.number = number;\n  function numberRange(value, min, max) {\n    return toString.call(value) === \"[object Number]\" \u0026\u0026 min \u003c= value \u0026\u0026 value \u003c= max;\n  }\n  Is2.numberRange = numberRange;\n  function integer2(value) {\n    return toString.call(value) === \"[object Number]\" \u0026\u0026 -2147483648 \u003c= value \u0026\u0026 value \u003c= 2147483647;\n  }\n  Is2.integer = integer2;\n  function uinteger2(value) {\n    return toString.call(value) === \"[object Number]\" \u0026\u0026 0 \u003c= value \u0026\u0026 value \u003c= 2147483647;\n  }\n  Is2.uinteger = uinteger2;\n  function func(value) {\n    return toString.call(value) === \"[object Function]\";\n  }\n  Is2.func = func;\n  function objectLiteral(value) {\n    return value !== null \u0026\u0026 typeof value === \"object\";\n  }\n  Is2.objectLiteral = objectLiteral;\n  function typedArray(value, check) {\n    return Array.isArray(value) \u0026\u0026 value.every(check);\n  }\n  Is2.typedArray = typedArray;\n})(Is || (Is = {}));\nvar FullTextDocument2 = class {\n  constructor(uri, languageId, version, content) {\n    this._uri = uri;\n    this._languageId = languageId;\n    this._version = version;\n    this._content = content;\n    this._lineOffsets = void 0;\n  }\n  get uri() {\n    return this._uri;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get version() {\n    return this._version;\n  }\n  getText(range) {\n    if (range) {\n      const start = this.offsetAt(range.start);\n      const end = this.offsetAt(range.end);\n      return this._content.substring(start, end);\n    }\n    return this._content;\n  }\n  update(changes, version) {\n    for (let change of changes) {\n      if (FullTextDocument2.isIncremental(change)) {\n        const range = getWellformedRange(change.range);\n        const startOffset = this.offsetAt(range.start);\n        const endOffset = this.offsetAt(range.end);\n        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n        const startLine = Math.max(range.start.line, 0);\n        const endLine = Math.max(range.end.line, 0);\n        let lineOffsets = this._lineOffsets;\n        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n        if (endLine - startLine === addedLineOffsets.length) {\n          for (let i = 0, len = addedLineOffsets.length; i \u003c len; i++) {\n            lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n          }\n        } else {\n          if (addedLineOffsets.length \u003c 1e4) {\n            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n          } else {\n            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n          }\n        }\n        const diff = change.text.length - (endOffset - startOffset);\n        if (diff !== 0) {\n          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i \u003c len; i++) {\n            lineOffsets[i] = lineOffsets[i] + diff;\n          }\n        }\n      } else if (FullTextDocument2.isFull(change)) {\n        this._content = change.text;\n        this._lineOffsets = void 0;\n      } else {\n        throw new Error(\"Unknown change event received\");\n      }\n    }\n    this._version = version;\n  }\n  getLineOffsets() {\n    if (this._lineOffsets === void 0) {\n      this._lineOffsets = computeLineOffsets(this._content, true);\n    }\n    return this._lineOffsets;\n  }\n  positionAt(offset) {\n    offset = Math.max(Math.min(offset, this._content.length), 0);\n    let lineOffsets = this.getLineOffsets();\n    let low = 0, high = lineOffsets.length;\n    if (high === 0) {\n      return { line: 0, character: offset };\n    }\n    while (low \u003c high) {\n      let mid = Math.floor((low + high) / 2);\n      if (lineOffsets[mid] \u003e offset) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    let line = low - 1;\n    return { line, character: offset - lineOffsets[line] };\n  }\n  offsetAt(position) {\n    let lineOffsets = this.getLineOffsets();\n    if (position.line \u003e= lineOffsets.length) {\n      return this._content.length;\n    } else if (position.line \u003c 0) {\n      return 0;\n    }\n    let lineOffset = lineOffsets[position.line];\n    let nextLineOffset = position.line + 1 \u003c lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n  }\n  get lineCount() {\n    return this.getLineOffsets().length;\n  }\n  static isIncremental(event) {\n    let candidate = event;\n    return candidate !== void 0 \u0026\u0026 candidate !== null \u0026\u0026 typeof candidate.text === \"string\" \u0026\u0026 candidate.range !== void 0 \u0026\u0026 (candidate.rangeLength === void 0 || typeof candidate.rangeLength === \"number\");\n  }\n  static isFull(event) {\n    let candidate = event;\n    return candidate !== void 0 \u0026\u0026 candidate !== null \u0026\u0026 typeof candidate.text === \"string\" \u0026\u0026 candidate.range === void 0 \u0026\u0026 candidate.rangeLength === void 0;\n  }\n};\nvar TextDocument2;\n(function(TextDocument3) {\n  function create(uri, languageId, version, content) {\n    return new FullTextDocument2(uri, languageId, version, content);\n  }\n  TextDocument3.create = create;\n  function update(document2, changes, version) {\n    if (document2 instanceof FullTextDocument2) {\n      document2.update(changes, version);\n      return document2;\n    } else {\n      throw new Error(\"TextDocument.update: document must be created by TextDocument.create\");\n    }\n  }\n  TextDocument3.update = update;\n  function applyEdits(document2, edits) {\n    let text = document2.getText();\n    let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a2, b) =\u003e {\n      let diff = a2.range.start.line - b.range.start.line;\n      if (diff === 0) {\n        return a2.range.start.character - b.range.start.character;\n      }\n      return diff;\n    });\n    let lastModifiedOffset = 0;\n    const spans = [];\n    for (const e of sortedEdits) {\n      let startOffset = document2.offsetAt(e.range.start);\n      if (startOffset \u003c lastModifiedOffset) {\n        throw new Error(\"Overlapping edit\");\n      } else if (startOffset \u003e lastModifiedOffset) {\n        spans.push(text.substring(lastModifiedOffset, startOffset));\n      }\n      if (e.newText.length) {\n        spans.push(e.newText);\n      }\n      lastModifiedOffset = document2.offsetAt(e.range.end);\n    }\n    spans.push(text.substr(lastModifiedOffset));\n    return spans.join(\"\");\n  }\n  TextDocument3.applyEdits = applyEdits;\n})(TextDocument2 || (TextDocument2 = {}));\nfunction mergeSort(data, compare) {\n  if (data.length \u003c= 1) {\n    return data;\n  }\n  const p = data.length / 2 | 0;\n  const left = data.slice(0, p);\n  const right = data.slice(p);\n  mergeSort(left, compare);\n  mergeSort(right, compare);\n  let leftIdx = 0;\n  let rightIdx = 0;\n  let i = 0;\n  while (leftIdx \u003c left.length \u0026\u0026 rightIdx \u003c right.length) {\n    let ret = compare(left[leftIdx], right[rightIdx]);\n    if (ret \u003c= 0) {\n      data[i++] = left[leftIdx++];\n    } else {\n      data[i++] = right[rightIdx++];\n    }\n  }\n  while (leftIdx \u003c left.length) {\n    data[i++] = left[leftIdx++];\n  }\n  while (rightIdx \u003c right.length) {\n    data[i++] = right[rightIdx++];\n  }\n  return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n  const result = isAtLineStart ? [textOffset] : [];\n  for (let i = 0; i \u003c text.length; i++) {\n    let ch = text.charCodeAt(i);\n    if (ch === 13 || ch === 10) {\n      if (ch === 13 \u0026\u0026 i + 1 \u003c text.length \u0026\u0026 text.charCodeAt(i + 1) === 10) {\n        i++;\n      }\n      result.push(textOffset + i + 1);\n    }\n  }\n  return result;\n}\nfunction getWellformedRange(range) {\n  const start = range.start;\n  const end = range.end;\n  if (start.line \u003e end.line || start.line === end.line \u0026\u0026 start.character \u003e end.character) {\n    return { start: end, end: start };\n  }\n  return range;\n}\nfunction getWellformedEdit(textEdit) {\n  const range = getWellformedRange(textEdit.range);\n  if (range !== textEdit.range) {\n    return { newText: textEdit.newText, range };\n  }\n  return textEdit;\n}\nvar ErrorCode;\n(function(ErrorCode2) {\n  ErrorCode2[ErrorCode2[\"Undefined\"] = 0] = \"Undefined\";\n  ErrorCode2[ErrorCode2[\"EnumValueMismatch\"] = 1] = \"EnumValueMismatch\";\n  ErrorCode2[ErrorCode2[\"Deprecated\"] = 2] = \"Deprecated\";\n  ErrorCode2[ErrorCode2[\"UnexpectedEndOfComment\"] = 257] = \"UnexpectedEndOfComment\";\n  ErrorCode2[ErrorCode2[\"UnexpectedEndOfString\"] = 258] = \"UnexpectedEndOfString\";\n  ErrorCode2[ErrorCode2[\"UnexpectedEndOfNumber\"] = 259] = \"UnexpectedEndOfNumber\";\n  ErrorCode2[ErrorCode2[\"InvalidUnicode\"] = 260] = \"InvalidUnicode\";\n  ErrorCode2[ErrorCode2[\"InvalidEscapeCharacter\"] = 261] = \"InvalidEscapeCharacter\";\n  ErrorCode2[ErrorCode2[\"InvalidCharacter\"] = 262] = \"InvalidCharacter\";\n  ErrorCode2[ErrorCode2[\"PropertyExpected\"] = 513] = \"PropertyExpected\";\n  ErrorCode2[ErrorCode2[\"CommaExpected\"] = 514] = \"CommaExpected\";\n  ErrorCode2[ErrorCode2[\"ColonExpected\"] = 515] = \"ColonExpected\";\n  ErrorCode2[ErrorCode2[\"ValueExpected\"] = 516] = \"ValueExpected\";\n  ErrorCode2[ErrorCode2[\"CommaOrCloseBacketExpected\"] = 517] = \"CommaOrCloseBacketExpected\";\n  ErrorCode2[ErrorCode2[\"CommaOrCloseBraceExpected\"] = 518] = \"CommaOrCloseBraceExpected\";\n  ErrorCode2[ErrorCode2[\"TrailingComma\"] = 519] = \"TrailingComma\";\n  ErrorCode2[ErrorCode2[\"DuplicateKey\"] = 520] = \"DuplicateKey\";\n  ErrorCode2[ErrorCode2[\"CommentNotPermitted\"] = 521] = \"CommentNotPermitted\";\n  ErrorCode2[ErrorCode2[\"SchemaResolveError\"] = 768] = \"SchemaResolveError\";\n})(ErrorCode || (ErrorCode = {}));\nvar ClientCapabilities;\n(function(ClientCapabilities2) {\n  ClientCapabilities2.LATEST = {\n    textDocument: {\n      completion: {\n        completionItem: {\n          documentationFormat: [MarkupKind.Markdown, MarkupKind.PlainText],\n          commitCharactersSupport: true\n        }\n      }\n    }\n  };\n})(ClientCapabilities || (ClientCapabilities = {}));\nfunction format3(message, args) {\n  let result;\n  if (args.length === 0) {\n    result = message;\n  } else {\n    result = message.replace(/\\{(\\d+)\\}/g, (match, rest) =\u003e {\n      let index = rest[0];\n      return typeof args[index] !== \"undefined\" ? args[index] : match;\n    });\n  }\n  return result;\n}\nfunction localize2(key, message, ...args) {\n  return format3(message, args);\n}\nfunction loadMessageBundle(file) {\n  return localize2;\n}\nvar __extends = /* @__PURE__ */ function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array \u0026\u0026 function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p))\n          d2[p] = b2[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    if (typeof b !== \"function\" \u0026\u0026 b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar localize22 = loadMessageBundle();\nvar formats = {\n  \"color-hex\": { errorMessage: localize22(\"colorHexFormatWarning\", \"Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.\"), pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ },\n  \"date-time\": { errorMessage: localize22(\"dateTimeFormatWarning\", \"String is not a RFC3339 date-time.\"), pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },\n  \"date\": { errorMessage: localize22(\"dateFormatWarning\", \"String is not a RFC3339 date.\"), pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i },\n  \"time\": { errorMessage: localize22(\"timeFormatWarning\", \"String is not a RFC3339 time.\"), pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },\n  \"email\": { errorMessage: localize22(\"emailFormatWarning\", \"String is not an e-mail address.\"), pattern: /^(([^\u003c\u003e()\\[\\]\\\\.,;:\\s@\"]+(\\.[^\u003c\u003e()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,}))$/ },\n  \"hostname\": { errorMessage: localize22(\"hostnameFormatWarning\", \"String is not a hostname.\"), pattern: /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i },\n  \"ipv4\": { errorMessage: localize22(\"ipv4FormatWarning\", \"String is not an IPv4 address.\"), pattern: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/ },\n  \"ipv6\": { errorMessage: localize22(\"ipv6FormatWarning\", \"String is not an IPv6 address.\"), pattern: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i }\n};\nvar ASTNodeImpl = function() {\n  function ASTNodeImpl2(parent, offset, length) {\n    if (length === void 0) {\n      length = 0;\n    }\n    this.offset = offset;\n    this.length = length;\n    this.parent = parent;\n  }\n  Object.defineProperty(ASTNodeImpl2.prototype, \"children\", {\n    get: function() {\n      return [];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ASTNodeImpl2.prototype.toString = function() {\n    return \"type: \" + this.type + \" (\" + this.offset + \"/\" + this.length + \")\" + (this.parent ? \" parent: {\" + this.parent.toString() + \"}\" : \"\");\n  };\n  return ASTNodeImpl2;\n}();\nvar NullASTNodeImpl = function(_super) {\n  __extends(NullASTNodeImpl2, _super);\n  function NullASTNodeImpl2(parent, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n    _this.type = \"null\";\n    _this.value = null;\n    return _this;\n  }\n  return NullASTNodeImpl2;\n}(ASTNodeImpl);\nvar BooleanASTNodeImpl = function(_super) {\n  __extends(BooleanASTNodeImpl2, _super);\n  function BooleanASTNodeImpl2(parent, boolValue, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n    _this.type = \"boolean\";\n    _this.value = boolValue;\n    return _this;\n  }\n  return BooleanASTNodeImpl2;\n}(ASTNodeImpl);\nvar ArrayASTNodeImpl = function(_super) {\n  __extends(ArrayASTNodeImpl2, _super);\n  function ArrayASTNodeImpl2(parent, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n    _this.type = \"array\";\n    _this.items = [];\n    return _this;\n  }\n  Object.defineProperty(ArrayASTNodeImpl2.prototype, \"children\", {\n    get: function() {\n      return this.items;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ArrayASTNodeImpl2;\n}(ASTNodeImpl);\nvar NumberASTNodeImpl = function(_super) {\n  __extends(NumberASTNodeImpl2, _super);\n  function NumberASTNodeImpl2(parent, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n    _this.type = \"number\";\n    _this.isInteger = true;\n    _this.value = Number.NaN;\n    return _this;\n  }\n  return NumberASTNodeImpl2;\n}(ASTNodeImpl);\nvar StringASTNodeImpl = function(_super) {\n  __extends(StringASTNodeImpl2, _super);\n  function StringASTNodeImpl2(parent, offset, length) {\n    var _this = _super.call(this, parent, offset, length) || this;\n    _this.type = \"string\";\n    _this.value = \"\";\n    return _this;\n  }\n  return StringASTNodeImpl2;\n}(ASTNodeImpl);\nvar PropertyASTNodeImpl = function(_super) {\n  __extends(PropertyASTNodeImpl2, _super);\n  function PropertyASTNodeImpl2(parent, offset, keyNode) {\n    var _this = _super.call(this, parent, offset) || this;\n    _this.type = \"property\";\n    _this.colonOffset = -1;\n    _this.keyNode = keyNode;\n    return _this;\n  }\n  Object.defineProperty(PropertyASTNodeImpl2.prototype, \"children\", {\n    get: function() {\n      return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return PropertyASTNodeImpl2;\n}(ASTNodeImpl);\nvar ObjectASTNodeImpl = function(_super) {\n  __extends(ObjectASTNodeImpl2, _super);\n  function ObjectASTNodeImpl2(parent, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n    _this.type = \"object\";\n    _this.properties = [];\n    return _this;\n  }\n  Object.defineProperty(ObjectASTNodeImpl2.prototype, \"children\", {\n    get: function() {\n      return this.properties;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ObjectASTNodeImpl2;\n}(ASTNodeImpl);\nfunction asSchema(schema2) {\n  if (isBoolean(schema2)) {\n    return schema2 ? {} : { \"not\": {} };\n  }\n  return schema2;\n}\nvar EnumMatch;\n(function(EnumMatch2) {\n  EnumMatch2[EnumMatch2[\"Key\"] = 0] = \"Key\";\n  EnumMatch2[EnumMatch2[\"Enum\"] = 1] = \"Enum\";\n})(EnumMatch || (EnumMatch = {}));\nvar SchemaCollector = function() {\n  function SchemaCollector2(focusOffset, exclude) {\n    if (focusOffset === void 0) {\n      focusOffset = -1;\n    }\n    this.focusOffset = focusOffset;\n    this.exclude = exclude;\n    this.schemas = [];\n  }\n  SchemaCollector2.prototype.add = function(schema2) {\n    this.schemas.push(schema2);\n  };\n  SchemaCollector2.prototype.merge = function(other) {\n    Array.prototype.push.apply(this.schemas, other.schemas);\n  };\n  SchemaCollector2.prototype.include = function(node) {\n    return (this.focusOffset === -1 || contains2(node, this.focusOffset)) \u0026\u0026 node !== this.exclude;\n  };\n  SchemaCollector2.prototype.newSub = function() {\n    return new SchemaCollector2(-1, this.exclude);\n  };\n  return SchemaCollector2;\n}();\nvar NoOpSchemaCollector = function() {\n  function NoOpSchemaCollector2() {\n  }\n  Object.defineProperty(NoOpSchemaCollector2.prototype, \"schemas\", {\n    get: function() {\n      return [];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  NoOpSchemaCollector2.prototype.add = function(schema2) {\n  };\n  NoOpSchemaCollector2.prototype.merge = function(other) {\n  };\n  NoOpSchemaCollector2.prototype.include = function(node) {\n    return true;\n  };\n  NoOpSchemaCollector2.prototype.newSub = function() {\n    return this;\n  };\n  NoOpSchemaCollector2.instance = new NoOpSchemaCollector2();\n  return NoOpSchemaCollector2;\n}();\nvar ValidationResult = function() {\n  function ValidationResult2() {\n    this.problems = [];\n    this.propertiesMatches = 0;\n    this.propertiesValueMatches = 0;\n    this.primaryValueMatches = 0;\n    this.enumValueMatch = false;\n    this.enumValues = void 0;\n  }\n  ValidationResult2.prototype.hasProblems = function() {\n    return !!this.problems.length;\n  };\n  ValidationResult2.prototype.mergeAll = function(validationResults) {\n    for (var _i = 0, validationResults_1 = validationResults; _i \u003c validationResults_1.length; _i++) {\n      var validationResult = validationResults_1[_i];\n      this.merge(validationResult);\n    }\n  };\n  ValidationResult2.prototype.merge = function(validationResult) {\n    this.problems = this.problems.concat(validationResult.problems);\n  };\n  ValidationResult2.prototype.mergeEnumValues = function(validationResult) {\n    if (!this.enumValueMatch \u0026\u0026 !validationResult.enumValueMatch \u0026\u0026 this.enumValues \u0026\u0026 validationResult.enumValues) {\n      this.enumValues = this.enumValues.concat(validationResult.enumValues);\n      for (var _i = 0, _a4 = this.problems; _i \u003c _a4.length; _i++) {\n        var error = _a4[_i];\n        if (error.code === ErrorCode.EnumValueMismatch) {\n          error.message = localize22(\"enumWarning\", \"Value is not accepted. Valid values: {0}.\", this.enumValues.map(function(v) {\n            return JSON.stringify(v);\n          }).join(\", \"));\n        }\n      }\n    }\n  };\n  ValidationResult2.prototype.mergePropertyMatch = function(propertyValidationResult) {\n    this.merge(propertyValidationResult);\n    this.propertiesMatches++;\n    if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() \u0026\u0026 propertyValidationResult.propertiesMatches) {\n      this.propertiesValueMatches++;\n    }\n    if (propertyValidationResult.enumValueMatch \u0026\u0026 propertyValidationResult.enumValues \u0026\u0026 propertyValidationResult.enumValues.length === 1) {\n      this.primaryValueMatches++;\n    }\n  };\n  ValidationResult2.prototype.compare = function(other) {\n    var hasProblems = this.hasProblems();\n    if (hasProblems !== other.hasProblems()) {\n      return hasProblems ? -1 : 1;\n    }\n    if (this.enumValueMatch !== other.enumValueMatch) {\n      return other.enumValueMatch ? -1 : 1;\n    }\n    if (this.primaryValueMatches !== other.primaryValueMatches) {\n      return this.primaryValueMatches - other.primaryValueMatches;\n    }\n    if (this.propertiesValueMatches !== other.propertiesValueMatches) {\n      return this.propertiesValueMatches - other.propertiesValueMatches;\n    }\n    return this.propertiesMatches - other.propertiesMatches;\n  };\n  return ValidationResult2;\n}();\nfunction newJSONDocument(root, diagnostics) {\n  if (diagnostics === void 0) {\n    diagnostics = [];\n  }\n  return new JSONDocument(root, diagnostics, []);\n}\nfunction getNodeValue3(node) {\n  return getNodeValue2(node);\n}\nfunction getNodePath3(node) {\n  return getNodePath2(node);\n}\nfunction contains2(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n  return offset \u003e= node.offset \u0026\u0026 offset \u003c node.offset + node.length || includeRightBound \u0026\u0026 offset === node.offset + node.length;\n}\nvar JSONDocument = function() {\n  function JSONDocument2(root, syntaxErrors, comments) {\n    if (syntaxErrors === void 0) {\n      syntaxErrors = [];\n    }\n    if (comments === void 0) {\n      comments = [];\n    }\n    this.root = root;\n    this.syntaxErrors = syntaxErrors;\n    this.comments = comments;\n  }\n  JSONDocument2.prototype.getNodeFromOffset = function(offset, includeRightBound) {\n    if (includeRightBound === void 0) {\n      includeRightBound = false;\n    }\n    if (this.root) {\n      return findNodeAtOffset2(this.root, offset, includeRightBound);\n    }\n    return void 0;\n  };\n  JSONDocument2.prototype.visit = function(visitor) {\n    if (this.root) {\n      var doVisit_1 = function(node) {\n        var ctn = visitor(node);\n        var children = node.children;\n        if (Array.isArray(children)) {\n          for (var i = 0; i \u003c children.length \u0026\u0026 ctn; i++) {\n            ctn = doVisit_1(children[i]);\n          }\n        }\n        return ctn;\n      };\n      doVisit_1(this.root);\n    }\n  };\n  JSONDocument2.prototype.validate = function(textDocument, schema2, severity) {\n    if (severity === void 0) {\n      severity = DiagnosticSeverity.Warning;\n    }\n    if (this.root \u0026\u0026 schema2) {\n      var validationResult = new ValidationResult();\n      validate(this.root, schema2, validationResult, NoOpSchemaCollector.instance);\n      return validationResult.problems.map(function(p) {\n        var _a4;\n        var range = Range2.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));\n        return Diagnostic.create(range, p.message, (_a4 = p.severity) !== null \u0026\u0026 _a4 !== void 0 ? _a4 : severity, p.code);\n      });\n    }\n    return void 0;\n  };\n  JSONDocument2.prototype.getMatchingSchemas = function(schema2, focusOffset, exclude) {\n    if (focusOffset === void 0) {\n      focusOffset = -1;\n    }\n    var matchingSchemas = new SchemaCollector(focusOffset, exclude);\n    if (this.root \u0026\u0026 schema2) {\n      validate(this.root, schema2, new ValidationResult(), matchingSchemas);\n    }\n    return matchingSchemas.schemas;\n  };\n  return JSONDocument2;\n}();\nfunction validate(n, schema2, validationResult, matchingSchemas) {\n  if (!n || !matchingSchemas.include(n)) {\n    return;\n  }\n  var node = n;\n  switch (node.type) {\n    case \"object\":\n      _validateObjectNode(node, schema2, validationResult, matchingSchemas);\n      break;\n    case \"array\":\n      _validateArrayNode(node, schema2, validationResult, matchingSchemas);\n      break;\n    case \"string\":\n      _validateStringNode(node, schema2, validationResult, matchingSchemas);\n      break;\n    case \"number\":\n      _validateNumberNode(node, schema2, validationResult, matchingSchemas);\n      break;\n    case \"property\":\n      return validate(node.valueNode, schema2, validationResult, matchingSchemas);\n  }\n  _validateNode();\n  matchingSchemas.add({ node, schema: schema2 });\n  function _validateNode() {\n    function matchesType(type) {\n      return node.type === type || type === \"integer\" \u0026\u0026 node.type === \"number\" \u0026\u0026 node.isInteger;\n    }\n    if (Array.isArray(schema2.type)) {\n      if (!schema2.type.some(matchesType)) {\n        validationResult.problems.push({\n          location: { offset: node.offset, length: node.length },\n          message: schema2.errorMessage || localize22(\"typeArrayMismatchWarning\", \"Incorrect type. Expected one of {0}.\", schema2.type.join(\", \"))\n        });\n      }\n    } else if (schema2.type) {\n      if (!matchesType(schema2.type)) {\n        validationResult.problems.push({\n          location: { offset: node.offset, length: node.length },\n          message: schema2.errorMessage || localize22(\"typeMismatchWarning\", 'Incorrect type. Expected \"{0}\".', schema2.type)\n        });\n      }\n    }\n    if (Array.isArray(schema2.allOf)) {\n      for (var _i = 0, _a4 = schema2.allOf; _i \u003c _a4.length; _i++) {\n        var subSchemaRef = _a4[_i];\n        validate(node, asSchema(subSchemaRef), validationResult, matchingSchemas);\n      }\n    }\n    var notSchema = asSchema(schema2.not);\n    if (notSchema) {\n      var subValidationResult = new ValidationResult();\n      var subMatchingSchemas = matchingSchemas.newSub();\n      validate(node, notSchema, subValidationResult, subMatchingSchemas);\n      if (!subValidationResult.hasProblems()) {\n        validationResult.problems.push({\n          location: { offset: node.offset, length: node.length },\n          message: localize22(\"notSchemaWarning\", \"Matches a schema that is not allowed.\")\n        });\n      }\n      for (var _b2 = 0, _c = subMatchingSchemas.schemas; _b2 \u003c _c.length; _b2++) {\n        var ms = _c[_b2];\n        ms.inverted = !ms.inverted;\n        matchingSchemas.add(ms);\n      }\n    }\n    var testAlternatives = function(alternatives, maxOneMatch) {\n      var matches = [];\n      var bestMatch = void 0;\n      for (var _i2 = 0, alternatives_1 = alternatives; _i2 \u003c alternatives_1.length; _i2++) {\n        var subSchemaRef2 = alternatives_1[_i2];\n        var subSchema = asSchema(subSchemaRef2);\n        var subValidationResult2 = new ValidationResult();\n        var subMatchingSchemas2 = matchingSchemas.newSub();\n        validate(node, subSchema, subValidationResult2, subMatchingSchemas2);\n        if (!subValidationResult2.hasProblems()) {\n          matches.push(subSchema);\n        }\n        if (!bestMatch) {\n          bestMatch = { schema: subSchema, validationResult: subValidationResult2, matchingSchemas: subMatchingSchemas2 };\n        } else {\n          if (!maxOneMatch \u0026\u0026 !subValidationResult2.hasProblems() \u0026\u0026 !bestMatch.validationResult.hasProblems()) {\n            bestMatch.matchingSchemas.merge(subMatchingSchemas2);\n            bestMatch.validationResult.propertiesMatches += subValidationResult2.propertiesMatches;\n            bestMatch.validationResult.propertiesValueMatches += subValidationResult2.propertiesValueMatches;\n          } else {\n            var compareResult = subValidationResult2.compare(bestMatch.validationResult);\n            if (compareResult \u003e 0) {\n              bestMatch = { schema: subSchema, validationResult: subValidationResult2, matchingSchemas: subMatchingSchemas2 };\n            } else if (compareResult === 0) {\n              bestMatch.matchingSchemas.merge(subMatchingSchemas2);\n              bestMatch.validationResult.mergeEnumValues(subValidationResult2);\n            }\n          }\n        }\n      }\n      if (matches.length \u003e 1 \u0026\u0026 maxOneMatch) {\n        validationResult.problems.push({\n          location: { offset: node.offset, length: 1 },\n          message: localize22(\"oneOfWarning\", \"Matches multiple schemas when only one must validate.\")\n        });\n      }\n      if (bestMatch) {\n        validationResult.merge(bestMatch.validationResult);\n        validationResult.propertiesMatches += bestMatch.validationResult.propertiesMatches;\n        validationResult.propertiesValueMatches += bestMatch.validationResult.propertiesValueMatches;\n        matchingSchemas.merge(bestMatch.matchingSchemas);\n      }\n      return matches.length;\n    };\n    if (Array.isArray(schema2.anyOf)) {\n      testAlternatives(schema2.anyOf, false);\n    }\n    if (Array.isArray(schema2.oneOf)) {\n      testAlternatives(schema2.oneOf, true);\n    }\n    var testBranch = function(schema22) {\n      var subValidationResult2 = new ValidationResult();\n      var subMatchingSchemas2 = matchingSchemas.newSub();\n      validate(node, asSchema(schema22), subValidationResult2, subMatchingSchemas2);\n      validationResult.merge(subValidationResult2);\n      validationResult.propertiesMatches += subValidationResult2.propertiesMatches;\n      validationResult.propertiesValueMatches += subValidationResult2.propertiesValueMatches;\n      matchingSchemas.merge(subMatchingSchemas2);\n    };\n    var testCondition = function(ifSchema2, thenSchema, elseSchema) {\n      var subSchema = asSchema(ifSchema2);\n      var subValidationResult2 = new ValidationResult();\n      var subMatchingSchemas2 = matchingSchemas.newSub();\n      validate(node, subSchema, subValidationResult2, subMatchingSchemas2);\n      matchingSchemas.merge(subMatchingSchemas2);\n      if (!subValidationResult2.hasProblems()) {\n        if (thenSchema) {\n          testBranch(thenSchema);\n        }\n      } else if (elseSchema) {\n        testBranch(elseSchema);\n      }\n    };\n    var ifSchema = asSchema(schema2.if);\n    if (ifSchema) {\n      testCondition(ifSchema, asSchema(schema2.then), asSchema(schema2.else));\n    }\n    if (Array.isArray(schema2.enum)) {\n      var val = getNodeValue3(node);\n      var enumValueMatch = false;\n      for (var _d = 0, _e = schema2.enum; _d \u003c _e.length; _d++) {\n        var e = _e[_d];\n        if (equals3(val, e)) {\n          enumValueMatch = true;\n          break;\n        }\n      }\n      validationResult.enumValues = schema2.enum;\n      validationResult.enumValueMatch = enumValueMatch;\n      if (!enumValueMatch) {\n        validationResult.problems.push({\n          location: { offset: node.offset, length: node.length },\n          code: ErrorCode.EnumValueMismatch,\n          message: schema2.errorMessage || localize22(\"enumWarning\", \"Value is not accepted. Valid values: {0}.\", schema2.enum.map(function(v) {\n            return JSON.stringify(v);\n          }).join(\", \"))\n        });\n      }\n    }\n    if (isDefined(schema2.const)) {\n      var val = getNodeValue3(node);\n      if (!equals3(val, schema2.const)) {\n        validationResult.problems.push({\n          location: { offset: node.offset, length: node.length },\n          code: ErrorCode.EnumValueMismatch,\n          message: schema2.errorMessage || localize22(\"constWarning\", \"Value must be {0}.\", JSON.stringify(schema2.const))\n        });\n        validationResult.enumValueMatch = false;\n      } else {\n        validationResult.enumValueMatch = true;\n      }\n      validationResult.enumValues = [schema2.const];\n    }\n    if (schema2.deprecationMessage \u0026\u0026 node.parent) {\n      validationResult.problems.push({\n        location: { offset: node.parent.offset, length: node.parent.length },\n        severity: DiagnosticSeverity.Warning,\n        message: schema2.deprecationMessage,\n        code: ErrorCode.Deprecated\n      });\n    }\n  }\n  function _validateNumberNode(node2, schema22, validationResult2, matchingSchemas2) {\n    var val = node2.value;\n    function normalizeFloats(float) {\n      var _a4;\n      var parts = /^(-?\\d+)(?:\\.(\\d+))?(?:e([-+]\\d+))?$/.exec(float.toString());\n      return parts \u0026\u0026 {\n        value: Number(parts[1] + (parts[2] || \"\")),\n        multiplier: (((_a4 = parts[2]) === null || _a4 === void 0 ? void 0 : _a4.length) || 0) - (parseInt(parts[3]) || 0)\n      };\n    }\n    ;\n    if (isNumber(schema22.multipleOf)) {\n      var remainder = -1;\n      if (Number.isInteger(schema22.multipleOf)) {\n        remainder = val % schema22.multipleOf;\n      } else {\n        var normMultipleOf = normalizeFloats(schema22.multipleOf);\n        var normValue = normalizeFloats(val);\n        if (normMultipleOf \u0026\u0026 normValue) {\n          var multiplier = Math.pow(10, Math.abs(normValue.multiplier - normMultipleOf.multiplier));\n          if (normValue.multiplier \u003c normMultipleOf.multiplier) {\n            normValue.value *= multiplier;\n          } else {\n            normMultipleOf.value *= multiplier;\n          }\n          remainder = normValue.value % normMultipleOf.value;\n        }\n      }\n      if (remainder !== 0) {\n        validationResult2.problems.push({\n          location: { offset: node2.offset, length: node2.length },\n          message: localize22(\"multipleOfWarning\", \"Value is not divisible by {0}.\", schema22.multipleOf)\n        });\n      }\n    }\n    function getExclusiveLimit(limit, exclusive) {\n      if (isNumber(exclusive)) {\n        return exclusive;\n      }\n      if (isBoolean(exclusive) \u0026\u0026 exclusive) {\n        return limit;\n      }\n      return void 0;\n    }\n    function getLimit(limit, exclusive) {\n      if (!isBoolean(exclusive) || !exclusive) {\n        return limit;\n      }\n      return void 0;\n    }\n    var exclusiveMinimum = getExclusiveLimit(schema22.minimum, schema22.exclusiveMinimum);\n    if (isNumber(exclusiveMinimum) \u0026\u0026 val \u003c= exclusiveMinimum) {\n      validationResult2.problems.push({\n        location: { offset: node2.offset, length: node2.length },\n        message: localize22(\"exclusiveMinimumWarning\", \"Value is below the exclusive minimum of {0}.\", exclusiveMinimum)\n      });\n    }\n    var exclusiveMaximum = getExclusiveLimit(schema22.maximum, schema22.exclusiveMaximum);\n    if (isNumber(exclusiveMaximum) \u0026\u0026 val \u003e= exclusiveMaximum) {\n      validationResult2.problems.push({\n        location: { offset: node2.offset, length: node2.length },\n        message: localize22(\"exclusiveMaximumWarning\", \"Value is above the exclusive maximum of {0}.\", exclusiveMaximum)\n      });\n    }\n    var minimum = getLimit(schema22.minimum, schema22.exclusiveMinimum);\n    if (isNumber(minimum) \u0026\u0026 val \u003c minimum) {\n      validationResult2.problems.push({\n        location: { offset: node2.offset, length: node2.length },\n        message: localize22(\"minimumWarning\", \"Value is below the minimum of {0}.\", minimum)\n      });\n    }\n    var maximum = getLimit(schema22.maximum, schema22.exclusiveMaximum);\n    if (isNumber(maximum) \u0026\u0026 val \u003e maximum) {\n      validationResult2.problems.push({\n        location: { offset: node2.offset, length: node2.length },\n        message: localize22(\"maximumWarning\", \"Value is above the maximum of {0}.\", maximum)\n      });\n    }\n  }\n  function _validateStringNode(node2, schema22, validationResult2, matchingSchemas2) {\n    if (isNumber(schema22.minLength) \u0026\u0026 node2.value.length \u003c schema22.minLength) {\n      validationResult2.problems.push({\n        location: { offset: node2.offset, length: node2.length },\n        message: localize22(\"minLengthWarning\", \"String is shorter than the minimum length of {0}.\", schema22.minLength)\n      });\n    }\n    if (isNumber(schema22.maxLength) \u0026\u0026 node2.value.length \u003e schema22.maxLength) {\n      validationResult2.problems.push({\n        location: { offset: node2.offset, length: node2.length },\n        message: localize22(\"maxLengthWarning\", \"String is longer than the maximum length of {0}.\", schema22.maxLength)\n      });\n    }\n    if (isString2(schema22.pattern)) {\n      var regex = extendedRegExp(schema22.pattern);\n      if (!(regex === null || regex === void 0 ? void 0 : regex.test(node2.value))) {\n        validationResult2.problems.push({\n          location: { offset: node2.offset, length: node2.length },\n          message: schema22.patternErrorMessage || schema22.errorMessage || localize22(\"patternWarning\", 'String does not match the pattern of \"{0}\".', schema22.pattern)\n        });\n      }\n    }\n    if (schema22.format) {\n      switch (schema22.format) {\n        case \"uri\":\n        case \"uri-reference\":\n          {\n            var errorMessage = void 0;\n            if (!node2.value) {\n              errorMessage = localize22(\"uriEmpty\", \"URI expected.\");\n            } else {\n              var match = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/.exec(node2.value);\n              if (!match) {\n                errorMessage = localize22(\"uriMissing\", \"URI is expected.\");\n              } else if (!match[2] \u0026\u0026 schema22.format === \"uri\") {\n                errorMessage = localize22(\"uriSchemeMissing\", \"URI with a scheme is expected.\");\n              }\n            }\n            if (errorMessage) {\n              validationResult2.problems.push({\n                location: { offset: node2.offset, length: node2.length },\n                message: schema22.patternErrorMessage || schema22.errorMessage || localize22(\"uriFormatWarning\", \"String is not a URI: {0}\", errorMessage)\n              });\n            }\n          }\n          break;\n        case \"color-hex\":\n        case \"date-time\":\n        case \"date\":\n        case \"time\":\n        case \"email\":\n        case \"hostname\":\n        case \"ipv4\":\n        case \"ipv6\":\n          var format4 = formats[schema22.format];\n          if (!node2.value || !format4.pattern.exec(node2.value)) {\n            validationResult2.problems.push({\n              location: { offset: node2.offset, length: node2.length },\n              message: schema22.patternErrorMessage || schema22.errorMessage || format4.errorMessage\n            });\n          }\n        default:\n      }\n    }\n  }\n  function _validateArrayNode(node2, schema22, validationResult2, matchingSchemas2) {\n    if (Array.isArray(schema22.items)) {\n      var subSchemas = schema22.items;\n      for (var index = 0; index \u003c subSchemas.length; index++) {\n        var subSchemaRef = subSchemas[index];\n        var subSchema = asSchema(subSchemaRef);\n        var itemValidationResult = new ValidationResult();\n        var item = node2.items[index];\n        if (item) {\n          validate(item, subSchema, itemValidationResult, matchingSchemas2);\n          validationResult2.mergePropertyMatch(itemValidationResult);\n        } else if (node2.items.length \u003e= subSchemas.length) {\n          validationResult2.propertiesValueMatches++;\n        }\n      }\n      if (node2.items.length \u003e subSchemas.length) {\n        if (typeof schema22.additionalItems === \"object\") {\n          for (var i = subSchemas.length; i \u003c node2.items.length; i++) {\n            var itemValidationResult = new ValidationResult();\n            validate(node2.items[i], schema22.additionalItems, itemValidationResult, matchingSchemas2);\n            validationResult2.mergePropertyMatch(itemValidationResult);\n          }\n        } else if (schema22.additionalItems === false) {\n          validationResult2.problems.push({\n            location: { offset: node2.offset, length: node2.length },\n            message: localize22(\"additionalItemsWarning\", \"Array has too many items according to schema. Expected {0} or fewer.\", subSchemas.length)\n          });\n        }\n      }\n    } else {\n      var itemSchema = asSchema(schema22.items);\n      if (itemSchema) {\n        for (var _i = 0, _a4 = node2.items; _i \u003c _a4.length; _i++) {\n          var item = _a4[_i];\n          var itemValidationResult = new ValidationResult();\n          validate(item, itemSchema, itemValidationResult, matchingSchemas2);\n          validationResult2.mergePropertyMatch(itemValidationResult);\n        }\n      }\n    }\n    var containsSchema = asSchema(schema22.contains);\n    if (containsSchema) {\n      var doesContain = node2.items.some(function(item2) {\n        var itemValidationResult2 = new ValidationResult();\n        validate(item2, containsSchema, itemValidationResult2, NoOpSchemaCollector.instance);\n        return !itemValidationResult2.hasProblems();\n      });\n      if (!doesContain) {\n        validationResult2.problems.push({\n          location: { offset: node2.offset, length: node2.length },\n          message: schema22.errorMessage || localize22(\"requiredItemMissingWarning\", \"Array does not contain required item.\")\n        });\n      }\n    }\n    if (isNumber(schema22.minItems) \u0026\u0026 node2.items.length \u003c schema22.minItems) {\n      validationResult2.problems.push({\n        location: { offset: node2.offset, length: node2.length },\n        message: localize22(\"minItemsWarning\", \"Array has too few items. Expected {0} or more.\", schema22.minItems)\n      });\n    }\n    if (isNumber(schema22.maxItems) \u0026\u0026 node2.items.length \u003e schema22.maxItems) {\n      validationResult2.problems.push({\n        location: { offset: node2.offset, length: node2.length },\n        message: localize22(\"maxItemsWarning\", \"Array has too many items. Expected {0} or fewer.\", schema22.maxItems)\n      });\n    }\n    if (schema22.uniqueItems === true) {\n      var values_1 = getNodeValue3(node2);\n      var duplicates = values_1.some(function(value, index2) {\n        return index2 !== values_1.lastIndexOf(value);\n      });\n      if (duplicates) {\n        validationResult2.problems.push({\n          location: { offset: node2.offset, length: node2.length },\n          message: localize22(\"uniqueItemsWarning\", \"Array has duplicate items.\")\n        });\n      }\n    }\n  }\n  function _validateObjectNode(node2, schema22, validationResult2, matchingSchemas2) {\n    var seenKeys = /* @__PURE__ */ Object.create(null);\n    var unprocessedProperties = [];\n    for (var _i = 0, _a4 = node2.properties; _i \u003c _a4.length; _i++) {\n      var propertyNode = _a4[_i];\n      var key = propertyNode.keyNode.value;\n      seenKeys[key] = propertyNode.valueNode;\n      unprocessedProperties.push(key);\n    }\n    if (Array.isArray(schema22.required)) {\n      for (var _b2 = 0, _c = schema22.required; _b2 \u003c _c.length; _b2++) {\n        var propertyName = _c[_b2];\n        if (!seenKeys[propertyName]) {\n          var keyNode = node2.parent \u0026\u0026 node2.parent.type === \"property\" \u0026\u0026 node2.parent.keyNode;\n          var location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node2.offset, length: 1 };\n          validationResult2.problems.push({\n            location,\n            message: localize22(\"MissingRequiredPropWarning\", 'Missing property \"{0}\".', propertyName)\n          });\n        }\n      }\n    }\n    var propertyProcessed = function(prop2) {\n      var index = unprocessedProperties.indexOf(prop2);\n      while (index \u003e= 0) {\n        unprocessedProperties.splice(index, 1);\n        index = unprocessedProperties.indexOf(prop2);\n      }\n    };\n    if (schema22.properties) {\n      for (var _d = 0, _e = Object.keys(schema22.properties); _d \u003c _e.length; _d++) {\n        var propertyName = _e[_d];\n        propertyProcessed(propertyName);\n        var propertySchema = schema22.properties[propertyName];\n        var child = seenKeys[propertyName];\n        if (child) {\n          if (isBoolean(propertySchema)) {\n            if (!propertySchema) {\n              var propertyNode = child.parent;\n              validationResult2.problems.push({\n                location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                message: schema22.errorMessage || localize22(\"DisallowedExtraPropWarning\", \"Property {0} is not allowed.\", propertyName)\n              });\n            } else {\n              validationResult2.propertiesMatches++;\n              validationResult2.propertiesValueMatches++;\n            }\n          } else {\n            var propertyValidationResult = new ValidationResult();\n            validate(child, propertySchema, propertyValidationResult, matchingSchemas2);\n            validationResult2.mergePropertyMatch(propertyValidationResult);\n          }\n        }\n      }\n    }\n    if (schema22.patternProperties) {\n      for (var _f = 0, _g = Object.keys(schema22.patternProperties); _f \u003c _g.length; _f++) {\n        var propertyPattern = _g[_f];\n        var regex = extendedRegExp(propertyPattern);\n        for (var _h = 0, _j = unprocessedProperties.slice(0); _h \u003c _j.length; _h++) {\n          var propertyName = _j[_h];\n          if (regex === null || regex === void 0 ? void 0 : regex.test(propertyName)) {\n            propertyProcessed(propertyName);\n            var child = seenKeys[propertyName];\n            if (child) {\n              var propertySchema = schema22.patternProperties[propertyPattern];\n              if (isBoolean(propertySchema)) {\n                if (!propertySchema) {\n                  var propertyNode = child.parent;\n                  validationResult2.problems.push({\n                    location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                    message: schema22.errorMessage || localize22(\"DisallowedExtraPropWarning\", \"Property {0} is not allowed.\", propertyName)\n                  });\n                } else {\n                  validationResult2.propertiesMatches++;\n                  validationResult2.propertiesValueMatches++;\n                }\n              } else {\n                var propertyValidationResult = new ValidationResult();\n                validate(child, propertySchema, propertyValidationResult, matchingSchemas2);\n                validationResult2.mergePropertyMatch(propertyValidationResult);\n              }\n            }\n          }\n        }\n      }\n    }\n    if (typeof schema22.additionalProperties === \"object\") {\n      for (var _k = 0, unprocessedProperties_1 = unprocessedProperties; _k \u003c unprocessedProperties_1.length; _k++) {\n        var propertyName = unprocessedProperties_1[_k];\n        var child = seenKeys[propertyName];\n        if (child) {\n          var propertyValidationResult = new ValidationResult();\n          validate(child, schema22.additionalProperties, propertyValidationResult, matchingSchemas2);\n          validationResult2.mergePropertyMatch(propertyValidationResult);\n        }\n      }\n    } else if (schema22.additionalProperties === false) {\n      if (unprocessedProperties.length \u003e 0) {\n        for (var _l = 0, unprocessedProperties_2 = unprocessedProperties; _l \u003c unprocessedProperties_2.length; _l++) {\n          var propertyName = unprocessedProperties_2[_l];\n          var child = seenKeys[propertyName];\n          if (child) {\n            var propertyNode = child.parent;\n            validationResult2.problems.push({\n              location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n              message: schema22.errorMessage || localize22(\"DisallowedExtraPropWarning\", \"Property {0} is not allowed.\", propertyName)\n            });\n          }\n        }\n      }\n    }\n    if (isNumber(schema22.maxProperties)) {\n      if (node2.properties.length \u003e schema22.maxProperties) {\n        validationResult2.problems.push({\n          location: { offset: node2.offset, length: node2.length },\n          message: localize22(\"MaxPropWarning\", \"Object has more properties than limit of {0}.\", schema22.maxProperties)\n        });\n      }\n    }\n    if (isNumber(schema22.minProperties)) {\n      if (node2.properties.length \u003c schema22.minProperties) {\n        validationResult2.problems.push({\n          location: { offset: node2.offset, length: node2.length },\n          message: localize22(\"MinPropWarning\", \"Object has fewer properties than the required number of {0}\", schema22.minProperties)\n        });\n      }\n    }\n    if (schema22.dependencies) {\n      for (var _m = 0, _o = Object.keys(schema22.dependencies); _m \u003c _o.length; _m++) {\n        var key = _o[_m];\n        var prop = seenKeys[key];\n        if (prop) {\n          var propertyDep = schema22.dependencies[key];\n          if (Array.isArray(propertyDep)) {\n            for (var _p = 0, propertyDep_1 = propertyDep; _p \u003c propertyDep_1.length; _p++) {\n              var requiredProp = propertyDep_1[_p];\n              if (!seenKeys[requiredProp]) {\n                validationResult2.problems.push({\n                  location: { offset: node2.offset, length: node2.length },\n                  message: localize22(\"RequiredDependentPropWarning\", \"Object is missing property {0} required by property {1}.\", requiredProp, key)\n                });\n              } else {\n                validationResult2.propertiesValueMatches++;\n              }\n            }\n          } else {\n            var propertySchema = asSchema(propertyDep);\n            if (propertySchema) {\n              var propertyValidationResult = new ValidationResult();\n              validate(node2, propertySchema, propertyValidationResult, matchingSchemas2);\n              validationResult2.mergePropertyMatch(propertyValidationResult);\n            }\n          }\n        }\n      }\n    }\n    var propertyNames = asSchema(schema22.propertyNames);\n    if (propertyNames) {\n      for (var _q = 0, _r = node2.properties; _q \u003c _r.length; _q++) {\n        var f2 = _r[_q];\n        var key = f2.keyNode;\n        if (key) {\n          validate(key, propertyNames, validationResult2, NoOpSchemaCollector.instance);\n        }\n      }\n    }\n  }\n}\nfunction parse3(textDocument, config) {\n  var problems = [];\n  var lastProblemOffset = -1;\n  var text = textDocument.getText();\n  var scanner = createScanner2(text, false);\n  var commentRanges = config \u0026\u0026 config.collectComments ? [] : void 0;\n  function _scanNext() {\n    while (true) {\n      var token_1 = scanner.scan();\n      _checkScanError();\n      switch (token_1) {\n        case 12:\n        case 13:\n          if (Array.isArray(commentRanges)) {\n            commentRanges.push(Range2.create(textDocument.positionAt(scanner.getTokenOffset()), textDocument.positionAt(scanner.getTokenOffset() + scanner.getTokenLength())));\n          }\n          break;\n        case 15:\n        case 14:\n          break;\n        default:\n          return token_1;\n      }\n    }\n  }\n  function _accept(token2) {\n    if (scanner.getToken() === token2) {\n      _scanNext();\n      return true;\n    }\n    return false;\n  }\n  function _errorAtRange(message, code, startOffset, endOffset, severity) {\n    if (severity === void 0) {\n      severity = DiagnosticSeverity.Error;\n    }\n    if (problems.length === 0 || startOffset !== lastProblemOffset) {\n      var range = Range2.create(textDocument.positionAt(startOffset), textDocument.positionAt(endOffset));\n      problems.push(Diagnostic.create(range, message, severity, code, textDocument.languageId));\n      lastProblemOffset = startOffset;\n    }\n  }\n  function _error(message, code, node, skipUntilAfter, skipUntil) {\n    if (node === void 0) {\n      node = void 0;\n    }\n    if (skipUntilAfter === void 0) {\n      skipUntilAfter = [];\n    }\n    if (skipUntil === void 0) {\n      skipUntil = [];\n    }\n    var start = scanner.getTokenOffset();\n    var end = scanner.getTokenOffset() + scanner.getTokenLength();\n    if (start === end \u0026\u0026 start \u003e 0) {\n      start--;\n      while (start \u003e 0 \u0026\u0026 /\\s/.test(text.charAt(start))) {\n        start--;\n      }\n      end = start + 1;\n    }\n    _errorAtRange(message, code, start, end);\n    if (node) {\n      _finalize(node, false);\n    }\n    if (skipUntilAfter.length + skipUntil.length \u003e 0) {\n      var token_2 = scanner.getToken();\n      while (token_2 !== 17) {\n        if (skipUntilAfter.indexOf(token_2) !== -1) {\n          _scanNext();\n          break;\n        } else if (skipUntil.indexOf(token_2) !== -1) {\n          break;\n        }\n        token_2 = _scanNext();\n      }\n    }\n    return node;\n  }\n  function _checkScanError() {\n    switch (scanner.getTokenError()) {\n      case 4:\n        _error(localize22(\"InvalidUnicode\", \"Invalid unicode sequence in string.\"), ErrorCode.InvalidUnicode);\n        return true;\n      case 5:\n        _error(localize22(\"InvalidEscapeCharacter\", \"Invalid escape character in string.\"), ErrorCode.InvalidEscapeCharacter);\n        return true;\n      case 3:\n        _error(localize22(\"UnexpectedEndOfNumber\", \"Unexpected end of number.\"), ErrorCode.UnexpectedEndOfNumber);\n        return true;\n      case 1:\n        _error(localize22(\"UnexpectedEndOfComment\", \"Unexpected end of comment.\"), ErrorCode.UnexpectedEndOfComment);\n        return true;\n      case 2:\n        _error(localize22(\"UnexpectedEndOfString\", \"Unexpected end of string.\"), ErrorCode.UnexpectedEndOfString);\n        return true;\n      case 6:\n        _error(localize22(\"InvalidCharacter\", \"Invalid characters in string. Control characters must be escaped.\"), ErrorCode.InvalidCharacter);\n        return true;\n    }\n    return false;\n  }\n  function _finalize(node, scanNext) {\n    node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;\n    if (scanNext) {\n      _scanNext();\n    }\n    return node;\n  }\n  function _parseArray(parent) {\n    if (scanner.getToken() !== 3) {\n      return void 0;\n    }\n    var node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());\n    _scanNext();\n    var count = 0;\n    var needsComma = false;\n    while (scanner.getToken() !== 4 \u0026\u0026 scanner.getToken() !== 17) {\n      if (scanner.getToken() === 5) {\n        if (!needsComma) {\n          _error(localize22(\"ValueExpected\", \"Value expected\"), ErrorCode.ValueExpected);\n        }\n        var commaOffset = scanner.getTokenOffset();\n        _scanNext();\n        if (scanner.getToken() === 4) {\n          if (needsComma) {\n            _errorAtRange(localize22(\"TrailingComma\", \"Trailing comma\"), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\n          }\n          continue;\n        }\n      } else if (needsComma) {\n        _error(localize22(\"ExpectedComma\", \"Expected comma\"), ErrorCode.CommaExpected);\n      }\n      var item = _parseValue(node);\n      if (!item) {\n        _error(localize22(\"PropertyExpected\", \"Value expected\"), ErrorCode.ValueExpected, void 0, [], [4, 5]);\n      } else {\n        node.items.push(item);\n      }\n      needsComma = true;\n    }\n    if (scanner.getToken() !== 4) {\n      return _error(localize22(\"ExpectedCloseBracket\", \"Expected comma or closing bracket\"), ErrorCode.CommaOrCloseBacketExpected, node);\n    }\n    return _finalize(node, true);\n  }\n  var keyPlaceholder = new StringASTNodeImpl(void 0, 0, 0);\n  function _parseProperty(parent, keysSeen) {\n    var node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset(), keyPlaceholder);\n    var key = _parseString(node);\n    if (!key) {\n      if (scanner.getToken() === 16) {\n        _error(localize22(\"DoubleQuotesExpected\", \"Property keys must be doublequoted\"), ErrorCode.Undefined);\n        var keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());\n        keyNode.value = scanner.getTokenValue();\n        key = keyNode;\n        _scanNext();\n      } else {\n        return void 0;\n      }\n    }\n    node.keyNode = key;\n    var seen = keysSeen[key.value];\n    if (seen) {\n      _errorAtRange(localize22(\"DuplicateKeyWarning\", \"Duplicate object key\"), ErrorCode.DuplicateKey, node.keyNode.offset, node.keyNode.offset + node.keyNode.length, DiagnosticSeverity.Warning);\n      if (typeof seen === \"object\") {\n        _errorAtRange(localize22(\"DuplicateKeyWarning\", \"Duplicate object key\"), ErrorCode.DuplicateKey, seen.keyNode.offset, seen.keyNode.offset + seen.keyNode.length, DiagnosticSeverity.Warning);\n      }\n      keysSeen[key.value] = true;\n    } else {\n      keysSeen[key.value] = node;\n    }\n    if (scanner.getToken() === 6) {\n      node.colonOffset = scanner.getTokenOffset();\n      _scanNext();\n    } else {\n      _error(localize22(\"ColonExpected\", \"Colon expected\"), ErrorCode.ColonExpected);\n      if (scanner.getToken() === 10 \u0026\u0026 textDocument.positionAt(key.offset + key.length).line \u003c textDocument.positionAt(scanner.getTokenOffset()).line) {\n        node.length = key.length;\n        return node;\n      }\n    }\n    var value = _parseValue(node);\n    if (!value) {\n      return _error(localize22(\"ValueExpected\", \"Value expected\"), ErrorCode.ValueExpected, node, [], [2, 5]);\n    }\n    node.valueNode = value;\n    node.length = value.offset + value.length - node.offset;\n    return node;\n  }\n  function _parseObject(parent) {\n    if (scanner.getToken() !== 1) {\n      return void 0;\n    }\n    var node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());\n    var keysSeen = /* @__PURE__ */ Object.create(null);\n    _scanNext();\n    var needsComma = false;\n    while (scanner.getToken() !== 2 \u0026\u0026 scanner.getToken() !== 17) {\n      if (scanner.getToken() === 5) {\n        if (!needsComma) {\n          _error(localize22(\"PropertyExpected\", \"Property expected\"), ErrorCode.PropertyExpected);\n        }\n        var commaOffset = scanner.getTokenOffset();\n        _scanNext();\n        if (scanner.getToken() === 2) {\n          if (needsComma) {\n            _errorAtRange(localize22(\"TrailingComma\", \"Trailing comma\"), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\n          }\n          continue;\n        }\n      } else if (needsComma) {\n        _error(localize22(\"ExpectedComma\", \"Expected comma\"), ErrorCode.CommaExpected);\n      }\n      var property2 = _parseProperty(node, keysSeen);\n      if (!property2) {\n        _error(localize22(\"PropertyExpected\", \"Property expected\"), ErrorCode.PropertyExpected, void 0, [], [2, 5]);\n      } else {\n        node.properties.push(property2);\n      }\n      needsComma = true;\n    }\n    if (scanner.getToken() !== 2) {\n      return _error(localize22(\"ExpectedCloseBrace\", \"Expected comma or closing brace\"), ErrorCode.CommaOrCloseBraceExpected, node);\n    }\n    return _finalize(node, true);\n  }\n  function _parseString(parent) {\n    if (scanner.getToken() !== 10) {\n      return void 0;\n    }\n    var node = new StringASTNodeImpl(parent, scanner.getTokenOffset());\n    node.value = scanner.getTokenValue();\n    return _finalize(node, true);\n  }\n  function _parseNumber(parent) {\n    if (scanner.getToken() !== 11) {\n      return void 0;\n    }\n    var node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());\n    if (scanner.getTokenError() === 0) {\n      var tokenValue = scanner.getTokenValue();\n      try {\n        var numberValue = JSON.parse(tokenValue);\n        if (!isNumber(numberValue)) {\n          return _error(localize22(\"InvalidNumberFormat\", \"Invalid number format.\"), ErrorCode.Undefined, node);\n        }\n        node.value = numberValue;\n      } catch (e) {\n        return _error(localize22(\"InvalidNumberFormat\", \"Invalid number format.\"), ErrorCode.Undefined, node);\n      }\n      node.isInteger = tokenValue.indexOf(\".\") === -1;\n    }\n    return _finalize(node, true);\n  }\n  function _parseLiteral(parent) {\n    var node;\n    switch (scanner.getToken()) {\n      case 7:\n        return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);\n      case 8:\n        return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);\n      case 9:\n        return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);\n      default:\n        return void 0;\n    }\n  }\n  function _parseValue(parent) {\n    return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);\n  }\n  var _root = void 0;\n  var token = _scanNext();\n  if (token !== 17) {\n    _root = _parseValue(_root);\n    if (!_root) {\n      _error(localize22(\"Invalid symbol\", \"Expected a JSON object, array or literal.\"), ErrorCode.Undefined);\n    } else if (scanner.getToken() !== 17) {\n      _error(localize22(\"End of file expected\", \"End of file expected.\"), ErrorCode.Undefined);\n    }\n  }\n  return new JSONDocument(_root, problems, commentRanges);\n}\nfunction stringifyObject(obj, indent, stringifyLiteral) {\n  if (obj !== null \u0026\u0026 typeof obj === \"object\") {\n    var newIndent = indent + \"\t\";\n    if (Array.isArray(obj)) {\n      if (obj.length === 0) {\n        return \"[]\";\n      }\n      var result = \"[\\n\";\n      for (var i = 0; i \u003c obj.length; i++) {\n        result += newIndent + stringifyObject(obj[i], newIndent, stringifyLiteral);\n        if (i \u003c obj.length - 1) {\n          result += \",\";\n        }\n        result += \"\\n\";\n      }\n      result += indent + \"]\";\n      return result;\n    } else {\n      var keys = Object.keys(obj);\n      if (keys.length === 0) {\n        return \"{}\";\n      }\n      var result = \"{\\n\";\n      for (var i = 0; i \u003c keys.length; i++) {\n        var key = keys[i];\n        result += newIndent + JSON.stringify(key) + \": \" + stringifyObject(obj[key], newIndent, stringifyLiteral);\n        if (i \u003c keys.length - 1) {\n          result += \",\";\n        }\n        result += \"\\n\";\n      }\n      result += indent + \"}\";\n      return result;\n    }\n  }\n  return stringifyLiteral(obj);\n}\nvar localize3 = loadMessageBundle();\nvar valueCommitCharacters = [\",\", \"}\", \"]\"];\nvar propertyCommitCharacters = [\":\"];\nvar JSONCompletion = function() {\n  function JSONCompletion2(schemaService, contributions, promiseConstructor, clientCapabilities) {\n    if (contributions === void 0) {\n      contributions = [];\n    }\n    if (promiseConstructor === void 0) {\n      promiseConstructor = Promise;\n    }\n    if (clientCapabilities === void 0) {\n      clientCapabilities = {};\n    }\n    this.schemaService = schemaService;\n    this.contributions = contributions;\n    this.promiseConstructor = promiseConstructor;\n    this.clientCapabilities = clientCapabilities;\n  }\n  JSONCompletion2.prototype.doResolve = function(item) {\n    for (var i = this.contributions.length - 1; i \u003e= 0; i--) {\n      var resolveCompletion = this.contributions[i].resolveCompletion;\n      if (resolveCompletion) {\n        var resolver = resolveCompletion(item);\n        if (resolver) {\n          return resolver;\n        }\n      }\n    }\n    return this.promiseConstructor.resolve(item);\n  };\n  JSONCompletion2.prototype.doComplete = function(document2, position, doc) {\n    var _this = this;\n    var result = {\n      items: [],\n      isIncomplete: false\n    };\n    var text = document2.getText();\n    var offset = document2.offsetAt(position);\n    var node = doc.getNodeFromOffset(offset, true);\n    if (this.isInComment(document2, node ? node.offset : 0, offset)) {\n      return Promise.resolve(result);\n    }\n    if (node \u0026\u0026 offset === node.offset + node.length \u0026\u0026 offset \u003e 0) {\n      var ch = text[offset - 1];\n      if (node.type === \"object\" \u0026\u0026 ch === \"}\" || node.type === \"array\" \u0026\u0026 ch === \"]\") {\n        node = node.parent;\n      }\n    }\n    var currentWord = this.getCurrentWord(document2, offset);\n    var overwriteRange;\n    if (node \u0026\u0026 (node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\" || node.type === \"null\")) {\n      overwriteRange = Range2.create(document2.positionAt(node.offset), document2.positionAt(node.offset + node.length));\n    } else {\n      var overwriteStart = offset - currentWord.length;\n      if (overwriteStart \u003e 0 \u0026\u0026 text[overwriteStart - 1] === '\"') {\n        overwriteStart--;\n      }\n      overwriteRange = Range2.create(document2.positionAt(overwriteStart), position);\n    }\n    var supportsCommitCharacters = false;\n    var proposed = {};\n    var collector = {\n      add: function(suggestion) {\n        var label = suggestion.label;\n        var existing = proposed[label];\n        if (!existing) {\n          label = label.replace(/[\\n]/g, \"\\u21B5\");\n          if (label.length \u003e 60) {\n            var shortendedLabel = label.substr(0, 57).trim() + \"...\";\n            if (!proposed[shortendedLabel]) {\n              label = shortendedLabel;\n            }\n          }\n          if (overwriteRange \u0026\u0026 suggestion.insertText !== void 0) {\n            suggestion.textEdit = TextEdit.replace(overwriteRange, suggestion.insertText);\n          }\n          if (supportsCommitCharacters) {\n            suggestion.commitCharacters = suggestion.kind === CompletionItemKind2.Property ? propertyCommitCharacters : valueCommitCharacters;\n          }\n          suggestion.label = label;\n          proposed[label] = suggestion;\n          result.items.push(suggestion);\n        } else {\n          if (!existing.documentation) {\n            existing.documentation = suggestion.documentation;\n          }\n          if (!existing.detail) {\n            existing.detail = suggestion.detail;\n          }\n        }\n      },\n      setAsIncomplete: function() {\n        result.isIncomplete = true;\n      },\n      error: function(message) {\n        console.error(message);\n      },\n      log: function(message) {\n        console.log(message);\n      },\n      getNumberOfProposals: function() {\n        return result.items.length;\n      }\n    };\n    return this.schemaService.getSchemaForResource(document2.uri, doc).then(function(schema2) {\n      var collectionPromises = [];\n      var addValue = true;\n      var currentKey = \"\";\n      var currentProperty = void 0;\n      if (node) {\n        if (node.type === \"string\") {\n          var parent = node.parent;\n          if (parent \u0026\u0026 parent.type === \"property\" \u0026\u0026 parent.keyNode === node) {\n            addValue = !parent.valueNode;\n            currentProperty = parent;\n            currentKey = text.substr(node.offset + 1, node.length - 2);\n            if (parent) {\n              node = parent.parent;\n            }\n          }\n        }\n      }\n      if (node \u0026\u0026 node.type === \"object\") {\n        if (node.offset === offset) {\n          return result;\n        }\n        var properties = node.properties;\n        properties.forEach(function(p) {\n          if (!currentProperty || currentProperty !== p) {\n            proposed[p.keyNode.value] = CompletionItem.create(\"__\");\n          }\n        });\n        var separatorAfter_1 = \"\";\n        if (addValue) {\n          separatorAfter_1 = _this.evaluateSeparatorAfter(document2, document2.offsetAt(overwriteRange.end));\n        }\n        if (schema2) {\n          _this.getPropertyCompletions(schema2, doc, node, addValue, separatorAfter_1, collector);\n        } else {\n          _this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);\n        }\n        var location_1 = getNodePath3(node);\n        _this.contributions.forEach(function(contribution) {\n          var collectPromise = contribution.collectPropertyCompletions(document2.uri, location_1, currentWord, addValue, separatorAfter_1 === \"\", collector);\n          if (collectPromise) {\n            collectionPromises.push(collectPromise);\n          }\n        });\n        if (!schema2 \u0026\u0026 currentWord.length \u003e 0 \u0026\u0026 text.charAt(offset - currentWord.length - 1) !== '\"') {\n          collector.add({\n            kind: CompletionItemKind2.Property,\n            label: _this.getLabelForValue(currentWord),\n            insertText: _this.getInsertTextForProperty(currentWord, void 0, false, separatorAfter_1),\n            insertTextFormat: InsertTextFormat.Snippet,\n            documentation: \"\"\n          });\n          collector.setAsIncomplete();\n        }\n      }\n      var types = {};\n      if (schema2) {\n        _this.getValueCompletions(schema2, doc, node, offset, document2, collector, types);\n      } else {\n        _this.getSchemaLessValueCompletions(doc, node, offset, document2, collector);\n      }\n      if (_this.contributions.length \u003e 0) {\n        _this.getContributedValueCompletions(doc, node, offset, document2, collector, collectionPromises);\n      }\n      return _this.promiseConstructor.all(collectionPromises).then(function() {\n        if (collector.getNumberOfProposals() === 0) {\n          var offsetForSeparator = offset;\n          if (node \u0026\u0026 (node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\" || node.type === \"null\")) {\n            offsetForSeparator = node.offset + node.length;\n          }\n          var separatorAfter = _this.evaluateSeparatorAfter(document2, offsetForSeparator);\n          _this.addFillerValueCompletions(types, separatorAfter, collector);\n        }\n        return result;\n      });\n    });\n  };\n  JSONCompletion2.prototype.getPropertyCompletions = function(schema2, doc, node, addValue, separatorAfter, collector) {\n    var _this = this;\n    var matchingSchemas = doc.getMatchingSchemas(schema2.schema, node.offset);\n    matchingSchemas.forEach(function(s) {\n      if (s.node === node \u0026\u0026 !s.inverted) {\n        var schemaProperties_1 = s.schema.properties;\n        if (schemaProperties_1) {\n          Object.keys(schemaProperties_1).forEach(function(key) {\n            var propertySchema = schemaProperties_1[key];\n            if (typeof propertySchema === \"object\" \u0026\u0026 !propertySchema.deprecationMessage \u0026\u0026 !propertySchema.doNotSuggest) {\n              var proposal = {\n                kind: CompletionItemKind2.Property,\n                label: key,\n                insertText: _this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                filterText: _this.getFilterTextForValue(key),\n                documentation: _this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || \"\"\n              };\n              if (propertySchema.suggestSortText !== void 0) {\n                proposal.sortText = propertySchema.suggestSortText;\n              }\n              if (proposal.insertText \u0026\u0026 endsWith(proposal.insertText, \"$1\".concat(separatorAfter))) {\n                proposal.command = {\n                  title: \"Suggest\",\n                  command: \"editor.action.triggerSuggest\"\n                };\n              }\n              collector.add(proposal);\n            }\n          });\n        }\n        var schemaPropertyNames_1 = s.schema.propertyNames;\n        if (typeof schemaPropertyNames_1 === \"object\" \u0026\u0026 !schemaPropertyNames_1.deprecationMessage \u0026\u0026 !schemaPropertyNames_1.doNotSuggest) {\n          var propertyNameCompletionItem = function(name, enumDescription2) {\n            if (enumDescription2 === void 0) {\n              enumDescription2 = void 0;\n            }\n            var proposal = {\n              kind: CompletionItemKind2.Property,\n              label: name,\n              insertText: _this.getInsertTextForProperty(name, void 0, addValue, separatorAfter),\n              insertTextFormat: InsertTextFormat.Snippet,\n              filterText: _this.getFilterTextForValue(name),\n              documentation: enumDescription2 || _this.fromMarkup(schemaPropertyNames_1.markdownDescription) || schemaPropertyNames_1.description || \"\"\n            };\n            if (schemaPropertyNames_1.suggestSortText !== void 0) {\n              proposal.sortText = schemaPropertyNames_1.suggestSortText;\n            }\n            if (proposal.insertText \u0026\u0026 endsWith(proposal.insertText, \"$1\".concat(separatorAfter))) {\n              proposal.command = {\n                title: \"Suggest\",\n                command: \"editor.action.triggerSuggest\"\n              };\n            }\n            collector.add(proposal);\n          };\n          if (schemaPropertyNames_1.enum) {\n            for (var i = 0; i \u003c schemaPropertyNames_1.enum.length; i++) {\n              var enumDescription = void 0;\n              if (schemaPropertyNames_1.markdownEnumDescriptions \u0026\u0026 i \u003c schemaPropertyNames_1.markdownEnumDescriptions.length) {\n                enumDescription = _this.fromMarkup(schemaPropertyNames_1.markdownEnumDescriptions[i]);\n              } else if (schemaPropertyNames_1.enumDescriptions \u0026\u0026 i \u003c schemaPropertyNames_1.enumDescriptions.length) {\n                enumDescription = schemaPropertyNames_1.enumDescriptions[i];\n              }\n              propertyNameCompletionItem(schemaPropertyNames_1.enum[i], enumDescription);\n            }\n          }\n          if (schemaPropertyNames_1.const) {\n            propertyNameCompletionItem(schemaPropertyNames_1.const);\n          }\n        }\n      }\n    });\n  };\n  JSONCompletion2.prototype.getSchemaLessPropertyCompletions = function(doc, node, currentKey, collector) {\n    var _this = this;\n    var collectCompletionsForSimilarObject = function(obj) {\n      obj.properties.forEach(function(p) {\n        var key = p.keyNode.value;\n        collector.add({\n          kind: CompletionItemKind2.Property,\n          label: key,\n          insertText: _this.getInsertTextForValue(key, \"\"),\n          insertTextFormat: InsertTextFormat.Snippet,\n          filterText: _this.getFilterTextForValue(key),\n          documentation: \"\"\n        });\n      });\n    };\n    if (node.parent) {\n      if (node.parent.type === \"property\") {\n        var parentKey_1 = node.parent.keyNode.value;\n        doc.visit(function(n) {\n          if (n.type === \"property\" \u0026\u0026 n !== node.parent \u0026\u0026 n.keyNode.value === parentKey_1 \u0026\u0026 n.valueNode \u0026\u0026 n.valueNode.type === \"object\") {\n            collectCompletionsForSimilarObject(n.valueNode);\n          }\n          return true;\n        });\n      } else if (node.parent.type === \"array\") {\n        node.parent.items.forEach(function(n) {\n          if (n.type === \"object\" \u0026\u0026 n !== node) {\n            collectCompletionsForSimilarObject(n);\n          }\n        });\n      }\n    } else if (node.type === \"object\") {\n      collector.add({\n        kind: CompletionItemKind2.Property,\n        label: \"$schema\",\n        insertText: this.getInsertTextForProperty(\"$schema\", void 0, true, \"\"),\n        insertTextFormat: InsertTextFormat.Snippet,\n        documentation: \"\",\n        filterText: this.getFilterTextForValue(\"$schema\")\n      });\n    }\n  };\n  JSONCompletion2.prototype.getSchemaLessValueCompletions = function(doc, node, offset, document2, collector) {\n    var _this = this;\n    var offsetForSeparator = offset;\n    if (node \u0026\u0026 (node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\" || node.type === \"null\")) {\n      offsetForSeparator = node.offset + node.length;\n      node = node.parent;\n    }\n    if (!node) {\n      collector.add({\n        kind: this.getSuggestionKind(\"object\"),\n        label: \"Empty object\",\n        insertText: this.getInsertTextForValue({}, \"\"),\n        insertTextFormat: InsertTextFormat.Snippet,\n        documentation: \"\"\n      });\n      collector.add({\n        kind: this.getSuggestionKind(\"array\"),\n        label: \"Empty array\",\n        insertText: this.getInsertTextForValue([], \"\"),\n        insertTextFormat: InsertTextFormat.Snippet,\n        documentation: \"\"\n      });\n      return;\n    }\n    var separatorAfter = this.evaluateSeparatorAfter(document2, offsetForSeparator);\n    var collectSuggestionsForValues = function(value) {\n      if (value.parent \u0026\u0026 !contains2(value.parent, offset, true)) {\n        collector.add({\n          kind: _this.getSuggestionKind(value.type),\n          label: _this.getLabelTextForMatchingNode(value, document2),\n          insertText: _this.getInsertTextForMatchingNode(value, document2, separatorAfter),\n          insertTextFormat: InsertTextFormat.Snippet,\n          documentation: \"\"\n        });\n      }\n      if (value.type === \"boolean\") {\n        _this.addBooleanValueCompletion(!value.value, separatorAfter, collector);\n      }\n    };\n    if (node.type === \"property\") {\n      if (offset \u003e (node.colonOffset || 0)) {\n        var valueNode = node.valueNode;\n        if (valueNode \u0026\u0026 (offset \u003e valueNode.offset + valueNode.length || valueNode.type === \"object\" || valueNode.type === \"array\")) {\n          return;\n        }\n        var parentKey_2 = node.keyNode.value;\n        doc.visit(function(n) {\n          if (n.type === \"property\" \u0026\u0026 n.keyNode.value === parentKey_2 \u0026\u0026 n.valueNode) {\n            collectSuggestionsForValues(n.valueNode);\n          }\n          return true;\n        });\n        if (parentKey_2 === \"$schema\" \u0026\u0026 node.parent \u0026\u0026 !node.parent.parent) {\n          this.addDollarSchemaCompletions(separatorAfter, collector);\n        }\n      }\n    }\n    if (node.type === \"array\") {\n      if (node.parent \u0026\u0026 node.parent.type === \"property\") {\n        var parentKey_3 = node.parent.keyNode.value;\n        doc.visit(function(n) {\n          if (n.type === \"property\" \u0026\u0026 n.keyNode.value === parentKey_3 \u0026\u0026 n.valueNode \u0026\u0026 n.valueNode.type === \"array\") {\n            n.valueNode.items.forEach(collectSuggestionsForValues);\n          }\n          return true;\n        });\n      } else {\n        node.items.forEach(collectSuggestionsForValues);\n      }\n    }\n  };\n  JSONCompletion2.prototype.getValueCompletions = function(schema2, doc, node, offset, document2, collector, types) {\n    var offsetForSeparator = offset;\n    var parentKey = void 0;\n    var valueNode = void 0;\n    if (node \u0026\u0026 (node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\" || node.type === \"null\")) {\n      offsetForSeparator = node.offset + node.length;\n      valueNode = node;\n      node = node.parent;\n    }\n    if (!node) {\n      this.addSchemaValueCompletions(schema2.schema, \"\", collector, types);\n      return;\n    }\n    if (node.type === \"property\" \u0026\u0026 offset \u003e (node.colonOffset || 0)) {\n      var valueNode_1 = node.valueNode;\n      if (valueNode_1 \u0026\u0026 offset \u003e valueNode_1.offset + valueNode_1.length) {\n        return;\n      }\n      parentKey = node.keyNode.value;\n      node = node.parent;\n    }\n    if (node \u0026\u0026 (parentKey !== void 0 || node.type === \"array\")) {\n      var separatorAfter = this.evaluateSeparatorAfter(document2, offsetForSeparator);\n      var matchingSchemas = doc.getMatchingSchemas(schema2.schema, node.offset, valueNode);\n      for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i \u003c matchingSchemas_1.length; _i++) {\n        var s = matchingSchemas_1[_i];\n        if (s.node === node \u0026\u0026 !s.inverted \u0026\u0026 s.schema) {\n          if (node.type === \"array\" \u0026\u0026 s.schema.items) {\n            if (Array.isArray(s.schema.items)) {\n              var index = this.findItemAtOffset(node, document2, offset);\n              if (index \u003c s.schema.items.length) {\n                this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, collector, types);\n              }\n            } else {\n              this.addSchemaValueCompletions(s.schema.items, separatorAfter, collector, types);\n            }\n          }\n          if (parentKey !== void 0) {\n            var propertyMatched = false;\n            if (s.schema.properties) {\n              var propertySchema = s.schema.properties[parentKey];\n              if (propertySchema) {\n                propertyMatched = true;\n                this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n              }\n            }\n            if (s.schema.patternProperties \u0026\u0026 !propertyMatched) {\n              for (var _a4 = 0, _b2 = Object.keys(s.schema.patternProperties); _a4 \u003c _b2.length; _a4++) {\n                var pattern = _b2[_a4];\n                var regex = extendedRegExp(pattern);\n                if (regex === null || regex === void 0 ? void 0 : regex.test(parentKey)) {\n                  propertyMatched = true;\n                  var propertySchema = s.schema.patternProperties[pattern];\n                  this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n                }\n              }\n            }\n            if (s.schema.additionalProperties \u0026\u0026 !propertyMatched) {\n              var propertySchema = s.schema.additionalProperties;\n              this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n            }\n          }\n        }\n      }\n      if (parentKey === \"$schema\" \u0026\u0026 !node.parent) {\n        this.addDollarSchemaCompletions(separatorAfter, collector);\n      }\n      if (types[\"boolean\"]) {\n        this.addBooleanValueCompletion(true, separatorAfter, collector);\n        this.addBooleanValueCompletion(false, separatorAfter, collector);\n      }\n      if (types[\"null\"]) {\n        this.addNullValueCompletion(separatorAfter, collector);\n      }\n    }\n  };\n  JSONCompletion2.prototype.getContributedValueCompletions = function(doc, node, offset, document2, collector, collectionPromises) {\n    if (!node) {\n      this.contributions.forEach(function(contribution) {\n        var collectPromise = contribution.collectDefaultCompletions(document2.uri, collector);\n        if (collectPromise) {\n          collectionPromises.push(collectPromise);\n        }\n      });\n    } else {\n      if (node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\" || node.type === \"null\") {\n        node = node.parent;\n      }\n      if (node \u0026\u0026 node.type === \"property\" \u0026\u0026 offset \u003e (node.colonOffset || 0)) {\n        var parentKey_4 = node.keyNode.value;\n        var valueNode = node.valueNode;\n        if ((!valueNode || offset \u003c= valueNode.offset + valueNode.length) \u0026\u0026 node.parent) {\n          var location_2 = getNodePath3(node.parent);\n          this.contributions.forEach(function(contribution) {\n            var collectPromise = contribution.collectValueCompletions(document2.uri, location_2, parentKey_4, collector);\n            if (collectPromise) {\n              collectionPromises.push(collectPromise);\n            }\n          });\n        }\n      }\n    }\n  };\n  JSONCompletion2.prototype.addSchemaValueCompletions = function(schema2, separatorAfter, collector, types) {\n    var _this = this;\n    if (typeof schema2 === \"object\") {\n      this.addEnumValueCompletions(schema2, separatorAfter, collector);\n      this.addDefaultValueCompletions(schema2, separatorAfter, collector);\n      this.collectTypes(schema2, types);\n      if (Array.isArray(schema2.allOf)) {\n        schema2.allOf.forEach(function(s) {\n          return _this.addSchemaValueCompletions(s, separatorAfter, collector, types);\n        });\n      }\n      if (Array.isArray(schema2.anyOf)) {\n        schema2.anyOf.forEach(function(s) {\n          return _this.addSchemaValueCompletions(s, separatorAfter, collector, types);\n        });\n      }\n      if (Array.isArray(schema2.oneOf)) {\n        schema2.oneOf.forEach(function(s) {\n          return _this.addSchemaValueCompletions(s, separatorAfter, collector, types);\n        });\n      }\n    }\n  };\n  JSONCompletion2.prototype.addDefaultValueCompletions = function(schema2, separatorAfter, collector, arrayDepth) {\n    var _this = this;\n    if (arrayDepth === void 0) {\n      arrayDepth = 0;\n    }\n    var hasProposals = false;\n    if (isDefined(schema2.default)) {\n      var type = schema2.type;\n      var value = schema2.default;\n      for (var i = arrayDepth; i \u003e 0; i--) {\n        value = [value];\n        type = \"array\";\n      }\n      collector.add({\n        kind: this.getSuggestionKind(type),\n        label: this.getLabelForValue(value),\n        insertText: this.getInsertTextForValue(value, separatorAfter),\n        insertTextFormat: InsertTextFormat.Snippet,\n        detail: localize3(\"json.suggest.default\", \"Default value\")\n      });\n      hasProposals = true;\n    }\n    if (Array.isArray(schema2.examples)) {\n      schema2.examples.forEach(function(example) {\n        var type2 = schema2.type;\n        var value2 = example;\n        for (var i2 = arrayDepth; i2 \u003e 0; i2--) {\n          value2 = [value2];\n          type2 = \"array\";\n        }\n        collector.add({\n          kind: _this.getSuggestionKind(type2),\n          label: _this.getLabelForValue(value2),\n          insertText: _this.getInsertTextForValue(value2, separatorAfter),\n          insertTextFormat: InsertTextFormat.Snippet\n        });\n        hasProposals = true;\n      });\n    }\n    if (Array.isArray(schema2.defaultSnippets)) {\n      schema2.defaultSnippets.forEach(function(s) {\n        var type2 = schema2.type;\n        var value2 = s.body;\n        var label = s.label;\n        var insertText;\n        var filterText;\n        if (isDefined(value2)) {\n          var type_1 = schema2.type;\n          for (var i2 = arrayDepth; i2 \u003e 0; i2--) {\n            value2 = [value2];\n            type_1 = \"array\";\n          }\n          insertText = _this.getInsertTextForSnippetValue(value2, separatorAfter);\n          filterText = _this.getFilterTextForSnippetValue(value2);\n          label = label || _this.getLabelForSnippetValue(value2);\n        } else if (typeof s.bodyText === \"string\") {\n          var prefix = \"\", suffix = \"\", indent = \"\";\n          for (var i2 = arrayDepth; i2 \u003e 0; i2--) {\n            prefix = prefix + indent + \"[\\n\";\n            suffix = suffix + \"\\n\" + indent + \"]\";\n            indent += \"\t\";\n            type2 = \"array\";\n          }\n          insertText = prefix + indent + s.bodyText.split(\"\\n\").join(\"\\n\" + indent) + suffix + separatorAfter;\n          label = label || insertText, filterText = insertText.replace(/[\\n]/g, \"\");\n        } else {\n          return;\n        }\n        collector.add({\n          kind: _this.getSuggestionKind(type2),\n          label,\n          documentation: _this.fromMarkup(s.markdownDescription) || s.description,\n          insertText,\n          insertTextFormat: InsertTextFormat.Snippet,\n          filterText\n        });\n        hasProposals = true;\n      });\n    }\n    if (!hasProposals \u0026\u0026 typeof schema2.items === \"object\" \u0026\u0026 !Array.isArray(schema2.items) \u0026\u0026 arrayDepth \u003c 5) {\n      this.addDefaultValueCompletions(schema2.items, separatorAfter, collector, arrayDepth + 1);\n    }\n  };\n  JSONCompletion2.prototype.addEnumValueCompletions = function(schema2, separatorAfter, collector) {\n    if (isDefined(schema2.const)) {\n      collector.add({\n        kind: this.getSuggestionKind(schema2.type),\n        label: this.getLabelForValue(schema2.const),\n        insertText: this.getInsertTextForValue(schema2.const, separatorAfter),\n        insertTextFormat: InsertTextFormat.Snippet,\n        documentation: this.fromMarkup(schema2.markdownDescription) || schema2.description\n      });\n    }\n    if (Array.isArray(schema2.enum)) {\n      for (var i = 0, length = schema2.enum.length; i \u003c length; i++) {\n        var enm = schema2.enum[i];\n        var documentation = this.fromMarkup(schema2.markdownDescription) || schema2.description;\n        if (schema2.markdownEnumDescriptions \u0026\u0026 i \u003c schema2.markdownEnumDescriptions.length \u0026\u0026 this.doesSupportMarkdown()) {\n          documentation = this.fromMarkup(schema2.markdownEnumDescriptions[i]);\n        } else if (schema2.enumDescriptions \u0026\u0026 i \u003c schema2.enumDescriptions.length) {\n          documentation = schema2.enumDescriptions[i];\n        }\n        collector.add({\n          kind: this.getSuggestionKind(schema2.type),\n          label: this.getLabelForValue(enm),\n          insertText: this.getInsertTextForValue(enm, separatorAfter),\n          insertTextFormat: InsertTextFormat.Snippet,\n          documentation\n        });\n      }\n    }\n  };\n  JSONCompletion2.prototype.collectTypes = function(schema2, types) {\n    if (Array.isArray(schema2.enum) || isDefined(schema2.const)) {\n      return;\n    }\n    var type = schema2.type;\n    if (Array.isArray(type)) {\n      type.forEach(function(t) {\n        return types[t] = true;\n      });\n    } else if (type) {\n      types[type] = true;\n    }\n  };\n  JSONCompletion2.prototype.addFillerValueCompletions = function(types, separatorAfter, collector) {\n    if (types[\"object\"]) {\n      collector.add({\n        kind: this.getSuggestionKind(\"object\"),\n        label: \"{}\",\n        insertText: this.getInsertTextForGuessedValue({}, separatorAfter),\n        insertTextFormat: InsertTextFormat.Snippet,\n        detail: localize3(\"defaults.object\", \"New object\"),\n        documentation: \"\"\n      });\n    }\n    if (types[\"array\"]) {\n      collector.add({\n        kind: this.getSuggestionKind(\"array\"),\n        label: \"[]\",\n        insertText: this.getInsertTextForGuessedValue([], separatorAfter),\n        insertTextFormat: InsertTextFormat.Snippet,\n        detail: localize3(\"defaults.array\", \"New array\"),\n        documentation: \"\"\n      });\n    }\n  };\n  JSONCompletion2.prototype.addBooleanValueCompletion = function(value, separatorAfter, collector) {\n    collector.add({\n      kind: this.getSuggestionKind(\"boolean\"),\n      label: value ? \"true\" : \"false\",\n      insertText: this.getInsertTextForValue(value, separatorAfter),\n      insertTextFormat: InsertTextFormat.Snippet,\n      documentation: \"\"\n    });\n  };\n  JSONCompletion2.prototype.addNullValueCompletion = function(separatorAfter, collector) {\n    collector.add({\n      kind: this.getSuggestionKind(\"null\"),\n      label: \"null\",\n      insertText: \"null\" + separatorAfter,\n      insertTextFormat: InsertTextFormat.Snippet,\n      documentation: \"\"\n    });\n  };\n  JSONCompletion2.prototype.addDollarSchemaCompletions = function(separatorAfter, collector) {\n    var _this = this;\n    var schemaIds = this.schemaService.getRegisteredSchemaIds(function(schema2) {\n      return schema2 === \"http\" || schema2 === \"https\";\n    });\n    schemaIds.forEach(function(schemaId) {\n      return collector.add({\n        kind: CompletionItemKind2.Module,\n        label: _this.getLabelForValue(schemaId),\n        filterText: _this.getFilterTextForValue(schemaId),\n        insertText: _this.getInsertTextForValue(schemaId, separatorAfter),\n        insertTextFormat: InsertTextFormat.Snippet,\n        documentation: \"\"\n      });\n    });\n  };\n  JSONCompletion2.prototype.getLabelForValue = function(value) {\n    return JSON.stringify(value);\n  };\n  JSONCompletion2.prototype.getFilterTextForValue = function(value) {\n    return JSON.stringify(value);\n  };\n  JSONCompletion2.prototype.getFilterTextForSnippetValue = function(value) {\n    return JSON.stringify(value).replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, \"$1\");\n  };\n  JSONCompletion2.prototype.getLabelForSnippetValue = function(value) {\n    var label = JSON.stringify(value);\n    return label.replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, \"$1\");\n  };\n  JSONCompletion2.prototype.getInsertTextForPlainText = function(text) {\n    return text.replace(/[\\\\\\$\\}]/g, \"\\\\$\u0026\");\n  };\n  JSONCompletion2.prototype.getInsertTextForValue = function(value, separatorAfter) {\n    var text = JSON.stringify(value, null, \"\t\");\n    if (text === \"{}\") {\n      return \"{$1}\" + separatorAfter;\n    } else if (text === \"[]\") {\n      return \"[$1]\" + separatorAfter;\n    }\n    return this.getInsertTextForPlainText(text + separatorAfter);\n  };\n  JSONCompletion2.prototype.getInsertTextForSnippetValue = function(value, separatorAfter) {\n    var replacer = function(value2) {\n      if (typeof value2 === \"string\") {\n        if (value2[0] === \"^\") {\n          return value2.substr(1);\n        }\n      }\n      return JSON.stringify(value2);\n    };\n    return stringifyObject(value, \"\", replacer) + separatorAfter;\n  };\n  JSONCompletion2.prototype.getInsertTextForGuessedValue = function(value, separatorAfter) {\n    switch (typeof value) {\n      case \"object\":\n        if (value === null) {\n          return \"${1:null}\" + separatorAfter;\n        }\n        return this.getInsertTextForValue(value, separatorAfter);\n      case \"string\":\n        var snippetValue = JSON.stringify(value);\n        snippetValue = snippetValue.substr(1, snippetValue.length - 2);\n        snippetValue = this.getInsertTextForPlainText(snippetValue);\n        return '\"${1:' + snippetValue + '}\"' + separatorAfter;\n      case \"number\":\n      case \"boolean\":\n        return \"${1:\" + JSON.stringify(value) + \"}\" + separatorAfter;\n    }\n    return this.getInsertTextForValue(value, separatorAfter);\n  };\n  JSONCompletion2.prototype.getSuggestionKind = function(type) {\n    if (Array.isArray(type)) {\n      var array = type;\n      type = array.length \u003e 0 ? array[0] : void 0;\n    }\n    if (!type) {\n      return CompletionItemKind2.Value;\n    }\n    switch (type) {\n      case \"string\":\n        return CompletionItemKind2.Value;\n      case \"object\":\n        return CompletionItemKind2.Module;\n      case \"property\":\n        return CompletionItemKind2.Property;\n      default:\n        return CompletionItemKind2.Value;\n    }\n  };\n  JSONCompletion2.prototype.getLabelTextForMatchingNode = function(node, document2) {\n    switch (node.type) {\n      case \"array\":\n        return \"[]\";\n      case \"object\":\n        return \"{}\";\n      default:\n        var content = document2.getText().substr(node.offset, node.length);\n        return content;\n    }\n  };\n  JSONCompletion2.prototype.getInsertTextForMatchingNode = function(node, document2, separatorAfter) {\n    switch (node.type) {\n      case \"array\":\n        return this.getInsertTextForValue([], separatorAfter);\n      case \"object\":\n        return this.getInsertTextForValue({}, separatorAfter);\n      default:\n        var content = document2.getText().substr(node.offset, node.length) + separatorAfter;\n        return this.getInsertTextForPlainText(content);\n    }\n  };\n  JSONCompletion2.prototype.getInsertTextForProperty = function(key, propertySchema, addValue, separatorAfter) {\n    var propertyText = this.getInsertTextForValue(key, \"\");\n    if (!addValue) {\n      return propertyText;\n    }\n    var resultText = propertyText + \": \";\n    var value;\n    var nValueProposals = 0;\n    if (propertySchema) {\n      if (Array.isArray(propertySchema.defaultSnippets)) {\n        if (propertySchema.defaultSnippets.length === 1) {\n          var body = propertySchema.defaultSnippets[0].body;\n          if (isDefined(body)) {\n            value = this.getInsertTextForSnippetValue(body, \"\");\n          }\n        }\n        nValueProposals += propertySchema.defaultSnippets.length;\n      }\n      if (propertySchema.enum) {\n        if (!value \u0026\u0026 propertySchema.enum.length === 1) {\n          value = this.getInsertTextForGuessedValue(propertySchema.enum[0], \"\");\n        }\n        nValueProposals += propertySchema.enum.length;\n      }\n      if (isDefined(propertySchema.default)) {\n        if (!value) {\n          value = this.getInsertTextForGuessedValue(propertySchema.default, \"\");\n        }\n        nValueProposals++;\n      }\n      if (Array.isArray(propertySchema.examples) \u0026\u0026 propertySchema.examples.length) {\n        if (!value) {\n          value = this.getInsertTextForGuessedValue(propertySchema.examples[0], \"\");\n        }\n        nValueProposals += propertySchema.examples.length;\n      }\n      if (nValueProposals === 0) {\n        var type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;\n        if (!type) {\n          if (propertySchema.properties) {\n            type = \"object\";\n          } else if (propertySchema.items) {\n            type = \"array\";\n          }\n        }\n        switch (type) {\n          case \"boolean\":\n            value = \"$1\";\n            break;\n          case \"string\":\n            value = '\"$1\"';\n            break;\n          case \"object\":\n            value = \"{$1}\";\n            break;\n          case \"array\":\n            value = \"[$1]\";\n            break;\n          case \"number\":\n          case \"integer\":\n            value = \"${1:0}\";\n            break;\n          case \"null\":\n            value = \"${1:null}\";\n            break;\n          default:\n            return propertyText;\n        }\n      }\n    }\n    if (!value || nValueProposals \u003e 1) {\n      value = \"$1\";\n    }\n    return resultText + value + separatorAfter;\n  };\n  JSONCompletion2.prototype.getCurrentWord = function(document2, offset) {\n    var i = offset - 1;\n    var text = document2.getText();\n    while (i \u003e= 0 \u0026\u0026 ' \t\\n\\r\\v\":{[,]}'.indexOf(text.charAt(i)) === -1) {\n      i--;\n    }\n    return text.substring(i + 1, offset);\n  };\n  JSONCompletion2.prototype.evaluateSeparatorAfter = function(document2, offset) {\n    var scanner = createScanner2(document2.getText(), true);\n    scanner.setPosition(offset);\n    var token = scanner.scan();\n    switch (token) {\n      case 5:\n      case 2:\n      case 4:\n      case 17:\n        return \"\";\n      default:\n        return \",\";\n    }\n  };\n  JSONCompletion2.prototype.findItemAtOffset = function(node, document2, offset) {\n    var scanner = createScanner2(document2.getText(), true);\n    var children = node.items;\n    for (var i = children.length - 1; i \u003e= 0; i--) {\n      var child = children[i];\n      if (offset \u003e child.offset + child.length) {\n        scanner.setPosition(child.offset + child.length);\n        var token = scanner.scan();\n        if (token === 5 \u0026\u0026 offset \u003e= scanner.getTokenOffset() + scanner.getTokenLength()) {\n          return i + 1;\n        }\n        return i;\n      } else if (offset \u003e= child.offset) {\n        return i;\n      }\n    }\n    return 0;\n  };\n  JSONCompletion2.prototype.isInComment = function(document2, start, offset) {\n    var scanner = createScanner2(document2.getText(), false);\n    scanner.setPosition(start);\n    var token = scanner.scan();\n    while (token !== 17 \u0026\u0026 scanner.getTokenOffset() + scanner.getTokenLength() \u003c offset) {\n      token = scanner.scan();\n    }\n    return (token === 12 || token === 13) \u0026\u0026 scanner.getTokenOffset() \u003c= offset;\n  };\n  JSONCompletion2.prototype.fromMarkup = function(markupString) {\n    if (markupString \u0026\u0026 this.doesSupportMarkdown()) {\n      return {\n        kind: MarkupKind.Markdown,\n        value: markupString\n      };\n    }\n    return void 0;\n  };\n  JSONCompletion2.prototype.doesSupportMarkdown = function() {\n    if (!isDefined(this.supportsMarkdown)) {\n      var completion = this.clientCapabilities.textDocument \u0026\u0026 this.clientCapabilities.textDocument.completion;\n      this.supportsMarkdown = completion \u0026\u0026 completion.completionItem \u0026\u0026 Array.isArray(completion.completionItem.documentationFormat) \u0026\u0026 completion.completionItem.documentationFormat.indexOf(MarkupKind.Markdown) !== -1;\n    }\n    return this.supportsMarkdown;\n  };\n  JSONCompletion2.prototype.doesSupportsCommitCharacters = function() {\n    if (!isDefined(this.supportsCommitCharacters)) {\n      var completion = this.clientCapabilities.textDocument \u0026\u0026 this.clientCapabilities.textDocument.completion;\n      this.supportsCommitCharacters = completion \u0026\u0026 completion.completionItem \u0026\u0026 !!completion.completionItem.commitCharactersSupport;\n    }\n    return this.supportsCommitCharacters;\n  };\n  return JSONCompletion2;\n}();\nvar JSONHover = function() {\n  function JSONHover2(schemaService, contributions, promiseConstructor) {\n    if (contributions === void 0) {\n      contributions = [];\n    }\n    this.schemaService = schemaService;\n    this.contributions = contributions;\n    this.promise = promiseConstructor || Promise;\n  }\n  JSONHover2.prototype.doHover = function(document2, position, doc) {\n    var offset = document2.offsetAt(position);\n    var node = doc.getNodeFromOffset(offset);\n    if (!node || (node.type === \"object\" || node.type === \"array\") \u0026\u0026 offset \u003e node.offset + 1 \u0026\u0026 offset \u003c node.offset + node.length - 1) {\n      return this.promise.resolve(null);\n    }\n    var hoverRangeNode = node;\n    if (node.type === \"string\") {\n      var parent = node.parent;\n      if (parent \u0026\u0026 parent.type === \"property\" \u0026\u0026 parent.keyNode === node) {\n        node = parent.valueNode;\n        if (!node) {\n          return this.promise.resolve(null);\n        }\n      }\n    }\n    var hoverRange = Range2.create(document2.positionAt(hoverRangeNode.offset), document2.positionAt(hoverRangeNode.offset + hoverRangeNode.length));\n    var createHover = function(contents) {\n      var result = {\n        contents,\n        range: hoverRange\n      };\n      return result;\n    };\n    var location = getNodePath3(node);\n    for (var i = this.contributions.length - 1; i \u003e= 0; i--) {\n      var contribution = this.contributions[i];\n      var promise = contribution.getInfoContribution(document2.uri, location);\n      if (promise) {\n        return promise.then(function(htmlContent) {\n          return createHover(htmlContent);\n        });\n      }\n    }\n    return this.schemaService.getSchemaForResource(document2.uri, doc).then(function(schema2) {\n      if (schema2 \u0026\u0026 node) {\n        var matchingSchemas = doc.getMatchingSchemas(schema2.schema, node.offset);\n        var title_1 = void 0;\n        var markdownDescription_1 = void 0;\n        var markdownEnumValueDescription_1 = void 0, enumValue_1 = void 0;\n        matchingSchemas.every(function(s) {\n          if (s.node === node \u0026\u0026 !s.inverted \u0026\u0026 s.schema) {\n            title_1 = title_1 || s.schema.title;\n            markdownDescription_1 = markdownDescription_1 || s.schema.markdownDescription || toMarkdown(s.schema.description);\n            if (s.schema.enum) {\n              var idx = s.schema.enum.indexOf(getNodeValue3(node));\n              if (s.schema.markdownEnumDescriptions) {\n                markdownEnumValueDescription_1 = s.schema.markdownEnumDescriptions[idx];\n              } else if (s.schema.enumDescriptions) {\n                markdownEnumValueDescription_1 = toMarkdown(s.schema.enumDescriptions[idx]);\n              }\n              if (markdownEnumValueDescription_1) {\n                enumValue_1 = s.schema.enum[idx];\n                if (typeof enumValue_1 !== \"string\") {\n                  enumValue_1 = JSON.stringify(enumValue_1);\n                }\n              }\n            }\n          }\n          return true;\n        });\n        var result = \"\";\n        if (title_1) {\n          result = toMarkdown(title_1);\n        }\n        if (markdownDescription_1) {\n          if (result.length \u003e 0) {\n            result += \"\\n\\n\";\n          }\n          result += markdownDescription_1;\n        }\n        if (markdownEnumValueDescription_1) {\n          if (result.length \u003e 0) {\n            result += \"\\n\\n\";\n          }\n          result += \"`\".concat(toMarkdownCodeBlock(enumValue_1), \"`: \").concat(markdownEnumValueDescription_1);\n        }\n        return createHover([result]);\n      }\n      return null;\n    });\n  };\n  return JSONHover2;\n}();\nfunction toMarkdown(plain) {\n  if (plain) {\n    var res = plain.replace(/([^\\n\\r])(\\r?\\n)([^\\n\\r])/gm, \"$1\\n\\n$3\");\n    return res.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$\u0026\");\n  }\n  return void 0;\n}\nfunction toMarkdownCodeBlock(content) {\n  if (content.indexOf(\"`\") !== -1) {\n    return \"`` \" + content + \" ``\";\n  }\n  return content;\n}\nvar localize4 = loadMessageBundle();\nvar JSONValidation = function() {\n  function JSONValidation2(jsonSchemaService, promiseConstructor) {\n    this.jsonSchemaService = jsonSchemaService;\n    this.promise = promiseConstructor;\n    this.validationEnabled = true;\n  }\n  JSONValidation2.prototype.configure = function(raw) {\n    if (raw) {\n      this.validationEnabled = raw.validate !== false;\n      this.commentSeverity = raw.allowComments ? void 0 : DiagnosticSeverity.Error;\n    }\n  };\n  JSONValidation2.prototype.doValidation = function(textDocument, jsonDocument, documentSettings, schema2) {\n    var _this = this;\n    if (!this.validationEnabled) {\n      return this.promise.resolve([]);\n    }\n    var diagnostics = [];\n    var added = {};\n    var addProblem = function(problem) {\n      var signature = problem.range.start.line + \" \" + problem.range.start.character + \" \" + problem.message;\n      if (!added[signature]) {\n        added[signature] = true;\n        diagnostics.push(problem);\n      }\n    };\n    var getDiagnostics = function(schema22) {\n      var trailingCommaSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.trailingCommas) ? toDiagnosticSeverity(documentSettings.trailingCommas) : DiagnosticSeverity.Error;\n      var commentSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.comments) ? toDiagnosticSeverity(documentSettings.comments) : _this.commentSeverity;\n      var schemaValidation = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaValidation) ? toDiagnosticSeverity(documentSettings.schemaValidation) : DiagnosticSeverity.Warning;\n      var schemaRequest = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaRequest) ? toDiagnosticSeverity(documentSettings.schemaRequest) : DiagnosticSeverity.Warning;\n      if (schema22) {\n        if (schema22.errors.length \u0026\u0026 jsonDocument.root \u0026\u0026 schemaRequest) {\n          var astRoot = jsonDocument.root;\n          var property2 = astRoot.type === \"object\" ? astRoot.properties[0] : void 0;\n          if (property2 \u0026\u0026 property2.keyNode.value === \"$schema\") {\n            var node = property2.valueNode || property2;\n            var range = Range2.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));\n            addProblem(Diagnostic.create(range, schema22.errors[0], schemaRequest, ErrorCode.SchemaResolveError));\n          } else {\n            var range = Range2.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));\n            addProblem(Diagnostic.create(range, schema22.errors[0], schemaRequest, ErrorCode.SchemaResolveError));\n          }\n        } else if (schemaValidation) {\n          var semanticErrors = jsonDocument.validate(textDocument, schema22.schema, schemaValidation);\n          if (semanticErrors) {\n            semanticErrors.forEach(addProblem);\n          }\n        }\n        if (schemaAllowsComments(schema22.schema)) {\n          commentSeverity = void 0;\n        }\n        if (schemaAllowsTrailingCommas(schema22.schema)) {\n          trailingCommaSeverity = void 0;\n        }\n      }\n      for (var _i = 0, _a4 = jsonDocument.syntaxErrors; _i \u003c _a4.length; _i++) {\n        var p = _a4[_i];\n        if (p.code === ErrorCode.TrailingComma) {\n          if (typeof trailingCommaSeverity !== \"number\") {\n            continue;\n          }\n          p.severity = trailingCommaSeverity;\n        }\n        addProblem(p);\n      }\n      if (typeof commentSeverity === \"number\") {\n        var message_1 = localize4(\"InvalidCommentToken\", \"Comments are not permitted in JSON.\");\n        jsonDocument.comments.forEach(function(c) {\n          addProblem(Diagnostic.create(c, message_1, commentSeverity, ErrorCode.CommentNotPermitted));\n        });\n      }\n      return diagnostics;\n    };\n    if (schema2) {\n      var id = schema2.id || \"schemaservice://untitled/\" + idCounter++;\n      var handle = this.jsonSchemaService.registerExternalSchema(id, [], schema2);\n      return handle.getResolvedSchema().then(function(resolvedSchema) {\n        return getDiagnostics(resolvedSchema);\n      });\n    }\n    return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then(function(schema22) {\n      return getDiagnostics(schema22);\n    });\n  };\n  JSONValidation2.prototype.getLanguageStatus = function(textDocument, jsonDocument) {\n    return { schemas: this.jsonSchemaService.getSchemaURIsForResource(textDocument.uri, jsonDocument) };\n  };\n  return JSONValidation2;\n}();\nvar idCounter = 0;\nfunction schemaAllowsComments(schemaRef) {\n  if (schemaRef \u0026\u0026 typeof schemaRef === \"object\") {\n    if (isBoolean(schemaRef.allowComments)) {\n      return schemaRef.allowComments;\n    }\n    if (schemaRef.allOf) {\n      for (var _i = 0, _a4 = schemaRef.allOf; _i \u003c _a4.length; _i++) {\n        var schema2 = _a4[_i];\n        var allow = schemaAllowsComments(schema2);\n        if (isBoolean(allow)) {\n          return allow;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction schemaAllowsTrailingCommas(schemaRef) {\n  if (schemaRef \u0026\u0026 typeof schemaRef === \"object\") {\n    if (isBoolean(schemaRef.allowTrailingCommas)) {\n      return schemaRef.allowTrailingCommas;\n    }\n    var deprSchemaRef = schemaRef;\n    if (isBoolean(deprSchemaRef[\"allowsTrailingCommas\"])) {\n      return deprSchemaRef[\"allowsTrailingCommas\"];\n    }\n    if (schemaRef.allOf) {\n      for (var _i = 0, _a4 = schemaRef.allOf; _i \u003c _a4.length; _i++) {\n        var schema2 = _a4[_i];\n        var allow = schemaAllowsTrailingCommas(schema2);\n        if (isBoolean(allow)) {\n          return allow;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction toDiagnosticSeverity(severityLevel) {\n  switch (severityLevel) {\n    case \"error\":\n      return DiagnosticSeverity.Error;\n    case \"warning\":\n      return DiagnosticSeverity.Warning;\n    case \"ignore\":\n      return void 0;\n  }\n  return void 0;\n}\nvar Digit0 = 48;\nvar Digit9 = 57;\nvar A = 65;\nvar a = 97;\nvar f = 102;\nfunction hexDigit(charCode) {\n  if (charCode \u003c Digit0) {\n    return 0;\n  }\n  if (charCode \u003c= Digit9) {\n    return charCode - Digit0;\n  }\n  if (charCode \u003c a) {\n    charCode += a - A;\n  }\n  if (charCode \u003e= a \u0026\u0026 charCode \u003c= f) {\n    return charCode - a + 10;\n  }\n  return 0;\n}\nfunction colorFromHex(text) {\n  if (text[0] !== \"#\") {\n    return void 0;\n  }\n  switch (text.length) {\n    case 4:\n      return {\n        red: hexDigit(text.charCodeAt(1)) * 17 / 255,\n        green: hexDigit(text.charCodeAt(2)) * 17 / 255,\n        blue: hexDigit(text.charCodeAt(3)) * 17 / 255,\n        alpha: 1\n      };\n    case 5:\n      return {\n        red: hexDigit(text.charCodeAt(1)) * 17 / 255,\n        green: hexDigit(text.charCodeAt(2)) * 17 / 255,\n        blue: hexDigit(text.charCodeAt(3)) * 17 / 255,\n        alpha: hexDigit(text.charCodeAt(4)) * 17 / 255\n      };\n    case 7:\n      return {\n        red: (hexDigit(text.charCodeAt(1)) * 16 + hexDigit(text.charCodeAt(2))) / 255,\n        green: (hexDigit(text.charCodeAt(3)) * 16 + hexDigit(text.charCodeAt(4))) / 255,\n        blue: (hexDigit(text.charCodeAt(5)) * 16 + hexDigit(text.charCodeAt(6))) / 255,\n        alpha: 1\n      };\n    case 9:\n      return {\n        red: (hexDigit(text.charCodeAt(1)) * 16 + hexDigit(text.charCodeAt(2))) / 255,\n        green: (hexDigit(text.charCodeAt(3)) * 16 + hexDigit(text.charCodeAt(4))) / 255,\n        blue: (hexDigit(text.charCodeAt(5)) * 16 + hexDigit(text.charCodeAt(6))) / 255,\n        alpha: (hexDigit(text.charCodeAt(7)) * 16 + hexDigit(text.charCodeAt(8))) / 255\n      };\n  }\n  return void 0;\n}\nvar JSONDocumentSymbols = function() {\n  function JSONDocumentSymbols2(schemaService) {\n    this.schemaService = schemaService;\n  }\n  JSONDocumentSymbols2.prototype.findDocumentSymbols = function(document2, doc, context) {\n    var _this = this;\n    if (context === void 0) {\n      context = { resultLimit: Number.MAX_VALUE };\n    }\n    var root = doc.root;\n    if (!root) {\n      return [];\n    }\n    var limit = context.resultLimit || Number.MAX_VALUE;\n    var resourceString = document2.uri;\n    if (resourceString === \"vscode://defaultsettings/keybindings.json\" || endsWith(resourceString.toLowerCase(), \"/user/keybindings.json\")) {\n      if (root.type === \"array\") {\n        var result_1 = [];\n        for (var _i = 0, _a4 = root.items; _i \u003c _a4.length; _i++) {\n          var item = _a4[_i];\n          if (item.type === \"object\") {\n            for (var _b2 = 0, _c = item.properties; _b2 \u003c _c.length; _b2++) {\n              var property2 = _c[_b2];\n              if (property2.keyNode.value === \"key\" \u0026\u0026 property2.valueNode) {\n                var location = Location.create(document2.uri, getRange(document2, item));\n                result_1.push({ name: getNodeValue3(property2.valueNode), kind: SymbolKind2.Function, location });\n                limit--;\n                if (limit \u003c= 0) {\n                  if (context \u0026\u0026 context.onResultLimitExceeded) {\n                    context.onResultLimitExceeded(resourceString);\n                  }\n                  return result_1;\n                }\n              }\n            }\n          }\n        }\n        return result_1;\n      }\n    }\n    var toVisit = [\n      { node: root, containerName: \"\" }\n    ];\n    var nextToVisit = 0;\n    var limitExceeded = false;\n    var result = [];\n    var collectOutlineEntries = function(node, containerName) {\n      if (node.type === \"array\") {\n        node.items.forEach(function(node2) {\n          if (node2) {\n            toVisit.push({ node: node2, containerName });\n          }\n        });\n      } else if (node.type === \"object\") {\n        node.properties.forEach(function(property22) {\n          var valueNode = property22.valueNode;\n          if (valueNode) {\n            if (limit \u003e 0) {\n              limit--;\n              var location2 = Location.create(document2.uri, getRange(document2, property22));\n              var childContainerName = containerName ? containerName + \".\" + property22.keyNode.value : property22.keyNode.value;\n              result.push({ name: _this.getKeyLabel(property22), kind: _this.getSymbolKind(valueNode.type), location: location2, containerName });\n              toVisit.push({ node: valueNode, containerName: childContainerName });\n            } else {\n              limitExceeded = true;\n            }\n          }\n        });\n      }\n    };\n    while (nextToVisit \u003c toVisit.length) {\n      var next = toVisit[nextToVisit++];\n      collectOutlineEntries(next.node, next.containerName);\n    }\n    if (limitExceeded \u0026\u0026 context \u0026\u0026 context.onResultLimitExceeded) {\n      context.onResultLimitExceeded(resourceString);\n    }\n    return result;\n  };\n  JSONDocumentSymbols2.prototype.findDocumentSymbols2 = function(document2, doc, context) {\n    var _this = this;\n    if (context === void 0) {\n      context = { resultLimit: Number.MAX_VALUE };\n    }\n    var root = doc.root;\n    if (!root) {\n      return [];\n    }\n    var limit = context.resultLimit || Number.MAX_VALUE;\n    var resourceString = document2.uri;\n    if (resourceString === \"vscode://defaultsettings/keybindings.json\" || endsWith(resourceString.toLowerCase(), \"/user/keybindings.json\")) {\n      if (root.type === \"array\") {\n        var result_2 = [];\n        for (var _i = 0, _a4 = root.items; _i \u003c _a4.length; _i++) {\n          var item = _a4[_i];\n          if (item.type === \"object\") {\n            for (var _b2 = 0, _c = item.properties; _b2 \u003c _c.length; _b2++) {\n              var property2 = _c[_b2];\n              if (property2.keyNode.value === \"key\" \u0026\u0026 property2.valueNode) {\n                var range = getRange(document2, item);\n                var selectionRange = getRange(document2, property2.keyNode);\n                result_2.push({ name: getNodeValue3(property2.valueNode), kind: SymbolKind2.Function, range, selectionRange });\n                limit--;\n                if (limit \u003c= 0) {\n                  if (context \u0026\u0026 context.onResultLimitExceeded) {\n                    context.onResultLimitExceeded(resourceString);\n                  }\n                  return result_2;\n                }\n              }\n            }\n          }\n        }\n        return result_2;\n      }\n    }\n    var result = [];\n    var toVisit = [\n      { node: root, result }\n    ];\n    var nextToVisit = 0;\n    var limitExceeded = false;\n    var collectOutlineEntries = function(node, result2) {\n      if (node.type === \"array\") {\n        node.items.forEach(function(node2, index) {\n          if (node2) {\n            if (limit \u003e 0) {\n              limit--;\n              var range2 = getRange(document2, node2);\n              var selectionRange2 = range2;\n              var name = String(index);\n              var symbol = { name, kind: _this.getSymbolKind(node2.type), range: range2, selectionRange: selectionRange2, children: [] };\n              result2.push(symbol);\n              toVisit.push({ result: symbol.children, node: node2 });\n            } else {\n              limitExceeded = true;\n            }\n          }\n        });\n      } else if (node.type === \"object\") {\n        node.properties.forEach(function(property22) {\n          var valueNode = property22.valueNode;\n          if (valueNode) {\n            if (limit \u003e 0) {\n              limit--;\n              var range2 = getRange(document2, property22);\n              var selectionRange2 = getRange(document2, property22.keyNode);\n              var children = [];\n              var symbol = { name: _this.getKeyLabel(property22), kind: _this.getSymbolKind(valueNode.type), range: range2, selectionRange: selectionRange2, children, detail: _this.getDetail(valueNode) };\n              result2.push(symbol);\n              toVisit.push({ result: children, node: valueNode });\n            } else {\n              limitExceeded = true;\n            }\n          }\n        });\n      }\n    };\n    while (nextToVisit \u003c toVisit.length) {\n      var next = toVisit[nextToVisit++];\n      collectOutlineEntries(next.node, next.result);\n    }\n    if (limitExceeded \u0026\u0026 context \u0026\u0026 context.onResultLimitExceeded) {\n      context.onResultLimitExceeded(resourceString);\n    }\n    return result;\n  };\n  JSONDocumentSymbols2.prototype.getSymbolKind = function(nodeType) {\n    switch (nodeType) {\n      case \"object\":\n        return SymbolKind2.Module;\n      case \"string\":\n        return SymbolKind2.String;\n      case \"number\":\n        return SymbolKind2.Number;\n      case \"array\":\n        return SymbolKind2.Array;\n      case \"boolean\":\n        return SymbolKind2.Boolean;\n      default:\n        return SymbolKind2.Variable;\n    }\n  };\n  JSONDocumentSymbols2.prototype.getKeyLabel = function(property2) {\n    var name = property2.keyNode.value;\n    if (name) {\n      name = name.replace(/[\\n]/g, \"\\u21B5\");\n    }\n    if (name \u0026\u0026 name.trim()) {\n      return name;\n    }\n    return '\"'.concat(name, '\"');\n  };\n  JSONDocumentSymbols2.prototype.getDetail = function(node) {\n    if (!node) {\n      return void 0;\n    }\n    if (node.type === \"boolean\" || node.type === \"number\" || node.type === \"null\" || node.type === \"string\") {\n      return String(node.value);\n    } else {\n      if (node.type === \"array\") {\n        return node.children.length ? void 0 : \"[]\";\n      } else if (node.type === \"object\") {\n        return node.children.length ? void 0 : \"{}\";\n      }\n    }\n    return void 0;\n  };\n  JSONDocumentSymbols2.prototype.findDocumentColors = function(document2, doc, context) {\n    return this.schemaService.getSchemaForResource(document2.uri, doc).then(function(schema2) {\n      var result = [];\n      if (schema2) {\n        var limit = context \u0026\u0026 typeof context.resultLimit === \"number\" ? context.resultLimit : Number.MAX_VALUE;\n        var matchingSchemas = doc.getMatchingSchemas(schema2.schema);\n        var visitedNode = {};\n        for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i \u003c matchingSchemas_1.length; _i++) {\n          var s = matchingSchemas_1[_i];\n          if (!s.inverted \u0026\u0026 s.schema \u0026\u0026 (s.schema.format === \"color\" || s.schema.format === \"color-hex\") \u0026\u0026 s.node \u0026\u0026 s.node.type === \"string\") {\n            var nodeId = String(s.node.offset);\n            if (!visitedNode[nodeId]) {\n              var color = colorFromHex(getNodeValue3(s.node));\n              if (color) {\n                var range = getRange(document2, s.node);\n                result.push({ color, range });\n              }\n              visitedNode[nodeId] = true;\n              limit--;\n              if (limit \u003c= 0) {\n                if (context \u0026\u0026 context.onResultLimitExceeded) {\n                  context.onResultLimitExceeded(document2.uri);\n                }\n                return result;\n              }\n            }\n          }\n        }\n      }\n      return result;\n    });\n  };\n  JSONDocumentSymbols2.prototype.getColorPresentations = function(document2, doc, color, range) {\n    var result = [];\n    var red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);\n    function toTwoDigitHex(n) {\n      var r = n.toString(16);\n      return r.length !== 2 ? \"0\" + r : r;\n    }\n    var label;\n    if (color.alpha === 1) {\n      label = \"#\".concat(toTwoDigitHex(red256)).concat(toTwoDigitHex(green256)).concat(toTwoDigitHex(blue256));\n    } else {\n      label = \"#\".concat(toTwoDigitHex(red256)).concat(toTwoDigitHex(green256)).concat(toTwoDigitHex(blue256)).concat(toTwoDigitHex(Math.round(color.alpha * 255)));\n    }\n    result.push({ label, textEdit: TextEdit.replace(range, JSON.stringify(label)) });\n    return result;\n  };\n  return JSONDocumentSymbols2;\n}();\nfunction getRange(document2, node) {\n  return Range2.create(document2.positionAt(node.offset), document2.positionAt(node.offset + node.length));\n}\nvar localize5 = loadMessageBundle();\nvar schemaContributions = {\n  schemaAssociations: [],\n  schemas: {\n    \"http://json-schema.org/schema#\": {\n      $ref: \"http://json-schema.org/draft-07/schema#\"\n    },\n    \"http://json-schema.org/draft-04/schema#\": {\n      \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n      \"definitions\": {\n        \"schemaArray\": {\n          \"type\": \"array\",\n          \"minItems\": 1,\n          \"items\": {\n            \"$ref\": \"#\"\n          }\n        },\n        \"positiveInteger\": {\n          \"type\": \"integer\",\n          \"minimum\": 0\n        },\n        \"positiveIntegerDefault0\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/positiveInteger\"\n            },\n            {\n              \"default\": 0\n            }\n          ]\n        },\n        \"simpleTypes\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"array\",\n            \"boolean\",\n            \"integer\",\n            \"null\",\n            \"number\",\n            \"object\",\n            \"string\"\n          ]\n        },\n        \"stringArray\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      },\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"$schema\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"title\": {\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"default\": {},\n        \"multipleOf\": {\n          \"type\": \"number\",\n          \"minimum\": 0,\n          \"exclusiveMinimum\": true\n        },\n        \"maximum\": {\n          \"type\": \"number\"\n        },\n        \"exclusiveMaximum\": {\n          \"type\": \"boolean\",\n          \"default\": false\n        },\n        \"minimum\": {\n          \"type\": \"number\"\n        },\n        \"exclusiveMinimum\": {\n          \"type\": \"boolean\",\n          \"default\": false\n        },\n        \"maxLength\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/positiveInteger\"\n            }\n          ]\n        },\n        \"minLength\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/positiveIntegerDefault0\"\n            }\n          ]\n        },\n        \"pattern\": {\n          \"type\": \"string\",\n          \"format\": \"regex\"\n        },\n        \"additionalItems\": {\n          \"anyOf\": [\n            {\n              \"type\": \"boolean\"\n            },\n            {\n              \"$ref\": \"#\"\n            }\n          ],\n          \"default\": {}\n        },\n        \"items\": {\n          \"anyOf\": [\n            {\n              \"$ref\": \"#\"\n            },\n            {\n              \"$ref\": \"#/definitions/schemaArray\"\n            }\n          ],\n          \"default\": {}\n        },\n        \"maxItems\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/positiveInteger\"\n            }\n          ]\n        },\n        \"minItems\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/positiveIntegerDefault0\"\n            }\n          ]\n        },\n        \"uniqueItems\": {\n          \"type\": \"boolean\",\n          \"default\": false\n        },\n        \"maxProperties\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/positiveInteger\"\n            }\n          ]\n        },\n        \"minProperties\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/positiveIntegerDefault0\"\n            }\n          ]\n        },\n        \"required\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/stringArray\"\n            }\n          ]\n        },\n        \"additionalProperties\": {\n          \"anyOf\": [\n            {\n              \"type\": \"boolean\"\n            },\n            {\n              \"$ref\": \"#\"\n            }\n          ],\n          \"default\": {}\n        },\n        \"definitions\": {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"#\"\n          },\n          \"default\": {}\n        },\n        \"properties\": {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"#\"\n          },\n          \"default\": {}\n        },\n        \"patternProperties\": {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"#\"\n          },\n          \"default\": {}\n        },\n        \"dependencies\": {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"anyOf\": [\n              {\n                \"$ref\": \"#\"\n              },\n              {\n                \"$ref\": \"#/definitions/stringArray\"\n              }\n            ]\n          }\n        },\n        \"enum\": {\n          \"type\": \"array\",\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        },\n        \"type\": {\n          \"anyOf\": [\n            {\n              \"$ref\": \"#/definitions/simpleTypes\"\n            },\n            {\n              \"type\": \"array\",\n              \"items\": {\n                \"$ref\": \"#/definitions/simpleTypes\"\n              },\n              \"minItems\": 1,\n              \"uniqueItems\": true\n            }\n          ]\n        },\n        \"format\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\",\n              \"enum\": [\n                \"date-time\",\n                \"uri\",\n                \"email\",\n                \"hostname\",\n                \"ipv4\",\n                \"ipv6\",\n                \"regex\"\n              ]\n            },\n            {\n              \"type\": \"string\"\n            }\n          ]\n        },\n        \"allOf\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/schemaArray\"\n            }\n          ]\n        },\n        \"anyOf\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/schemaArray\"\n            }\n          ]\n        },\n        \"oneOf\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#/definitions/schemaArray\"\n            }\n          ]\n        },\n        \"not\": {\n          \"allOf\": [\n            {\n              \"$ref\": \"#\"\n            }\n          ]\n        }\n      },\n      \"dependencies\": {\n        \"exclusiveMaximum\": [\n          \"maximum\"\n        ],\n        \"exclusiveMinimum\": [\n          \"minimum\"\n        ]\n      },\n      \"default\": {}\n    },\n    \"http://json-schema.org/draft-07/schema#\": {\n      \"definitions\": {\n        \"schemaArray\": {\n          \"type\": \"array\",\n          \"minItems\": 1,\n          \"items\": { \"$ref\": \"#\" }\n        },\n        \"nonNegativeInteger\": {\n          \"type\": \"integer\",\n          \"minimum\": 0\n        },\n        \"nonNegativeIntegerDefault0\": {\n          \"allOf\": [\n            { \"$ref\": \"#/definitions/nonNegativeInteger\" },\n            { \"default\": 0 }\n          ]\n        },\n        \"simpleTypes\": {\n          \"enum\": [\n            \"array\",\n            \"boolean\",\n            \"integer\",\n            \"null\",\n            \"number\",\n            \"object\",\n            \"string\"\n          ]\n        },\n        \"stringArray\": {\n          \"type\": \"array\",\n          \"items\": { \"type\": \"string\" },\n          \"uniqueItems\": true,\n          \"default\": []\n        }\n      },\n      \"type\": [\"object\", \"boolean\"],\n      \"properties\": {\n        \"$id\": {\n          \"type\": \"string\",\n          \"format\": \"uri-reference\"\n        },\n        \"$schema\": {\n          \"type\": \"string\",\n          \"format\": \"uri\"\n        },\n        \"$ref\": {\n          \"type\": \"string\",\n          \"format\": \"uri-reference\"\n        },\n        \"$comment\": {\n          \"type\": \"string\"\n        },\n        \"title\": {\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"type\": \"string\"\n        },\n        \"default\": true,\n        \"readOnly\": {\n          \"type\": \"boolean\",\n          \"default\": false\n        },\n        \"examples\": {\n          \"type\": \"array\",\n          \"items\": true\n        },\n        \"multipleOf\": {\n          \"type\": \"number\",\n          \"exclusiveMinimum\": 0\n        },\n        \"maximum\": {\n          \"type\": \"number\"\n        },\n        \"exclusiveMaximum\": {\n          \"type\": \"number\"\n        },\n        \"minimum\": {\n          \"type\": \"number\"\n        },\n        \"exclusiveMinimum\": {\n          \"type\": \"number\"\n        },\n        \"maxLength\": { \"$ref\": \"#/definitions/nonNegativeInteger\" },\n        \"minLength\": { \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\" },\n        \"pattern\": {\n          \"type\": \"string\",\n          \"format\": \"regex\"\n        },\n        \"additionalItems\": { \"$ref\": \"#\" },\n        \"items\": {\n          \"anyOf\": [\n            { \"$ref\": \"#\" },\n            { \"$ref\": \"#/definitions/schemaArray\" }\n          ],\n          \"default\": true\n        },\n        \"maxItems\": { \"$ref\": \"#/definitions/nonNegativeInteger\" },\n        \"minItems\": { \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\" },\n        \"uniqueItems\": {\n          \"type\": \"boolean\",\n          \"default\": false\n        },\n        \"contains\": { \"$ref\": \"#\" },\n        \"maxProperties\": { \"$ref\": \"#/definitions/nonNegativeInteger\" },\n        \"minProperties\": { \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\" },\n        \"required\": { \"$ref\": \"#/definitions/stringArray\" },\n        \"additionalProperties\": { \"$ref\": \"#\" },\n        \"definitions\": {\n          \"type\": \"object\",\n          \"additionalProperties\": { \"$ref\": \"#\" },\n          \"default\": {}\n        },\n        \"properties\": {\n          \"type\": \"object\",\n          \"additionalProperties\": { \"$ref\": \"#\" },\n          \"default\": {}\n        },\n        \"patternProperties\": {\n          \"type\": \"object\",\n          \"additionalProperties\": { \"$ref\": \"#\" },\n          \"propertyNames\": { \"format\": \"regex\" },\n          \"default\": {}\n        },\n        \"dependencies\": {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"anyOf\": [\n              { \"$ref\": \"#\" },\n              { \"$ref\": \"#/definitions/stringArray\" }\n            ]\n          }\n        },\n        \"propertyNames\": { \"$ref\": \"#\" },\n        \"const\": true,\n        \"enum\": {\n          \"type\": \"array\",\n          \"items\": true,\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        },\n        \"type\": {\n          \"anyOf\": [\n            { \"$ref\": \"#/definitions/simpleTypes\" },\n            {\n              \"type\": \"array\",\n              \"items\": { \"$ref\": \"#/definitions/simpleTypes\" },\n              \"minItems\": 1,\n              \"uniqueItems\": true\n            }\n          ]\n        },\n        \"format\": { \"type\": \"string\" },\n        \"contentMediaType\": { \"type\": \"string\" },\n        \"contentEncoding\": { \"type\": \"string\" },\n        \"if\": { \"$ref\": \"#\" },\n        \"then\": { \"$ref\": \"#\" },\n        \"else\": { \"$ref\": \"#\" },\n        \"allOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"anyOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"oneOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"not\": { \"$ref\": \"#\" }\n      },\n      \"default\": true\n    }\n  }\n};\nvar descriptions = {\n  id: localize5(\"schema.json.id\", \"A unique identifier for the schema.\"),\n  $schema: localize5(\"schema.json.$schema\", \"The schema to verify this document against.\"),\n  title: localize5(\"schema.json.title\", \"A descriptive title of the element.\"),\n  description: localize5(\"schema.json.description\", \"A long description of the element. Used in hover menus and suggestions.\"),\n  default: localize5(\"schema.json.default\", \"A default value. Used by suggestions.\"),\n  multipleOf: localize5(\"schema.json.multipleOf\", \"A number that should cleanly divide the current value (i.e. have no remainder).\"),\n  maximum: localize5(\"schema.json.maximum\", \"The maximum numerical value, inclusive by default.\"),\n  exclusiveMaximum: localize5(\"schema.json.exclusiveMaximum\", \"Makes the maximum property exclusive.\"),\n  minimum: localize5(\"schema.json.minimum\", \"The minimum numerical value, inclusive by default.\"),\n  exclusiveMinimum: localize5(\"schema.json.exclusiveMininum\", \"Makes the minimum property exclusive.\"),\n  maxLength: localize5(\"schema.json.maxLength\", \"The maximum length of a string.\"),\n  minLength: localize5(\"schema.json.minLength\", \"The minimum length of a string.\"),\n  pattern: localize5(\"schema.json.pattern\", \"A regular expression to match the string against. It is not implicitly anchored.\"),\n  additionalItems: localize5(\"schema.json.additionalItems\", \"For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail.\"),\n  items: localize5(\"schema.json.items\", \"For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on.\"),\n  maxItems: localize5(\"schema.json.maxItems\", \"The maximum number of items that can be inside an array. Inclusive.\"),\n  minItems: localize5(\"schema.json.minItems\", \"The minimum number of items that can be inside an array. Inclusive.\"),\n  uniqueItems: localize5(\"schema.json.uniqueItems\", \"If all of the items in the array must be unique. Defaults to false.\"),\n  maxProperties: localize5(\"schema.json.maxProperties\", \"The maximum number of properties an object can have. Inclusive.\"),\n  minProperties: localize5(\"schema.json.minProperties\", \"The minimum number of properties an object can have. Inclusive.\"),\n  required: localize5(\"schema.json.required\", \"An array of strings that lists the names of all properties required on this object.\"),\n  additionalProperties: localize5(\"schema.json.additionalProperties\", \"Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail.\"),\n  definitions: localize5(\"schema.json.definitions\", \"Not used for validation. Place subschemas here that you wish to reference inline with $ref.\"),\n  properties: localize5(\"schema.json.properties\", \"A map of property names to schemas for each property.\"),\n  patternProperties: localize5(\"schema.json.patternProperties\", \"A map of regular expressions on property names to schemas for matching properties.\"),\n  dependencies: localize5(\"schema.json.dependencies\", \"A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object.\"),\n  enum: localize5(\"schema.json.enum\", \"The set of literal values that are valid.\"),\n  type: localize5(\"schema.json.type\", \"Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types.\"),\n  format: localize5(\"schema.json.format\", \"Describes the format expected for the value.\"),\n  allOf: localize5(\"schema.json.allOf\", \"An array of schemas, all of which must match.\"),\n  anyOf: localize5(\"schema.json.anyOf\", \"An array of schemas, where at least one must match.\"),\n  oneOf: localize5(\"schema.json.oneOf\", \"An array of schemas, exactly one of which must match.\"),\n  not: localize5(\"schema.json.not\", \"A schema which must not match.\"),\n  $id: localize5(\"schema.json.$id\", \"A unique identifier for the schema.\"),\n  $ref: localize5(\"schema.json.$ref\", \"Reference a definition hosted on any location.\"),\n  $comment: localize5(\"schema.json.$comment\", \"Comments from schema authors to readers or maintainers of the schema.\"),\n  readOnly: localize5(\"schema.json.readOnly\", \"Indicates that the value of the instance is managed exclusively by the owning authority.\"),\n  examples: localize5(\"schema.json.examples\", \"Sample JSON values associated with a particular schema, for the purpose of illustrating usage.\"),\n  contains: localize5(\"schema.json.contains\", 'An array instance is valid against \"contains\" if at least one of its elements is valid against the given schema.'),\n  propertyNames: localize5(\"schema.json.propertyNames\", \"If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema.\"),\n  const: localize5(\"schema.json.const\", \"An instance validates successfully against this keyword if its value is equal to the value of the keyword.\"),\n  contentMediaType: localize5(\"schema.json.contentMediaType\", \"Describes the media type of a string property.\"),\n  contentEncoding: localize5(\"schema.json.contentEncoding\", \"Describes the content encoding of a string property.\"),\n  if: localize5(\"schema.json.if\", 'The validation outcome of the \"if\" subschema controls which of the \"then\" or \"else\" keywords are evaluated.'),\n  then: localize5(\"schema.json.then\", 'The \"if\" subschema is used for validation when the \"if\" subschema succeeds.'),\n  else: localize5(\"schema.json.else\", 'The \"else\" subschema is used for validation when the \"if\" subschema fails.')\n};\nfor (schemaName in schemaContributions.schemas) {\n  schema = schemaContributions.schemas[schemaName];\n  for (property in schema.properties) {\n    propertyObject = schema.properties[property];\n    if (typeof propertyObject === \"boolean\") {\n      propertyObject = schema.properties[property] = {};\n    }\n    description = descriptions[property];\n    if (description) {\n      propertyObject[\"description\"] = description;\n    } else {\n      console.log(\"\".concat(property, \": localize('schema.json.\").concat(property, `', \"\")`));\n    }\n  }\n}\nvar schema;\nvar propertyObject;\nvar description;\nvar property;\nvar schemaName;\nvar LIB;\nLIB = (() =\u003e {\n  \"use strict\";\n  var t = { 470: (t2) =\u003e {\n    function e2(t3) {\n      if (\"string\" != typeof t3)\n        throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(t3));\n    }\n    function r2(t3, e3) {\n      for (var r3, n2 = \"\", o = 0, i = -1, a2 = 0, h = 0; h \u003c= t3.length; ++h) {\n        if (h \u003c t3.length)\n          r3 = t3.charCodeAt(h);\n        else {\n          if (47 === r3)\n            break;\n          r3 = 47;\n        }\n        if (47 === r3) {\n          if (i === h - 1 || 1 === a2)\n            ;\n          else if (i !== h - 1 \u0026\u0026 2 === a2) {\n            if (n2.length \u003c 2 || 2 !== o || 46 !== n2.charCodeAt(n2.length - 1) || 46 !== n2.charCodeAt(n2.length - 2)) {\n              if (n2.length \u003e 2) {\n                var s = n2.lastIndexOf(\"/\");\n                if (s !== n2.length - 1) {\n                  -1 === s ? (n2 = \"\", o = 0) : o = (n2 = n2.slice(0, s)).length - 1 - n2.lastIndexOf(\"/\"), i = h, a2 = 0;\n                  continue;\n                }\n              } else if (2 === n2.length || 1 === n2.length) {\n                n2 = \"\", o = 0, i = h, a2 = 0;\n                continue;\n              }\n            }\n            e3 \u0026\u0026 (n2.length \u003e 0 ? n2 += \"/..\" : n2 = \"..\", o = 2);\n          } else\n            n2.length \u003e 0 ? n2 += \"/\" + t3.slice(i + 1, h) : n2 = t3.slice(i + 1, h), o = h - i - 1;\n          i = h, a2 = 0;\n        } else\n          46 === r3 \u0026\u0026 -1 !== a2 ? ++a2 : a2 = -1;\n      }\n      return n2;\n    }\n    var n = { resolve: function() {\n      for (var t3, n2 = \"\", o = false, i = arguments.length - 1; i \u003e= -1 \u0026\u0026 !o; i--) {\n        var a2;\n        i \u003e= 0 ? a2 = arguments[i] : (void 0 === t3 \u0026\u0026 (t3 = __Process$.cwd()), a2 = t3), e2(a2), 0 !== a2.length \u0026\u0026 (n2 = a2 + \"/\" + n2, o = 47 === a2.charCodeAt(0));\n      }\n      return n2 = r2(n2, !o), o ? n2.length \u003e 0 ? \"/\" + n2 : \"/\" : n2.length \u003e 0 ? n2 : \".\";\n    }, normalize: function(t3) {\n      if (e2(t3), 0 === t3.length)\n        return \".\";\n      var n2 = 47 === t3.charCodeAt(0), o = 47 === t3.charCodeAt(t3.length - 1);\n      return 0 !== (t3 = r2(t3, !n2)).length || n2 || (t3 = \".\"), t3.length \u003e 0 \u0026\u0026 o \u0026\u0026 (t3 += \"/\"), n2 ? \"/\" + t3 : t3;\n    }, isAbsolute: function(t3) {\n      return e2(t3), t3.length \u003e 0 \u0026\u0026 47 === t3.charCodeAt(0);\n    }, join: function() {\n      if (0 === arguments.length)\n        return \".\";\n      for (var t3, r3 = 0; r3 \u003c arguments.length; ++r3) {\n        var o = arguments[r3];\n        e2(o), o.length \u003e 0 \u0026\u0026 (void 0 === t3 ? t3 = o : t3 += \"/\" + o);\n      }\n      return void 0 === t3 ? \".\" : n.normalize(t3);\n    }, relative: function(t3, r3) {\n      if (e2(t3), e2(r3), t3 === r3)\n        return \"\";\n      if ((t3 = n.resolve(t3)) === (r3 = n.resolve(r3)))\n        return \"\";\n      for (var o = 1; o \u003c t3.length \u0026\u0026 47 === t3.charCodeAt(o); ++o)\n        ;\n      for (var i = t3.length, a2 = i - o, h = 1; h \u003c r3.length \u0026\u0026 47 === r3.charCodeAt(h); ++h)\n        ;\n      for (var s = r3.length - h, c = a2 \u003c s ? a2 : s, f2 = -1, u = 0; u \u003c= c; ++u) {\n        if (u === c) {\n          if (s \u003e c) {\n            if (47 === r3.charCodeAt(h + u))\n              return r3.slice(h + u + 1);\n            if (0 === u)\n              return r3.slice(h + u);\n          } else\n            a2 \u003e c \u0026\u0026 (47 === t3.charCodeAt(o + u) ? f2 = u : 0 === u \u0026\u0026 (f2 = 0));\n          break;\n        }\n        var l = t3.charCodeAt(o + u);\n        if (l !== r3.charCodeAt(h + u))\n          break;\n        47 === l \u0026\u0026 (f2 = u);\n      }\n      var p = \"\";\n      for (u = o + f2 + 1; u \u003c= i; ++u)\n        u !== i \u0026\u0026 47 !== t3.charCodeAt(u) || (0 === p.length ? p += \"..\" : p += \"/..\");\n      return p.length \u003e 0 ? p + r3.slice(h + f2) : (h += f2, 47 === r3.charCodeAt(h) \u0026\u0026 ++h, r3.slice(h));\n    }, _makeLong: function(t3) {\n      return t3;\n    }, dirname: function(t3) {\n      if (e2(t3), 0 === t3.length)\n        return \".\";\n      for (var r3 = t3.charCodeAt(0), n2 = 47 === r3, o = -1, i = true, a2 = t3.length - 1; a2 \u003e= 1; --a2)\n        if (47 === (r3 = t3.charCodeAt(a2))) {\n          if (!i) {\n            o = a2;\n            break;\n          }\n        } else\n          i = false;\n      return -1 === o ? n2 ? \"/\" : \".\" : n2 \u0026\u0026 1 === o ? \"//\" : t3.slice(0, o);\n    }, basename: function(t3, r3) {\n      if (void 0 !== r3 \u0026\u0026 \"string\" != typeof r3)\n        throw new TypeError('\"ext\" argument must be a string');\n      e2(t3);\n      var n2, o = 0, i = -1, a2 = true;\n      if (void 0 !== r3 \u0026\u0026 r3.length \u003e 0 \u0026\u0026 r3.length \u003c= t3.length) {\n        if (r3.length === t3.length \u0026\u0026 r3 === t3)\n          return \"\";\n        var h = r3.length - 1, s = -1;\n        for (n2 = t3.length - 1; n2 \u003e= 0; --n2) {\n          var c = t3.charCodeAt(n2);\n          if (47 === c) {\n            if (!a2) {\n              o = n2 + 1;\n              break;\n            }\n          } else\n            -1 === s \u0026\u0026 (a2 = false, s = n2 + 1), h \u003e= 0 \u0026\u0026 (c === r3.charCodeAt(h) ? -1 == --h \u0026\u0026 (i = n2) : (h = -1, i = s));\n        }\n        return o === i ? i = s : -1 === i \u0026\u0026 (i = t3.length), t3.slice(o, i);\n      }\n      for (n2 = t3.length - 1; n2 \u003e= 0; --n2)\n        if (47 === t3.charCodeAt(n2)) {\n          if (!a2) {\n            o = n2 + 1;\n            break;\n          }\n        } else\n          -1 === i \u0026\u0026 (a2 = false, i = n2 + 1);\n      return -1 === i ? \"\" : t3.slice(o, i);\n    }, extname: function(t3) {\n      e2(t3);\n      for (var r3 = -1, n2 = 0, o = -1, i = true, a2 = 0, h = t3.length - 1; h \u003e= 0; --h) {\n        var s = t3.charCodeAt(h);\n        if (47 !== s)\n          -1 === o \u0026\u0026 (i = false, o = h + 1), 46 === s ? -1 === r3 ? r3 = h : 1 !== a2 \u0026\u0026 (a2 = 1) : -1 !== r3 \u0026\u0026 (a2 = -1);\n        else if (!i) {\n          n2 = h + 1;\n          break;\n        }\n      }\n      return -1 === r3 || -1 === o || 0 === a2 || 1 === a2 \u0026\u0026 r3 === o - 1 \u0026\u0026 r3 === n2 + 1 ? \"\" : t3.slice(r3, o);\n    }, format: function(t3) {\n      if (null === t3 || \"object\" != typeof t3)\n        throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof t3);\n      return function(t4, e3) {\n        var r3 = e3.dir || e3.root, n2 = e3.base || (e3.name || \"\") + (e3.ext || \"\");\n        return r3 ? r3 === e3.root ? r3 + n2 : r3 + \"/\" + n2 : n2;\n      }(0, t3);\n    }, parse: function(t3) {\n      e2(t3);\n      var r3 = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n      if (0 === t3.length)\n        return r3;\n      var n2, o = t3.charCodeAt(0), i = 47 === o;\n      i ? (r3.root = \"/\", n2 = 1) : n2 = 0;\n      for (var a2 = -1, h = 0, s = -1, c = true, f2 = t3.length - 1, u = 0; f2 \u003e= n2; --f2)\n        if (47 !== (o = t3.charCodeAt(f2)))\n          -1 === s \u0026\u0026 (c = false, s = f2 + 1), 46 === o ? -1 === a2 ? a2 = f2 : 1 !== u \u0026\u0026 (u = 1) : -1 !== a2 \u0026\u0026 (u = -1);\n        else if (!c) {\n          h = f2 + 1;\n          break;\n        }\n      return -1 === a2 || -1 === s || 0 === u || 1 === u \u0026\u0026 a2 === s - 1 \u0026\u0026 a2 === h + 1 ? -1 !== s \u0026\u0026 (r3.base = r3.name = 0 === h \u0026\u0026 i ? t3.slice(1, s) : t3.slice(h, s)) : (0 === h \u0026\u0026 i ? (r3.name = t3.slice(1, a2), r3.base = t3.slice(1, s)) : (r3.name = t3.slice(h, a2), r3.base = t3.slice(h, s)), r3.ext = t3.slice(a2, s)), h \u003e 0 ? r3.dir = t3.slice(0, h - 1) : i \u0026\u0026 (r3.dir = \"/\"), r3;\n    }, sep: \"/\", delimiter: \":\", win32: null, posix: null };\n    n.posix = n, t2.exports = n;\n  }, 447: (t2, e2, r2) =\u003e {\n    var n;\n    if (r2.r(e2), r2.d(e2, { URI: () =\u003e d, Utils: () =\u003e P }), \"object\" == typeof __Process$)\n      n = \"win32\" === __Process$.platform;\n    else if (\"object\" == typeof navigator) {\n      var o = navigator.userAgent;\n      n = o.indexOf(\"Windows\") \u003e= 0;\n    }\n    var i, a2, h = (i = function(t3, e3) {\n      return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array \u0026\u0026 function(t4, e4) {\n        t4.__proto__ = e4;\n      } || function(t4, e4) {\n        for (var r3 in e4)\n          Object.prototype.hasOwnProperty.call(e4, r3) \u0026\u0026 (t4[r3] = e4[r3]);\n      })(t3, e3);\n    }, function(t3, e3) {\n      if (\"function\" != typeof e3 \u0026\u0026 null !== e3)\n        throw new TypeError(\"Class extends value \" + String(e3) + \" is not a constructor or null\");\n      function r3() {\n        this.constructor = t3;\n      }\n      i(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (r3.prototype = e3.prototype, new r3());\n    }), s = /^\\w[\\w\\d+.-]*$/, c = /^\\//, f2 = /^\\/\\//;\n    function u(t3, e3) {\n      if (!t3.scheme \u0026\u0026 e3)\n        throw new Error('[UriError]: Scheme is missing: {scheme: \"\", authority: \"'.concat(t3.authority, '\", path: \"').concat(t3.path, '\", query: \"').concat(t3.query, '\", fragment: \"').concat(t3.fragment, '\"}'));\n      if (t3.scheme \u0026\u0026 !s.test(t3.scheme))\n        throw new Error(\"[UriError]: Scheme contains illegal characters.\");\n      if (t3.path) {\n        if (t3.authority) {\n          if (!c.test(t3.path))\n            throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n        } else if (f2.test(t3.path))\n          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n      }\n    }\n    var l = \"\", p = \"/\", g = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/, d = function() {\n      function t3(t4, e3, r3, n2, o2, i2) {\n        void 0 === i2 \u0026\u0026 (i2 = false), \"object\" == typeof t4 ? (this.scheme = t4.scheme || l, this.authority = t4.authority || l, this.path = t4.path || l, this.query = t4.query || l, this.fragment = t4.fragment || l) : (this.scheme = /* @__PURE__ */ function(t5, e4) {\n          return t5 || e4 ? t5 : \"file\";\n        }(t4, i2), this.authority = e3 || l, this.path = function(t5, e4) {\n          switch (t5) {\n            case \"https\":\n            case \"http\":\n            case \"file\":\n              e4 ? e4[0] !== p \u0026\u0026 (e4 = p + e4) : e4 = p;\n          }\n          return e4;\n        }(this.scheme, r3 || l), this.query = n2 || l, this.fragment = o2 || l, u(this, i2));\n      }\n      return t3.isUri = function(e3) {\n        return e3 instanceof t3 || !!e3 \u0026\u0026 \"string\" == typeof e3.authority \u0026\u0026 \"string\" == typeof e3.fragment \u0026\u0026 \"string\" == typeof e3.path \u0026\u0026 \"string\" == typeof e3.query \u0026\u0026 \"string\" == typeof e3.scheme \u0026\u0026 \"string\" == typeof e3.fsPath \u0026\u0026 \"function\" == typeof e3.with \u0026\u0026 \"function\" == typeof e3.toString;\n      }, Object.defineProperty(t3.prototype, \"fsPath\", { get: function() {\n        return A2(this, false);\n      }, enumerable: false, configurable: true }), t3.prototype.with = function(t4) {\n        if (!t4)\n          return this;\n        var e3 = t4.scheme, r3 = t4.authority, n2 = t4.path, o2 = t4.query, i2 = t4.fragment;\n        return void 0 === e3 ? e3 = this.scheme : null === e3 \u0026\u0026 (e3 = l), void 0 === r3 ? r3 = this.authority : null === r3 \u0026\u0026 (r3 = l), void 0 === n2 ? n2 = this.path : null === n2 \u0026\u0026 (n2 = l), void 0 === o2 ? o2 = this.query : null === o2 \u0026\u0026 (o2 = l), void 0 === i2 ? i2 = this.fragment : null === i2 \u0026\u0026 (i2 = l), e3 === this.scheme \u0026\u0026 r3 === this.authority \u0026\u0026 n2 === this.path \u0026\u0026 o2 === this.query \u0026\u0026 i2 === this.fragment ? this : new y(e3, r3, n2, o2, i2);\n      }, t3.parse = function(t4, e3) {\n        void 0 === e3 \u0026\u0026 (e3 = false);\n        var r3 = g.exec(t4);\n        return r3 ? new y(r3[2] || l, O(r3[4] || l), O(r3[5] || l), O(r3[7] || l), O(r3[9] || l), e3) : new y(l, l, l, l, l);\n      }, t3.file = function(t4) {\n        var e3 = l;\n        if (n \u0026\u0026 (t4 = t4.replace(/\\\\/g, p)), t4[0] === p \u0026\u0026 t4[1] === p) {\n          var r3 = t4.indexOf(p, 2);\n          -1 === r3 ? (e3 = t4.substring(2), t4 = p) : (e3 = t4.substring(2, r3), t4 = t4.substring(r3) || p);\n        }\n        return new y(\"file\", e3, t4, l, l);\n      }, t3.from = function(t4) {\n        var e3 = new y(t4.scheme, t4.authority, t4.path, t4.query, t4.fragment);\n        return u(e3, true), e3;\n      }, t3.prototype.toString = function(t4) {\n        return void 0 === t4 \u0026\u0026 (t4 = false), w(this, t4);\n      }, t3.prototype.toJSON = function() {\n        return this;\n      }, t3.revive = function(e3) {\n        if (e3) {\n          if (e3 instanceof t3)\n            return e3;\n          var r3 = new y(e3);\n          return r3._formatted = e3.external, r3._fsPath = e3._sep === v ? e3.fsPath : null, r3;\n        }\n        return e3;\n      }, t3;\n    }(), v = n ? 1 : void 0, y = function(t3) {\n      function e3() {\n        var e4 = null !== t3 \u0026\u0026 t3.apply(this, arguments) || this;\n        return e4._formatted = null, e4._fsPath = null, e4;\n      }\n      return h(e3, t3), Object.defineProperty(e3.prototype, \"fsPath\", { get: function() {\n        return this._fsPath || (this._fsPath = A2(this, false)), this._fsPath;\n      }, enumerable: false, configurable: true }), e3.prototype.toString = function(t4) {\n        return void 0 === t4 \u0026\u0026 (t4 = false), t4 ? w(this, true) : (this._formatted || (this._formatted = w(this, false)), this._formatted);\n      }, e3.prototype.toJSON = function() {\n        var t4 = { $mid: 1 };\n        return this._fsPath \u0026\u0026 (t4.fsPath = this._fsPath, t4._sep = v), this._formatted \u0026\u0026 (t4.external = this._formatted), this.path \u0026\u0026 (t4.path = this.path), this.scheme \u0026\u0026 (t4.scheme = this.scheme), this.authority \u0026\u0026 (t4.authority = this.authority), this.query \u0026\u0026 (t4.query = this.query), this.fragment \u0026\u0026 (t4.fragment = this.fragment), t4;\n      }, e3;\n    }(d), m = ((a2 = {})[58] = \"%3A\", a2[47] = \"%2F\", a2[63] = \"%3F\", a2[35] = \"%23\", a2[91] = \"%5B\", a2[93] = \"%5D\", a2[64] = \"%40\", a2[33] = \"%21\", a2[36] = \"%24\", a2[38] = \"%26\", a2[39] = \"%27\", a2[40] = \"%28\", a2[41] = \"%29\", a2[42] = \"%2A\", a2[43] = \"%2B\", a2[44] = \"%2C\", a2[59] = \"%3B\", a2[61] = \"%3D\", a2[32] = \"%20\", a2);\n    function b(t3, e3) {\n      for (var r3 = void 0, n2 = -1, o2 = 0; o2 \u003c t3.length; o2++) {\n        var i2 = t3.charCodeAt(o2);\n        if (i2 \u003e= 97 \u0026\u0026 i2 \u003c= 122 || i2 \u003e= 65 \u0026\u0026 i2 \u003c= 90 || i2 \u003e= 48 \u0026\u0026 i2 \u003c= 57 || 45 === i2 || 46 === i2 || 95 === i2 || 126 === i2 || e3 \u0026\u0026 47 === i2)\n          -1 !== n2 \u0026\u0026 (r3 += encodeURIComponent(t3.substring(n2, o2)), n2 = -1), void 0 !== r3 \u0026\u0026 (r3 += t3.charAt(o2));\n        else {\n          void 0 === r3 \u0026\u0026 (r3 = t3.substr(0, o2));\n          var a3 = m[i2];\n          void 0 !== a3 ? (-1 !== n2 \u0026\u0026 (r3 += encodeURIComponent(t3.substring(n2, o2)), n2 = -1), r3 += a3) : -1 === n2 \u0026\u0026 (n2 = o2);\n        }\n      }\n      return -1 !== n2 \u0026\u0026 (r3 += encodeURIComponent(t3.substring(n2))), void 0 !== r3 ? r3 : t3;\n    }\n    function C(t3) {\n      for (var e3 = void 0, r3 = 0; r3 \u003c t3.length; r3++) {\n        var n2 = t3.charCodeAt(r3);\n        35 === n2 || 63 === n2 ? (void 0 === e3 \u0026\u0026 (e3 = t3.substr(0, r3)), e3 += m[n2]) : void 0 !== e3 \u0026\u0026 (e3 += t3[r3]);\n      }\n      return void 0 !== e3 ? e3 : t3;\n    }\n    function A2(t3, e3) {\n      var r3;\n      return r3 = t3.authority \u0026\u0026 t3.path.length \u003e 1 \u0026\u0026 \"file\" === t3.scheme ? \"//\".concat(t3.authority).concat(t3.path) : 47 === t3.path.charCodeAt(0) \u0026\u0026 (t3.path.charCodeAt(1) \u003e= 65 \u0026\u0026 t3.path.charCodeAt(1) \u003c= 90 || t3.path.charCodeAt(1) \u003e= 97 \u0026\u0026 t3.path.charCodeAt(1) \u003c= 122) \u0026\u0026 58 === t3.path.charCodeAt(2) ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, n \u0026\u0026 (r3 = r3.replace(/\\//g, \"\\\\\")), r3;\n    }\n    function w(t3, e3) {\n      var r3 = e3 ? C : b, n2 = \"\", o2 = t3.scheme, i2 = t3.authority, a3 = t3.path, h2 = t3.query, s2 = t3.fragment;\n      if (o2 \u0026\u0026 (n2 += o2, n2 += \":\"), (i2 || \"file\" === o2) \u0026\u0026 (n2 += p, n2 += p), i2) {\n        var c2 = i2.indexOf(\"@\");\n        if (-1 !== c2) {\n          var f3 = i2.substr(0, c2);\n          i2 = i2.substr(c2 + 1), -1 === (c2 = f3.indexOf(\":\")) ? n2 += r3(f3, false) : (n2 += r3(f3.substr(0, c2), false), n2 += \":\", n2 += r3(f3.substr(c2 + 1), false)), n2 += \"@\";\n        }\n        -1 === (c2 = (i2 = i2.toLowerCase()).indexOf(\":\")) ? n2 += r3(i2, false) : (n2 += r3(i2.substr(0, c2), false), n2 += i2.substr(c2));\n      }\n      if (a3) {\n        if (a3.length \u003e= 3 \u0026\u0026 47 === a3.charCodeAt(0) \u0026\u0026 58 === a3.charCodeAt(2))\n          (u2 = a3.charCodeAt(1)) \u003e= 65 \u0026\u0026 u2 \u003c= 90 \u0026\u0026 (a3 = \"/\".concat(String.fromCharCode(u2 + 32), \":\").concat(a3.substr(3)));\n        else if (a3.length \u003e= 2 \u0026\u0026 58 === a3.charCodeAt(1)) {\n          var u2;\n          (u2 = a3.charCodeAt(0)) \u003e= 65 \u0026\u0026 u2 \u003c= 90 \u0026\u0026 (a3 = \"\".concat(String.fromCharCode(u2 + 32), \":\").concat(a3.substr(2)));\n        }\n        n2 += r3(a3, true);\n      }\n      return h2 \u0026\u0026 (n2 += \"?\", n2 += r3(h2, false)), s2 \u0026\u0026 (n2 += \"#\", n2 += e3 ? s2 : b(s2, false)), n2;\n    }\n    function x(t3) {\n      try {\n        return decodeURIComponent(t3);\n      } catch (e3) {\n        return t3.length \u003e 3 ? t3.substr(0, 3) + x(t3.substr(3)) : t3;\n      }\n    }\n    var _ = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n    function O(t3) {\n      return t3.match(_) ? t3.replace(_, function(t4) {\n        return x(t4);\n      }) : t3;\n    }\n    var P, j = r2(470), U = function(t3, e3, r3) {\n      if (r3 || 2 === arguments.length)\n        for (var n2, o2 = 0, i2 = e3.length; o2 \u003c i2; o2++)\n          !n2 \u0026\u0026 o2 in e3 || (n2 || (n2 = Array.prototype.slice.call(e3, 0, o2)), n2[o2] = e3[o2]);\n      return t3.concat(n2 || Array.prototype.slice.call(e3));\n    }, I = j.posix || j;\n    !function(t3) {\n      t3.joinPath = function(t4) {\n        for (var e3 = [], r3 = 1; r3 \u003c arguments.length; r3++)\n          e3[r3 - 1] = arguments[r3];\n        return t4.with({ path: I.join.apply(I, U([t4.path], e3, false)) });\n      }, t3.resolvePath = function(t4) {\n        for (var e3 = [], r3 = 1; r3 \u003c arguments.length; r3++)\n          e3[r3 - 1] = arguments[r3];\n        var n2 = t4.path || \"/\";\n        return t4.with({ path: I.resolve.apply(I, U([n2], e3, false)) });\n      }, t3.dirname = function(t4) {\n        var e3 = I.dirname(t4.path);\n        return 1 === e3.length \u0026\u0026 46 === e3.charCodeAt(0) ? t4 : t4.with({ path: e3 });\n      }, t3.basename = function(t4) {\n        return I.basename(t4.path);\n      }, t3.extname = function(t4) {\n        return I.extname(t4.path);\n      };\n    }(P || (P = {}));\n  } }, e = {};\n  function r(n) {\n    if (e[n])\n      return e[n].exports;\n    var o = e[n] = { exports: {} };\n    return t[n](o, o.exports, r), o.exports;\n  }\n  return r.d = (t2, e2) =\u003e {\n    for (var n in e2)\n      r.o(e2, n) \u0026\u0026 !r.o(t2, n) \u0026\u0026 Object.defineProperty(t2, n, { enumerable: true, get: e2[n] });\n  }, r.o = (t2, e2) =\u003e Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) =\u003e {\n    \"undefined\" != typeof Symbol \u0026\u0026 Symbol.toStringTag \u0026\u0026 Object.defineProperty(t2, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(t2, \"__esModule\", { value: true });\n  }, r(447);\n})();\nvar { URI: URI2, Utils } = LIB;\nfunction createRegex(glob, opts) {\n  if (typeof glob !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  var str = String(glob);\n  var reStr = \"\";\n  var extended = opts ? !!opts.extended : false;\n  var globstar = opts ? !!opts.globstar : false;\n  var inGroup = false;\n  var flags = opts \u0026\u0026 typeof opts.flags === \"string\" ? opts.flags : \"\";\n  var c;\n  for (var i = 0, len = str.length; i \u003c len; i++) {\n    c = str[i];\n    switch (c) {\n      case \"/\":\n      case \"$\":\n      case \"^\":\n      case \"+\":\n      case \".\":\n      case \"(\":\n      case \")\":\n      case \"=\":\n      case \"!\":\n      case \"|\":\n        reStr += \"\\\\\" + c;\n        break;\n      case \"?\":\n        if (extended) {\n          reStr += \".\";\n          break;\n        }\n      case \"[\":\n      case \"]\":\n        if (extended) {\n          reStr += c;\n          break;\n        }\n      case \"{\":\n        if (extended) {\n          inGroup = true;\n          reStr += \"(\";\n          break;\n        }\n      case \"}\":\n        if (extended) {\n          inGroup = false;\n          reStr += \")\";\n          break;\n        }\n      case \",\":\n        if (inGroup) {\n          reStr += \"|\";\n          break;\n        }\n        reStr += \"\\\\\" + c;\n        break;\n      case \"*\":\n        var prevChar = str[i - 1];\n        var starCount = 1;\n        while (str[i + 1] === \"*\") {\n          starCount++;\n          i++;\n        }\n        var nextChar = str[i + 1];\n        if (!globstar) {\n          reStr += \".*\";\n        } else {\n          var isGlobstar = starCount \u003e 1 \u0026\u0026 (prevChar === \"/\" || prevChar === void 0 || prevChar === \"{\" || prevChar === \",\") \u0026\u0026 (nextChar === \"/\" || nextChar === void 0 || nextChar === \",\" || nextChar === \"}\");\n          if (isGlobstar) {\n            if (nextChar === \"/\") {\n              i++;\n            } else if (prevChar === \"/\" \u0026\u0026 reStr.endsWith(\"\\\\/\")) {\n              reStr = reStr.substr(0, reStr.length - 2);\n            }\n            reStr += \"((?:[^/]*(?:/|$))*)\";\n          } else {\n            reStr += \"([^/]*)\";\n          }\n        }\n        break;\n      default:\n        reStr += c;\n    }\n  }\n  if (!flags || !~flags.indexOf(\"g\")) {\n    reStr = \"^\" + reStr + \"$\";\n  }\n  return new RegExp(reStr, flags);\n}\nvar localize6 = loadMessageBundle();\nvar BANG = \"!\";\nvar PATH_SEP = \"/\";\nvar FilePatternAssociation = function() {\n  function FilePatternAssociation2(pattern, uris) {\n    this.globWrappers = [];\n    try {\n      for (var _i = 0, pattern_1 = pattern; _i \u003c pattern_1.length; _i++) {\n        var patternString = pattern_1[_i];\n        var include = patternString[0] !== BANG;\n        if (!include) {\n          patternString = patternString.substring(1);\n        }\n        if (patternString.length \u003e 0) {\n          if (patternString[0] === PATH_SEP) {\n            patternString = patternString.substring(1);\n          }\n          this.globWrappers.push({\n            regexp: createRegex(\"**/\" + patternString, { extended: true, globstar: true }),\n            include\n          });\n        }\n      }\n      ;\n      this.uris = uris;\n    } catch (e) {\n      this.globWrappers.length = 0;\n      this.uris = [];\n    }\n  }\n  FilePatternAssociation2.prototype.matchesPattern = function(fileName) {\n    var match = false;\n    for (var _i = 0, _a4 = this.globWrappers; _i \u003c _a4.length; _i++) {\n      var _b2 = _a4[_i], regexp = _b2.regexp, include = _b2.include;\n      if (regexp.test(fileName)) {\n        match = include;\n      }\n    }\n    return match;\n  };\n  FilePatternAssociation2.prototype.getURIs = function() {\n    return this.uris;\n  };\n  return FilePatternAssociation2;\n}();\nvar SchemaHandle = function() {\n  function SchemaHandle2(service, uri, unresolvedSchemaContent) {\n    this.service = service;\n    this.uri = uri;\n    this.dependencies = /* @__PURE__ */ new Set();\n    this.anchors = void 0;\n    if (unresolvedSchemaContent) {\n      this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));\n    }\n  }\n  SchemaHandle2.prototype.getUnresolvedSchema = function() {\n    if (!this.unresolvedSchema) {\n      this.unresolvedSchema = this.service.loadSchema(this.uri);\n    }\n    return this.unresolvedSchema;\n  };\n  SchemaHandle2.prototype.getResolvedSchema = function() {\n    var _this = this;\n    if (!this.resolvedSchema) {\n      this.resolvedSchema = this.getUnresolvedSchema().then(function(unresolved) {\n        return _this.service.resolveSchemaContent(unresolved, _this);\n      });\n    }\n    return this.resolvedSchema;\n  };\n  SchemaHandle2.prototype.clearSchema = function() {\n    var hasChanges = !!this.unresolvedSchema;\n    this.resolvedSchema = void 0;\n    this.unresolvedSchema = void 0;\n    this.dependencies.clear();\n    this.anchors = void 0;\n    return hasChanges;\n  };\n  return SchemaHandle2;\n}();\nvar UnresolvedSchema = /* @__PURE__ */ function() {\n  function UnresolvedSchema2(schema2, errors) {\n    if (errors === void 0) {\n      errors = [];\n    }\n    this.schema = schema2;\n    this.errors = errors;\n  }\n  return UnresolvedSchema2;\n}();\nvar ResolvedSchema = function() {\n  function ResolvedSchema2(schema2, errors) {\n    if (errors === void 0) {\n      errors = [];\n    }\n    this.schema = schema2;\n    this.errors = errors;\n  }\n  ResolvedSchema2.prototype.getSection = function(path) {\n    var schemaRef = this.getSectionRecursive(path, this.schema);\n    if (schemaRef) {\n      return asSchema(schemaRef);\n    }\n    return void 0;\n  };\n  ResolvedSchema2.prototype.getSectionRecursive = function(path, schema2) {\n    if (!schema2 || typeof schema2 === \"boolean\" || path.length === 0) {\n      return schema2;\n    }\n    var next = path.shift();\n    if (schema2.properties \u0026\u0026 typeof schema2.properties[next]) {\n      return this.getSectionRecursive(path, schema2.properties[next]);\n    } else if (schema2.patternProperties) {\n      for (var _i = 0, _a4 = Object.keys(schema2.patternProperties); _i \u003c _a4.length; _i++) {\n        var pattern = _a4[_i];\n        var regex = extendedRegExp(pattern);\n        if (regex === null || regex === void 0 ? void 0 : regex.test(next)) {\n          return this.getSectionRecursive(path, schema2.patternProperties[pattern]);\n        }\n      }\n    } else if (typeof schema2.additionalProperties === \"object\") {\n      return this.getSectionRecursive(path, schema2.additionalProperties);\n    } else if (next.match(\"[0-9]+\")) {\n      if (Array.isArray(schema2.items)) {\n        var index = parseInt(next, 10);\n        if (!isNaN(index) \u0026\u0026 schema2.items[index]) {\n          return this.getSectionRecursive(path, schema2.items[index]);\n        }\n      } else if (schema2.items) {\n        return this.getSectionRecursive(path, schema2.items);\n      }\n    }\n    return void 0;\n  };\n  return ResolvedSchema2;\n}();\nvar JSONSchemaService = function() {\n  function JSONSchemaService2(requestService, contextService, promiseConstructor) {\n    this.contextService = contextService;\n    this.requestService = requestService;\n    this.promiseConstructor = promiseConstructor || Promise;\n    this.callOnDispose = [];\n    this.contributionSchemas = {};\n    this.contributionAssociations = [];\n    this.schemasById = {};\n    this.filePatternAssociations = [];\n    this.registeredSchemasIds = {};\n  }\n  JSONSchemaService2.prototype.getRegisteredSchemaIds = function(filter) {\n    return Object.keys(this.registeredSchemasIds).filter(function(id) {\n      var scheme = URI2.parse(id).scheme;\n      return scheme !== \"schemaservice\" \u0026\u0026 (!filter || filter(scheme));\n    });\n  };\n  Object.defineProperty(JSONSchemaService2.prototype, \"promise\", {\n    get: function() {\n      return this.promiseConstructor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  JSONSchemaService2.prototype.dispose = function() {\n    while (this.callOnDispose.length \u003e 0) {\n      this.callOnDispose.pop()();\n    }\n  };\n  JSONSchemaService2.prototype.onResourceChange = function(uri) {\n    var _this = this;\n    this.cachedSchemaForResource = void 0;\n    var hasChanges = false;\n    uri = normalizeId(uri);\n    var toWalk = [uri];\n    var all = Object.keys(this.schemasById).map(function(key) {\n      return _this.schemasById[key];\n    });\n    while (toWalk.length) {\n      var curr = toWalk.pop();\n      for (var i = 0; i \u003c all.length; i++) {\n        var handle = all[i];\n        if (handle \u0026\u0026 (handle.uri === curr || handle.dependencies.has(curr))) {\n          if (handle.uri !== curr) {\n            toWalk.push(handle.uri);\n          }\n          if (handle.clearSchema()) {\n            hasChanges = true;\n          }\n          all[i] = void 0;\n        }\n      }\n    }\n    return hasChanges;\n  };\n  JSONSchemaService2.prototype.setSchemaContributions = function(schemaContributions2) {\n    if (schemaContributions2.schemas) {\n      var schemas = schemaContributions2.schemas;\n      for (var id in schemas) {\n        var normalizedId = normalizeId(id);\n        this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);\n      }\n    }\n    if (Array.isArray(schemaContributions2.schemaAssociations)) {\n      var schemaAssociations = schemaContributions2.schemaAssociations;\n      for (var _i = 0, schemaAssociations_1 = schemaAssociations; _i \u003c schemaAssociations_1.length; _i++) {\n        var schemaAssociation = schemaAssociations_1[_i];\n        var uris = schemaAssociation.uris.map(normalizeId);\n        var association = this.addFilePatternAssociation(schemaAssociation.pattern, uris);\n        this.contributionAssociations.push(association);\n      }\n    }\n  };\n  JSONSchemaService2.prototype.addSchemaHandle = function(id, unresolvedSchemaContent) {\n    var schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);\n    this.schemasById[id] = schemaHandle;\n    return schemaHandle;\n  };\n  JSONSchemaService2.prototype.getOrAddSchemaHandle = function(id, unresolvedSchemaContent) {\n    return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);\n  };\n  JSONSchemaService2.prototype.addFilePatternAssociation = function(pattern, uris) {\n    var fpa = new FilePatternAssociation(pattern, uris);\n    this.filePatternAssociations.push(fpa);\n    return fpa;\n  };\n  JSONSchemaService2.prototype.registerExternalSchema = function(uri, filePatterns, unresolvedSchemaContent) {\n    var id = normalizeId(uri);\n    this.registeredSchemasIds[id] = true;\n    this.cachedSchemaForResource = void 0;\n    if (filePatterns) {\n      this.addFilePatternAssociation(filePatterns, [id]);\n    }\n    return unresolvedSchemaContent ? this.addSchemaHandle(id, unresolvedSchemaContent) : this.getOrAddSchemaHandle(id);\n  };\n  JSONSchemaService2.prototype.clearExternalSchemas = function() {\n    this.schemasById = {};\n    this.filePatternAssociations = [];\n    this.registeredSchemasIds = {};\n    this.cachedSchemaForResource = void 0;\n    for (var id in this.contributionSchemas) {\n      this.schemasById[id] = this.contributionSchemas[id];\n      this.registeredSchemasIds[id] = true;\n    }\n    for (var _i = 0, _a4 = this.contributionAssociations; _i \u003c _a4.length; _i++) {\n      var contributionAssociation = _a4[_i];\n      this.filePatternAssociations.push(contributionAssociation);\n    }\n  };\n  JSONSchemaService2.prototype.getResolvedSchema = function(schemaId) {\n    var id = normalizeId(schemaId);\n    var schemaHandle = this.schemasById[id];\n    if (schemaHandle) {\n      return schemaHandle.getResolvedSchema();\n    }\n    return this.promise.resolve(void 0);\n  };\n  JSONSchemaService2.prototype.loadSchema = function(url) {\n    if (!this.requestService) {\n      var errorMessage = localize6(\"json.schema.norequestservice\", \"Unable to load schema from '{0}'. No schema request service available\", toDisplayString(url));\n      return this.promise.resolve(new UnresolvedSchema({}, [errorMessage]));\n    }\n    return this.requestService(url).then(function(content) {\n      if (!content) {\n        var errorMessage2 = localize6(\"json.schema.nocontent\", \"Unable to load schema from '{0}': No content.\", toDisplayString(url));\n        return new UnresolvedSchema({}, [errorMessage2]);\n      }\n      var schemaContent = {};\n      var jsonErrors = [];\n      schemaContent = parse2(content, jsonErrors);\n      var errors = jsonErrors.length ? [localize6(\"json.schema.invalidFormat\", \"Unable to parse content from '{0}': Parse error at offset {1}.\", toDisplayString(url), jsonErrors[0].offset)] : [];\n      return new UnresolvedSchema(schemaContent, errors);\n    }, function(error) {\n      var errorMessage2 = error.toString();\n      var errorSplit = error.toString().split(\"Error: \");\n      if (errorSplit.length \u003e 1) {\n        errorMessage2 = errorSplit[1];\n      }\n      if (endsWith(errorMessage2, \".\")) {\n        errorMessage2 = errorMessage2.substr(0, errorMessage2.length - 1);\n      }\n      return new UnresolvedSchema({}, [localize6(\"json.schema.nocontent\", \"Unable to load schema from '{0}': {1}.\", toDisplayString(url), errorMessage2)]);\n    });\n  };\n  JSONSchemaService2.prototype.resolveSchemaContent = function(schemaToResolve, handle) {\n    var _this = this;\n    var resolveErrors = schemaToResolve.errors.slice(0);\n    var schema2 = schemaToResolve.schema;\n    if (schema2.$schema) {\n      var id = normalizeId(schema2.$schema);\n      if (id === \"http://json-schema.org/draft-03/schema\") {\n        return this.promise.resolve(new ResolvedSchema({}, [localize6(\"json.schema.draft03.notsupported\", \"Draft-03 schemas are not supported.\")]));\n      } else if (id === \"https://json-schema.org/draft/2019-09/schema\") {\n        resolveErrors.push(localize6(\"json.schema.draft201909.notsupported\", \"Draft 2019-09 schemas are not yet fully supported.\"));\n      } else if (id === \"https://json-schema.org/draft/2020-12/schema\") {\n        resolveErrors.push(localize6(\"json.schema.draft202012.notsupported\", \"Draft 2020-12 schemas are not yet fully supported.\"));\n      }\n    }\n    var contextService = this.contextService;\n    var findSectionByJSONPointer = function(schema22, path) {\n      path = decodeURIComponent(path);\n      var current = schema22;\n      if (path[0] === \"/\") {\n        path = path.substring(1);\n      }\n      path.split(\"/\").some(function(part) {\n        part = part.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n        current = current[part];\n        return !current;\n      });\n      return current;\n    };\n    var findSchemaById = function(schema22, handle2, id2) {\n      if (!handle2.anchors) {\n        handle2.anchors = collectAnchors(schema22);\n      }\n      return handle2.anchors.get(id2);\n    };\n    var merge = function(target, section) {\n      for (var key in section) {\n        if (section.hasOwnProperty(key) \u0026\u0026 !target.hasOwnProperty(key) \u0026\u0026 key !== \"id\" \u0026\u0026 key !== \"$id\") {\n          target[key] = section[key];\n        }\n      }\n    };\n    var mergeRef = function(target, sourceRoot, sourceHandle, refSegment) {\n      var section;\n      if (refSegment === void 0 || refSegment.length === 0) {\n        section = sourceRoot;\n      } else if (refSegment.charAt(0) === \"/\") {\n        section = findSectionByJSONPointer(sourceRoot, refSegment);\n      } else {\n        section = findSchemaById(sourceRoot, sourceHandle, refSegment);\n      }\n      if (section) {\n        merge(target, section);\n      } else {\n        resolveErrors.push(localize6(\"json.schema.invalidid\", \"$ref '{0}' in '{1}' can not be resolved.\", refSegment, sourceHandle.uri));\n      }\n    };\n    var resolveExternalLink = function(node, uri, refSegment, parentHandle) {\n      if (contextService \u0026\u0026 !/^[A-Za-z][A-Za-z0-9+\\-.+]*:\\/\\/.*/.test(uri)) {\n        uri = contextService.resolveRelativePath(uri, parentHandle.uri);\n      }\n      uri = normalizeId(uri);\n      var referencedHandle = _this.getOrAddSchemaHandle(uri);\n      return referencedHandle.getUnresolvedSchema().then(function(unresolvedSchema) {\n        parentHandle.dependencies.add(uri);\n        if (unresolvedSchema.errors.length) {\n          var loc = refSegment ? uri + \"#\" + refSegment : uri;\n          resolveErrors.push(localize6(\"json.schema.problemloadingref\", \"Problems loading reference '{0}': {1}\", loc, unresolvedSchema.errors[0]));\n        }\n        mergeRef(node, unresolvedSchema.schema, referencedHandle, refSegment);\n        return resolveRefs(node, unresolvedSchema.schema, referencedHandle);\n      });\n    };\n    var resolveRefs = function(node, parentSchema, parentHandle) {\n      var openPromises = [];\n      _this.traverseNodes(node, function(next) {\n        var seenRefs = /* @__PURE__ */ new Set();\n        while (next.$ref) {\n          var ref = next.$ref;\n          var segments = ref.split(\"#\", 2);\n          delete next.$ref;\n          if (segments[0].length \u003e 0) {\n            openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentHandle));\n            return;\n          } else {\n            if (!seenRefs.has(ref)) {\n              var id2 = segments[1];\n              mergeRef(next, parentSchema, parentHandle, id2);\n              seenRefs.add(ref);\n            }\n          }\n        }\n      });\n      return _this.promise.all(openPromises);\n    };\n    var collectAnchors = function(root) {\n      var result = /* @__PURE__ */ new Map();\n      _this.traverseNodes(root, function(next) {\n        var id2 = next.$id || next.id;\n        if (typeof id2 === \"string\" \u0026\u0026 id2.charAt(0) === \"#\") {\n          var anchor = id2.substring(1);\n          if (result.has(anchor)) {\n            resolveErrors.push(localize6(\"json.schema.duplicateid\", \"Duplicate id declaration: '{0}'\", id2));\n          } else {\n            result.set(anchor, next);\n          }\n        }\n      });\n      return result;\n    };\n    return resolveRefs(schema2, schema2, handle).then(function(_) {\n      return new ResolvedSchema(schema2, resolveErrors);\n    });\n  };\n  JSONSchemaService2.prototype.traverseNodes = function(root, handle) {\n    if (!root || typeof root !== \"object\") {\n      return Promise.resolve(null);\n    }\n    var seen = /* @__PURE__ */ new Set();\n    var collectEntries = function() {\n      var entries = [];\n      for (var _i = 0; _i \u003c arguments.length; _i++) {\n        entries[_i] = arguments[_i];\n      }\n      for (var _a4 = 0, entries_1 = entries; _a4 \u003c entries_1.length; _a4++) {\n        var entry = entries_1[_a4];\n        if (typeof entry === \"object\") {\n          toWalk.push(entry);\n        }\n      }\n    };\n    var collectMapEntries = function() {\n      var maps = [];\n      for (var _i = 0; _i \u003c arguments.length; _i++) {\n        maps[_i] = arguments[_i];\n      }\n      for (var _a4 = 0, maps_1 = maps; _a4 \u003c maps_1.length; _a4++) {\n        var map = maps_1[_a4];\n        if (typeof map === \"object\") {\n          for (var k in map) {\n            var key = k;\n            var entry = map[key];\n            if (typeof entry === \"object\") {\n              toWalk.push(entry);\n            }\n          }\n        }\n      }\n    };\n    var collectArrayEntries = function() {\n      var arrays = [];\n      for (var _i = 0; _i \u003c arguments.length; _i++) {\n        arrays[_i] = arguments[_i];\n      }\n      for (var _a4 = 0, arrays_1 = arrays; _a4 \u003c arrays_1.length; _a4++) {\n        var array = arrays_1[_a4];\n        if (Array.isArray(array)) {\n          for (var _b2 = 0, array_1 = array; _b2 \u003c array_1.length; _b2++) {\n            var entry = array_1[_b2];\n            if (typeof entry === \"object\") {\n              toWalk.push(entry);\n            }\n          }\n        }\n      }\n    };\n    var toWalk = [root];\n    var next = toWalk.pop();\n    while (next) {\n      if (!seen.has(next)) {\n        seen.add(next);\n        handle(next);\n        collectEntries(next.items, next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);\n        collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);\n        collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items);\n      }\n      next = toWalk.pop();\n    }\n  };\n  ;\n  JSONSchemaService2.prototype.getSchemaFromProperty = function(resource, document2) {\n    var _a4, _b2;\n    if (((_a4 = document2.root) === null || _a4 === void 0 ? void 0 : _a4.type) === \"object\") {\n      for (var _i = 0, _c = document2.root.properties; _i \u003c _c.length; _i++) {\n        var p = _c[_i];\n        if (p.keyNode.value === \"$schema\" \u0026\u0026 ((_b2 = p.valueNode) === null || _b2 === void 0 ? void 0 : _b2.type) === \"string\") {\n          var schemaId = p.valueNode.value;\n          if (this.contextService \u0026\u0026 !/^\\w[\\w\\d+.-]*:/.test(schemaId)) {\n            schemaId = this.contextService.resolveRelativePath(schemaId, resource);\n          }\n          return schemaId;\n        }\n      }\n    }\n    return void 0;\n  };\n  JSONSchemaService2.prototype.getAssociatedSchemas = function(resource) {\n    var seen = /* @__PURE__ */ Object.create(null);\n    var schemas = [];\n    var normalizedResource = normalizeResourceForMatching(resource);\n    for (var _i = 0, _a4 = this.filePatternAssociations; _i \u003c _a4.length; _i++) {\n      var entry = _a4[_i];\n      if (entry.matchesPattern(normalizedResource)) {\n        for (var _b2 = 0, _c = entry.getURIs(); _b2 \u003c _c.length; _b2++) {\n          var schemaId = _c[_b2];\n          if (!seen[schemaId]) {\n            schemas.push(schemaId);\n            seen[schemaId] = true;\n          }\n        }\n      }\n    }\n    return schemas;\n  };\n  JSONSchemaService2.prototype.getSchemaURIsForResource = function(resource, document2) {\n    var schemeId = document2 \u0026\u0026 this.getSchemaFromProperty(resource, document2);\n    if (schemeId) {\n      return [schemeId];\n    }\n    return this.getAssociatedSchemas(resource);\n  };\n  JSONSchemaService2.prototype.getSchemaForResource = function(resource, document2) {\n    if (document2) {\n      var schemeId = this.getSchemaFromProperty(resource, document2);\n      if (schemeId) {\n        var id = normalizeId(schemeId);\n        return this.getOrAddSchemaHandle(id).getResolvedSchema();\n      }\n    }\n    if (this.cachedSchemaForResource \u0026\u0026 this.cachedSchemaForResource.resource === resource) {\n      return this.cachedSchemaForResource.resolvedSchema;\n    }\n    var schemas = this.getAssociatedSchemas(resource);\n    var resolvedSchema = schemas.length \u003e 0 ? this.createCombinedSchema(resource, schemas).getResolvedSchema() : this.promise.resolve(void 0);\n    this.cachedSchemaForResource = { resource, resolvedSchema };\n    return resolvedSchema;\n  };\n  JSONSchemaService2.prototype.createCombinedSchema = function(resource, schemaIds) {\n    if (schemaIds.length === 1) {\n      return this.getOrAddSchemaHandle(schemaIds[0]);\n    } else {\n      var combinedSchemaId = \"schemaservice://combinedSchema/\" + encodeURIComponent(resource);\n      var combinedSchema = {\n        allOf: schemaIds.map(function(schemaId) {\n          return { $ref: schemaId };\n        })\n      };\n      return this.addSchemaHandle(combinedSchemaId, combinedSchema);\n    }\n  };\n  JSONSchemaService2.prototype.getMatchingSchemas = function(document2, jsonDocument, schema2) {\n    if (schema2) {\n      var id = schema2.id || \"schemaservice://untitled/matchingSchemas/\" + idCounter2++;\n      var handle = this.addSchemaHandle(id, schema2);\n      return handle.getResolvedSchema().then(function(resolvedSchema) {\n        return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter(function(s) {\n          return !s.inverted;\n        });\n      });\n    }\n    return this.getSchemaForResource(document2.uri, jsonDocument).then(function(schema22) {\n      if (schema22) {\n        return jsonDocument.getMatchingSchemas(schema22.schema).filter(function(s) {\n          return !s.inverted;\n        });\n      }\n      return [];\n    });\n  };\n  return JSONSchemaService2;\n}();\nvar idCounter2 = 0;\nfunction normalizeId(id) {\n  try {\n    return URI2.parse(id).toString(true);\n  } catch (e) {\n    return id;\n  }\n}\nfunction normalizeResourceForMatching(resource) {\n  try {\n    return URI2.parse(resource).with({ fragment: null, query: null }).toString(true);\n  } catch (e) {\n    return resource;\n  }\n}\nfunction toDisplayString(url) {\n  try {\n    var uri = URI2.parse(url);\n    if (uri.scheme === \"file\") {\n      return uri.fsPath;\n    }\n  } catch (e) {\n  }\n  return url;\n}\nfunction getFoldingRanges(document2, context) {\n  var ranges = [];\n  var nestingLevels = [];\n  var stack = [];\n  var prevStart = -1;\n  var scanner = createScanner2(document2.getText(), false);\n  var token = scanner.scan();\n  function addRange(range2) {\n    ranges.push(range2);\n    nestingLevels.push(stack.length);\n  }\n  while (token !== 17) {\n    switch (token) {\n      case 1:\n      case 3: {\n        var startLine = document2.positionAt(scanner.getTokenOffset()).line;\n        var range = { startLine, endLine: startLine, kind: token === 1 ? \"object\" : \"array\" };\n        stack.push(range);\n        break;\n      }\n      case 2:\n      case 4: {\n        var kind = token === 2 ? \"object\" : \"array\";\n        if (stack.length \u003e 0 \u0026\u0026 stack[stack.length - 1].kind === kind) {\n          var range = stack.pop();\n          var line = document2.positionAt(scanner.getTokenOffset()).line;\n          if (range \u0026\u0026 line \u003e range.startLine + 1 \u0026\u0026 prevStart !== range.startLine) {\n            range.endLine = line - 1;\n            addRange(range);\n            prevStart = range.startLine;\n          }\n        }\n        break;\n      }\n      case 13: {\n        var startLine = document2.positionAt(scanner.getTokenOffset()).line;\n        var endLine = document2.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n        if (scanner.getTokenError() === 1 \u0026\u0026 startLine + 1 \u003c document2.lineCount) {\n          scanner.setPosition(document2.offsetAt(Position2.create(startLine + 1, 0)));\n        } else {\n          if (startLine \u003c endLine) {\n            addRange({ startLine, endLine, kind: FoldingRangeKind2.Comment });\n            prevStart = startLine;\n          }\n        }\n        break;\n      }\n      case 12: {\n        var text = document2.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());\n        var m = text.match(/^\\/\\/\\s*#(region\\b)|(endregion\\b)/);\n        if (m) {\n          var line = document2.positionAt(scanner.getTokenOffset()).line;\n          if (m[1]) {\n            var range = { startLine: line, endLine: line, kind: FoldingRangeKind2.Region };\n            stack.push(range);\n          } else {\n            var i = stack.length - 1;\n            while (i \u003e= 0 \u0026\u0026 stack[i].kind !== FoldingRangeKind2.Region) {\n              i--;\n            }\n            if (i \u003e= 0) {\n              var range = stack[i];\n              stack.length = i;\n              if (line \u003e range.startLine \u0026\u0026 prevStart !== range.startLine) {\n                range.endLine = line;\n                addRange(range);\n                prevStart = range.startLine;\n              }\n            }\n          }\n        }\n        break;\n      }\n    }\n    token = scanner.scan();\n  }\n  var rangeLimit = context \u0026\u0026 context.rangeLimit;\n  if (typeof rangeLimit !== \"number\" || ranges.length \u003c= rangeLimit) {\n    return ranges;\n  }\n  if (context \u0026\u0026 context.onRangeLimitExceeded) {\n    context.onRangeLimitExceeded(document2.uri);\n  }\n  var counts = [];\n  for (var _i = 0, nestingLevels_1 = nestingLevels; _i \u003c nestingLevels_1.length; _i++) {\n    var level = nestingLevels_1[_i];\n    if (level \u003c 30) {\n      counts[level] = (counts[level] || 0) + 1;\n    }\n  }\n  var entries = 0;\n  var maxLevel = 0;\n  for (var i = 0; i \u003c counts.length; i++) {\n    var n = counts[i];\n    if (n) {\n      if (n + entries \u003e rangeLimit) {\n        maxLevel = i;\n        break;\n      }\n      entries += n;\n    }\n  }\n  var result = [];\n  for (var i = 0; i \u003c ranges.length; i++) {\n    var level = nestingLevels[i];\n    if (typeof level === \"number\") {\n      if (level \u003c maxLevel || level === maxLevel \u0026\u0026 entries++ \u003c rangeLimit) {\n        result.push(ranges[i]);\n      }\n    }\n  }\n  return result;\n}\nfunction getSelectionRanges(document2, positions, doc) {\n  function getSelectionRange(position) {\n    var offset = document2.offsetAt(position);\n    var node = doc.getNodeFromOffset(offset, true);\n    var result = [];\n    while (node) {\n      switch (node.type) {\n        case \"string\":\n        case \"object\":\n        case \"array\":\n          var cStart = node.offset + 1, cEnd = node.offset + node.length - 1;\n          if (cStart \u003c cEnd \u0026\u0026 offset \u003e= cStart \u0026\u0026 offset \u003c= cEnd) {\n            result.push(newRange(cStart, cEnd));\n          }\n          result.push(newRange(node.offset, node.offset + node.length));\n          break;\n        case \"number\":\n        case \"boolean\":\n        case \"null\":\n        case \"property\":\n          result.push(newRange(node.offset, node.offset + node.length));\n          break;\n      }\n      if (node.type === \"property\" || node.parent \u0026\u0026 node.parent.type === \"array\") {\n        var afterCommaOffset = getOffsetAfterNextToken(node.offset + node.length, 5);\n        if (afterCommaOffset !== -1) {\n          result.push(newRange(node.offset, afterCommaOffset));\n        }\n      }\n      node = node.parent;\n    }\n    var current = void 0;\n    for (var index = result.length - 1; index \u003e= 0; index--) {\n      current = SelectionRange.create(result[index], current);\n    }\n    if (!current) {\n      current = SelectionRange.create(Range2.create(position, position));\n    }\n    return current;\n  }\n  function newRange(start, end) {\n    return Range2.create(document2.positionAt(start), document2.positionAt(end));\n  }\n  var scanner = createScanner2(document2.getText(), true);\n  function getOffsetAfterNextToken(offset, expectedToken) {\n    scanner.setPosition(offset);\n    var token = scanner.scan();\n    if (token === expectedToken) {\n      return scanner.getTokenOffset() + scanner.getTokenLength();\n    }\n    return -1;\n  }\n  return positions.map(getSelectionRange);\n}\nfunction findLinks(document2, doc) {\n  var links = [];\n  doc.visit(function(node) {\n    var _a4;\n    if (node.type === \"property\" \u0026\u0026 node.keyNode.value === \"$ref\" \u0026\u0026 ((_a4 = node.valueNode) === null || _a4 === void 0 ? void 0 : _a4.type) === \"string\") {\n      var path = node.valueNode.value;\n      var targetNode = findTargetNode(doc, path);\n      if (targetNode) {\n        var targetPos = document2.positionAt(targetNode.offset);\n        links.push({\n          target: \"\".concat(document2.uri, \"#\").concat(targetPos.line + 1, \",\").concat(targetPos.character + 1),\n          range: createRange(document2, node.valueNode)\n        });\n      }\n    }\n    return true;\n  });\n  return Promise.resolve(links);\n}\nfunction createRange(document2, node) {\n  return Range2.create(document2.positionAt(node.offset + 1), document2.positionAt(node.offset + node.length - 1));\n}\nfunction findTargetNode(doc, path) {\n  var tokens = parseJSONPointer(path);\n  if (!tokens) {\n    return null;\n  }\n  return findNode(tokens, doc.root);\n}\nfunction findNode(pointer, node) {\n  if (!node) {\n    return null;\n  }\n  if (pointer.length === 0) {\n    return node;\n  }\n  var token = pointer.shift();\n  if (node \u0026\u0026 node.type === \"object\") {\n    var propertyNode = node.properties.find(function(propertyNode2) {\n      return propertyNode2.keyNode.value === token;\n    });\n    if (!propertyNode) {\n      return null;\n    }\n    return findNode(pointer, propertyNode.valueNode);\n  } else if (node \u0026\u0026 node.type === \"array\") {\n    if (token.match(/^(0|[1-9][0-9]*)$/)) {\n      var index = Number.parseInt(token);\n      var arrayItem = node.items[index];\n      if (!arrayItem) {\n        return null;\n      }\n      return findNode(pointer, arrayItem);\n    }\n  }\n  return null;\n}\nfunction parseJSONPointer(path) {\n  if (path === \"#\") {\n    return [];\n  }\n  if (path[0] !== \"#\" || path[1] !== \"/\") {\n    return null;\n  }\n  return path.substring(2).split(/\\//).map(unescape);\n}\nfunction unescape(str) {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nfunction getLanguageService(params) {\n  var promise = params.promiseConstructor || Promise;\n  var jsonSchemaService = new JSONSchemaService(params.schemaRequestService, params.workspaceContext, promise);\n  jsonSchemaService.setSchemaContributions(schemaContributions);\n  var jsonCompletion = new JSONCompletion(jsonSchemaService, params.contributions, promise, params.clientCapabilities);\n  var jsonHover = new JSONHover(jsonSchemaService, params.contributions, promise);\n  var jsonDocumentSymbols = new JSONDocumentSymbols(jsonSchemaService);\n  var jsonValidation = new JSONValidation(jsonSchemaService, promise);\n  return {\n    configure: function(settings) {\n      jsonSchemaService.clearExternalSchemas();\n      if (settings.schemas) {\n        settings.schemas.forEach(function(settings2) {\n          jsonSchemaService.registerExternalSchema(settings2.uri, settings2.fileMatch, settings2.schema);\n        });\n      }\n      jsonValidation.configure(settings);\n    },\n    resetSchema: function(uri) {\n      return jsonSchemaService.onResourceChange(uri);\n    },\n    doValidation: jsonValidation.doValidation.bind(jsonValidation),\n    getLanguageStatus: jsonValidation.getLanguageStatus.bind(jsonValidation),\n    parseJSONDocument: function(document2) {\n      return parse3(document2, { collectComments: true });\n    },\n    newJSONDocument: function(root, diagnostics) {\n      return newJSONDocument(root, diagnostics);\n    },\n    getMatchingSchemas: jsonSchemaService.getMatchingSchemas.bind(jsonSchemaService),\n    doResolve: jsonCompletion.doResolve.bind(jsonCompletion),\n    doComplete: jsonCompletion.doComplete.bind(jsonCompletion),\n    findDocumentSymbols: jsonDocumentSymbols.findDocumentSymbols.bind(jsonDocumentSymbols),\n    findDocumentSymbols2: jsonDocumentSymbols.findDocumentSymbols2.bind(jsonDocumentSymbols),\n    findDocumentColors: jsonDocumentSymbols.findDocumentColors.bind(jsonDocumentSymbols),\n    getColorPresentations: jsonDocumentSymbols.getColorPresentations.bind(jsonDocumentSymbols),\n    doHover: jsonHover.doHover.bind(jsonHover),\n    getFoldingRanges,\n    getSelectionRanges,\n    findDefinition: function() {\n      return Promise.resolve([]);\n    },\n    findLinks,\n    format: function(d, r, o) {\n      var range = void 0;\n      if (r) {\n        var offset = d.offsetAt(r.start);\n        var length = d.offsetAt(r.end) - offset;\n        range = { offset, length };\n      }\n      var options = { tabSize: o ? o.tabSize : 4, insertSpaces: (o === null || o === void 0 ? void 0 : o.insertSpaces) === true, insertFinalNewline: (o === null || o === void 0 ? void 0 : o.insertFinalNewline) === true, eol: \"\\n\" };\n      return format2(d.getText(), range, options).map(function(e) {\n        return TextEdit.replace(Range2.create(d.positionAt(e.offset), d.positionAt(e.offset + e.length)), e.content);\n      });\n    }\n  };\n}\nvar defaultSchemaRequestService;\nif (typeof fetch !== \"undefined\") {\n  defaultSchemaRequestService = function(url) {\n    return fetch(url).then((response) =\u003e response.text());\n  };\n}\nvar JSONWorker = class {\n  _ctx;\n  _languageService;\n  _languageSettings;\n  _languageId;\n  constructor(ctx, createData) {\n    this._ctx = ctx;\n    this._languageSettings = createData.languageSettings;\n    this._languageId = createData.languageId;\n    this._languageService = getLanguageService({\n      workspaceContext: {\n        resolveRelativePath: (relativePath, resource) =\u003e {\n          const base = resource.substr(0, resource.lastIndexOf(\"/\") + 1);\n          return resolvePath(base, relativePath);\n        }\n      },\n      schemaRequestService: createData.enableSchemaRequest ? defaultSchemaRequestService : void 0\n    });\n    this._languageService.configure(this._languageSettings);\n  }\n  async doValidation(uri) {\n    let document2 = this._getTextDocument(uri);\n    if (document2) {\n      let jsonDocument = this._languageService.parseJSONDocument(document2);\n      return this._languageService.doValidation(document2, jsonDocument, this._languageSettings);\n    }\n    return Promise.resolve([]);\n  }\n  async doComplete(uri, position) {\n    let document2 = this._getTextDocument(uri);\n    if (!document2) {\n      return null;\n    }\n    let jsonDocument = this._languageService.parseJSONDocument(document2);\n    return this._languageService.doComplete(document2, position, jsonDocument);\n  }\n  async doResolve(item) {\n    return this._languageService.doResolve(item);\n  }\n  async doHover(uri, position) {\n    let document2 = this._getTextDocument(uri);\n    if (!document2) {\n      return null;\n    }\n    let jsonDocument = this._languageService.parseJSONDocument(document2);\n    return this._languageService.doHover(document2, position, jsonDocument);\n  }\n  async format(uri, range, options) {\n    let document2 = this._getTextDocument(uri);\n    if (!document2) {\n      return [];\n    }\n    let textEdits = this._languageService.format(document2, range, options);\n    return Promise.resolve(textEdits);\n  }\n  async resetSchema(uri) {\n    return Promise.resolve(this._languageService.resetSchema(uri));\n  }\n  async findDocumentSymbols(uri) {\n    let document2 = this._getTextDocument(uri);\n    if (!document2) {\n      return [];\n    }\n    let jsonDocument = this._languageService.parseJSONDocument(document2);\n    let symbols = this._languageService.findDocumentSymbols(document2, jsonDocument);\n    return Promise.resolve(symbols);\n  }\n  async findDocumentColors(uri) {\n    let document2 = this._getTextDocument(uri);\n    if (!document2) {\n      return [];\n    }\n    let jsonDocument = this._languageService.parseJSONDocument(document2);\n    let colorSymbols = this._languageService.findDocumentColors(document2, jsonDocument);\n    return Promise.resolve(colorSymbols);\n  }\n  async getColorPresentations(uri, color, range) {\n    let document2 = this._getTextDocument(uri);\n    if (!document2) {\n      return [];\n    }\n    let jsonDocument = this._languageService.parseJSONDocument(document2);\n    let colorPresentations = this._languageService.getColorPresentations(document2, jsonDocument, color, range);\n    return Promise.resolve(colorPresentations);\n  }\n  async getFoldingRanges(uri, context) {\n    let document2 = this._getTextDocument(uri);\n    if (!document2) {\n      return [];\n    }\n    let ranges = this._languageService.getFoldingRanges(document2, context);\n    return Promise.resolve(ranges);\n  }\n  async getSelectionRanges(uri, positions) {\n    let document2 = this._getTextDocument(uri);\n    if (!document2) {\n      return [];\n    }\n    let jsonDocument = this._languageService.parseJSONDocument(document2);\n    let ranges = this._languageService.getSelectionRanges(document2, positions, jsonDocument);\n    return Promise.resolve(ranges);\n  }\n  _getTextDocument(uri) {\n    let models = this._ctx.getMirrorModels();\n    for (let model of models) {\n      if (model.uri.toString() === uri) {\n        return TextDocument2.create(uri, this._languageId, model.version, model.getValue());\n      }\n    }\n    return null;\n  }\n};\nvar Slash = \"/\".charCodeAt(0);\nvar Dot = \".\".charCodeAt(0);\nfunction isAbsolutePath(path) {\n  return path.charCodeAt(0) === Slash;\n}\nfunction resolvePath(uriString, path) {\n  if (isAbsolutePath(path)) {\n    const uri = URI2.parse(uriString);\n    const parts = path.split(\"/\");\n    return uri.with({ path: normalizePath(parts) }).toString();\n  }\n  return joinPath(uriString, path);\n}\nfunction normalizePath(parts) {\n  const newParts = [];\n  for (const part of parts) {\n    if (part.length === 0 || part.length === 1 \u0026\u0026 part.charCodeAt(0) === Dot) {\n    } else if (part.length === 2 \u0026\u0026 part.charCodeAt(0) === Dot \u0026\u0026 part.charCodeAt(1) === Dot) {\n      newParts.pop();\n    } else {\n      newParts.push(part);\n    }\n  }\n  if (parts.length \u003e 1 \u0026\u0026 parts[parts.length - 1].length === 0) {\n    newParts.push(\"\");\n  }\n  let res = newParts.join(\"/\");\n  if (parts[0].length === 0) {\n    res = \"/\" + res;\n  }\n  return res;\n}\nfunction joinPath(uriString, ...paths) {\n  const uri = URI2.parse(uriString);\n  const parts = uri.path.split(\"/\");\n  for (let path of paths) {\n    parts.push(...path.split(\"/\"));\n  }\n  return uri.with({ path: normalizePath(parts) }).toString();\n}\nself.onmessage = () =\u003e {\n  initialize((ctx, createData) =\u003e {\n    return new JSONWorker(ctx, createData);\n  });\n};\n/*! Bundled license information:\n\nmonaco-editor/esm/vs/language/json/json.worker.js:\n  (*!-----------------------------------------------------------------------------\n   * Copyright (c) Microsoft Corporation. All rights reserved.\n   * Version: 0.45.0(5e5af013f8d295555a7210df0d5f2cea0bf5dd56)\n   * Released under the MIT license\n   * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n   *-----------------------------------------------------------------------------*)\n*/\n"
, typeof inject === "string" ? "\n// inject\n" + inject : ""], { type: "application/javascript" }); return new Worker(URL.createObjectURL(blob), { type: "module" })}